/**
* @vue/shared v3.5.14
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}

const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$5 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$5.call(val, key);
const isArray$2 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isFunction$2 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject$2(val) || isFunction$2(val)) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString$1(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};

function normalizeStyle(value) {
  if (isArray$2(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value) || isObject$2(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$1(value)) {
    res = value;
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}

const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}

function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol$1(a);
  bValidType = isSymbol$1(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$2(a);
  bValidType = isArray$2(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$2(a);
  bValidType = isObject$2(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}

const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$2(val) && (val.toString === objectToString$1 || !isFunction$2(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol$1(val)) {
    return stringifySymbol(val);
  } else if (isObject$2(val) && !isArray$2(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol$1(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};

/**
* @vue/reactivity v3.5.14
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    /**
     * @internal
     */
    this._active = true;
    /**
     * @internal track `on` calls, allow `on` call multiple times
     */
    this._on = 0;
    /**
     * @internal
     */
    this.effects = [];
    /**
     * @internal
     */
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}

let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 1 | 4;
    /**
     * @internal
     */
    this.next = void 0;
    /**
     * @internal
     */
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed) {
  if (computed.flags & 4 && !(computed.flags & 16)) {
    return;
  }
  computed.flags &= -17;
  if (computed.globalVersion === globalVersion) {
    return;
  }
  computed.globalVersion = globalVersion;
  if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) {
    return;
  }
  computed.flags |= 2;
  const dep = computed.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed;
  shouldTrack = true;
  try {
    prepareDeps(computed);
    const value = computed.fn(computed._value);
    if (dep.version === 0 || hasChanged(value, computed._value)) {
      computed.flags |= 128;
      computed._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed);
    computed.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}

let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  constructor(computed) {
    this.computed = computed;
    this.version = 0;
    /**
     * Link between this dep and the current active effect
     */
    this.activeLink = void 0;
    /**
     * Doubly linked list representing the subscribing effects (tail)
     */
    this.subs = void 0;
    /**
     * For object property deps cleanup
     */
    this.map = void 0;
    this.key = void 0;
    /**
     * Subscriber counter
     */
    this.sc = 0;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (!!("production" !== "production")) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed = link.dep.computed;
    if (computed && !link.dep.subs) {
      computed.flags |= 4 | 16;
      for (let l = computed.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray$2(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol$1(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}

function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray$2(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toReactive(value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self, method, wrapValue) {
  const arr = shallowReadArray(self);
  const iter = arr[method]();
  if (arr !== self && !isShallow(self)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto$1 = Array.prototype;
function apply(self, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self);
  const needsWrap = arr !== self && !isShallow(self);
  const methodFn = arr[method];
  if (methodFn !== arrayProto$1[method]) {
    const result2 = methodFn.apply(self, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toReactive(item), index, self);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self, method, fn, args) {
  const arr = shallowReadArray(self);
  let wrappedFn = fn;
  if (arr !== self) {
    if (!isShallow(self)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toReactive(item), index, self);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self, method, args) {
  const arr = toRaw(self);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self)[method].apply(self, args);
  endBatch();
  resetTracking();
  return res;
}

const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
);
function hasOwnProperty$4(key) {
  if (!isSymbol$1(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$2(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$4;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$2(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$2(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
      !readonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend(
    instrumentations,
    readonly ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0);
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};

const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1 /* COMMON */;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2 /* COLLECTION */;
    default:
      return 0 /* INVALID */;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$2(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0 /* INVALID */) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;

function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}

class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    /**
     * @internal
     */
    this._value = void 0;
    /**
     * @internal
     */
    this.dep = new Dep(this);
    /**
     * @internal
     */
    this.__v_isRef = true;
    // TODO isolatedDeclarations "__v_isReadonly"
    // A computed is also a subscriber that tracks other deps
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 16;
    /**
     * @internal
     */
    this.globalVersion = globalVersion - 1;
    /**
     * @internal
     */
    this.next = void 0;
    // for backwards compat
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction$2(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$2(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$2(s)) {
        return call ? call(s, 2) : s();
      } else ;
    });
  } else if (isFunction$2(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect.stop();
    if (scope && scope.active) {
      remove(scope.effects, effect);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
          oldValue = newValue;
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect = new ReactiveEffect(getter);
  effect.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);
  cleanup = effect.onStop = () => {
    const cleanups = cleanupMap.get(effect);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect.run();
  }
  watchHandle.pause = effect.pause.bind(effect);
  watchHandle.resume = effect.resume.bind(effect);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject$2(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}

/**
* @vue/runtime-core v3.5.14
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$1(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$2(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$2(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray$2(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$2(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= -2;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction$2(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c of children) {
      if (c.type !== Comment) {
        child = c;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$2(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey]) {
        el[enterCbKey](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  if (vnode.component) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction$2(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$2(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$2(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
    return hasOwn(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    if (isString$1(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$2(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString$1(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$2(existing) && remove(existing, refValue);
          } else {
            if (!isArray$2(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          ref3.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$1(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve$1(instance[type] || Component[type], name) || // global registration
      resolve$1(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve$1(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache;
  const sourceIsArray = isArray$2(source);
  if (sourceIsArray || isString$1(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    let isReadonlySource = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      isReadonlySource = isReadonly(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i])) : toReactive(source[i]) : source[i],
        i,
        void 0,
        cached
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached);
    }
  } else if (isObject$2(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached)
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol$1(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i) ,
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i) 
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$2(props) ? props.reduce(
    (normalized, p) => (normalized[p] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$2(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$2(data)) ; else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$2(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$2(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$2(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$2(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$1(raw)) {
    const handler = ctx[raw];
    if (isFunction$2(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction$2(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject$2(raw)) {
    if (isArray$2(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$2(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$2(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ; else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction$2(to) ? to.call(this, this) : to,
      isFunction$2(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$2(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$2(to) && isArray$2(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!isFunction$2(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$2(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ; else if (plugin && isFunction$2(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$2(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance) ; else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$2(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? { type: opt } : extend({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray$2(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = isFunction$2(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction$2(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$2(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if (isFunction$2(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || !isInternalKey(key)) {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        {
          if (root.ce) {
            root.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => {
          if (vnode.ctx.isUnmounted) {
            hostRemove(el);
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      pauseTracking();
      setRef(ref3, null, parentSuspense, vnode, true);
      resetTracking();
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const {
      bum,
      scope,
      job,
      subTree,
      um,
      m,
      a,
      parent,
      slots: { __: slotCacheKeys }
    } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    if (parent && isArray$2(slotCacheKeys)) {
      slotCacheKeys.forEach((v) => {
        parent.renderCache[v] = void 0;
      });
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  return {
    render,
    hydrate,
    createApp: createAppAPI(render)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= -33;
    job.flags &= -5;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$2(ch1) && isArray$2(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$2(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$2(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$2(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false) ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$2(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$2(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$2(style)) {
      if (isProxy(style) && !isArray$2(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$2(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$2(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$2(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$2(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$2 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$2++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set) => set(v));
      else setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized || isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    pauseTracking();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise(setupResult);
    resetTracking();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult);
    }
  } else {
    finishComponentSetup(instance);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$2(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$2(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance);
}
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    instance.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$2(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c;
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$2(propsOrChildren) && !isArray$2(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version$1 = "3.5.14";
const warn = NOOP;

/**
* @vue/runtime-dom v3.5.14
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if (isArray$2(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done, isCancelled) => {
    el._enterCancelled = isCancelled;
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (!el._enterCancelled) {
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
      } else {
        addTransitionClass(el, leaveActiveClass);
        forceReflow();
      }
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false, void 0, true);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true, void 0, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$2(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
const CSS_VAR_TEXT = Symbol("");
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$1(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString$1(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle$1(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle$1(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle$1(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle$1(style, name, val) {
  if (isArray$2(val)) {
    val.forEach((v) => setStyle$1(style, name, v));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : isSymbol$1(value) ? String(value) : value
      );
    }
  }
}
function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(attrName || key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$2(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString$1(nextValue))
  ) {
    patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$2(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$1(value)) {
    return false;
  }
  return key in el;
}
const REMOVAL = {};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, extraOptions, _createApp) {
  const Comp = defineComponent(options, extraOptions);
  if (isPlainObject(Comp)) extend(Comp, extraOptions);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, _createApp);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, _createApp = createApp) {
    super();
    this._def = _def;
    this._props = _props;
    this._createApp = _createApp;
    this._isVueCE = true;
    this._instance = null;
    this._app = null;
    this._nonce = this._def.nonce;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._styleChildren = /* @__PURE__ */ new WeakSet();
    this._ob = null;
    if (this.shadowRoot && _createApp !== createApp) {
      this._root = this.shadowRoot;
    } else {
      if (_def.shadowRoot !== false) {
        this.attachShadow({ mode: "open" });
        this._root = this.shadowRoot;
      } else {
        this._root = this;
      }
    }
    if (!this._def.__asyncLoader) {
      this._resolveProps(this._def);
    }
  }
  connectedCallback() {
    if (!this.isConnected) return;
    if (!this.shadowRoot) {
      this._parseSlots();
    }
    this._connected = true;
    let parent = this;
    while (parent = parent && (parent.parentNode || parent.host)) {
      if (parent instanceof VueElement) {
        this._parent = parent;
        break;
      }
    }
    if (!this._instance) {
      if (this._resolved) {
        this._setParent();
        this._update();
      } else {
        if (parent && parent._pendingResolve) {
          this._pendingResolve = parent._pendingResolve.then(() => {
            this._pendingResolve = void 0;
            this._resolveDef();
          });
        } else {
          this._resolveDef();
        }
      }
    }
  }
  _setParent(parent = this._parent) {
    if (parent) {
      this._instance.parent = parent._instance;
      this._instance.provides = parent._instance.provides;
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        if (this._ob) {
          this._ob.disconnect();
          this._ob = null;
        }
        this._app && this._app.unmount();
        if (this._instance) this._instance.ce = void 0;
        this._app = this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve) {
      return;
    }
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve = (def, isAsync = false) => {
      this._resolved = true;
      this._pendingResolve = void 0;
      const { props, styles } = def;
      let numberProps;
      if (props && !isArray$2(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def);
      }
      if (this.shadowRoot) {
        this._applyStyles(styles);
      }
      this._mount(def);
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      this._pendingResolve = asyncDef().then(
        (def) => resolve(this._def = def, true)
      );
    } else {
      resolve(this._def);
    }
  }
  _mount(def) {
    this._app = this._createApp(def);
    if (def.configureApp) {
      def.configureApp(this._app);
    }
    this._app._ceVNode = this._createVNode();
    this._app.mount(this._root);
    const exposed = this._instance && this._instance.exposed;
    if (!exposed) return;
    for (const key in exposed) {
      if (!hasOwn(this, key)) {
        Object.defineProperty(this, key, {
          // unwrap ref to be consistent with public instance behavior
          get: () => unref(exposed[key])
        });
      }
    }
  }
  _resolveProps(def) {
    const { props } = def;
    const declaredPropKeys = isArray$2(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key]);
      }
    }
    for (const key of declaredPropKeys.map(camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val, true, true);
        }
      });
    }
  }
  _setAttr(key) {
    if (key.startsWith("data-v-")) return;
    const has = this.hasAttribute(key);
    let value = has ? this.getAttribute(key) : REMOVAL;
    const camelKey = camelize(key);
    if (has && this._numberProps && this._numberProps[camelKey]) {
      value = toNumber(value);
    }
    this._setProp(camelKey, value, false, true);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
    if (val !== this._props[key]) {
      if (val === REMOVAL) {
        delete this._props[key];
      } else {
        this._props[key] = val;
        if (key === "key" && this._app) {
          this._app._ceVNode.key = val;
        }
      }
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        const ob = this._ob;
        ob && ob.disconnect();
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
        ob && ob.observe(this, { attributes: true });
      }
    }
  }
  _update() {
    render(this._createVNode(), this._root);
  }
  _createVNode() {
    const baseProps = {};
    if (!this.shadowRoot) {
      baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
    }
    const vnode = createVNode(this._def, extend(baseProps, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.ce = this;
        instance.isCE = true;
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(
              event,
              isPlainObject(args[0]) ? extend({ detail: args }, args[0]) : { detail: args }
            )
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if (hyphenate(event) !== event) {
            dispatch(hyphenate(event), args);
          }
        };
        this._setParent();
      };
    }
    return vnode;
  }
  _applyStyles(styles, owner) {
    if (!styles) return;
    if (owner) {
      if (owner === this._def || this._styleChildren.has(owner)) {
        return;
      }
      this._styleChildren.add(owner);
    }
    const nonce = this._nonce;
    for (let i = styles.length - 1; i >= 0; i--) {
      const s = document.createElement("style");
      if (nonce) s.setAttribute("nonce", nonce);
      s.textContent = styles[i];
      this.shadowRoot.prepend(s);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const slots = this._slots = {};
    let n;
    while (n = this.firstChild) {
      const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
      (slots[slotName] || (slots[slotName] = [])).push(n);
      this.removeChild(n);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const outlets = (this._teleportTarget || this).querySelectorAll("slot");
    const scopeId = this._instance.type.__scopeId;
    for (let i = 0; i < outlets.length; i++) {
      const o = outlets[i];
      const slotName = o.getAttribute("name") || "default";
      const content = this._slots[slotName];
      const parent = o.parentNode;
      if (content) {
        for (const n of content) {
          if (scopeId && n.nodeType === 1) {
            const id = scopeId + "-s";
            const walker = document.createTreeWalker(n, 1);
            n.setAttribute(id, "");
            let child;
            while (child = walker.nextNode()) {
              child.setAttribute(id, "");
            }
          }
          parent.insertBefore(n, o);
        }
      } else {
        while (o.firstChild) parent.insertBefore(o.firstChild, o);
      }
      parent.removeChild(o);
    }
  }
  /**
   * @internal
   */
  _injectChildStyle(comp) {
    this._applyStyles(comp.styles, comp);
  }
  /**
   * @internal
   */
  _removeChildStyle(comp) {
  }
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$2(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
const assignKey = Symbol("_assign");
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue$1(o)) : getValue$1(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    if (!el._assigning) {
      setSelected(el, value);
    }
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray$2(value);
  if (isMultiple && !isArrayValue && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue$1(option);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value.some((v) => String(v) === String(optionValue));
        } else {
          option.selected = looseIndexOf(value, optionValue) > -1;
        }
      } else {
        option.selected = value.has(optionValue);
      }
    } else if (looseEqual(getValue$1(option), value)) {
      if (el.selectedIndex !== i) el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue$1(el) {
  return "_value" in el ? el._value : el.value;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!isFunction$2(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString$1(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}

const configProviderContextKey = Symbol();

const defaultNamespace = "el";
const statePrefix = "is-";
const _bem = (namespace, block, blockSuffix, element, modifier) => {
  let cls = `${namespace}-${block}`;
  if (blockSuffix) {
    cls += `-${blockSuffix}`;
  }
  if (element) {
    cls += `__${element}`;
  }
  if (modifier) {
    cls += `--${modifier}`;
  }
  return cls;
};
const namespaceContextKey = Symbol("namespaceContextKey");
const useGetDerivedNamespace = (namespaceOverrides) => {
  const derivedNamespace = namespaceOverrides || (getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace));
  const namespace = computed(() => {
    return unref(derivedNamespace) || defaultNamespace;
  });
  return namespace;
};
const useNamespace = (block, namespaceOverrides) => {
  const namespace = useGetDerivedNamespace(namespaceOverrides);
  const b = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
  const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
  const m = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
  const be = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
  const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
  const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
  const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
  const is = (name, ...args) => {
    const state = args.length >= 1 ? args[0] : true;
    return name && state ? `${statePrefix}${name}` : "";
  };
  const cssVar = (object) => {
    const styles = {};
    for (const key in object) {
      if (object[key]) {
        styles[`--${namespace.value}-${key}`] = object[key];
      }
    }
    return styles;
  };
  const cssVarBlock = (object) => {
    const styles = {};
    for (const key in object) {
      if (object[key]) {
        styles[`--${namespace.value}-${block}-${key}`] = object[key];
      }
    }
    return styles;
  };
  const cssVarName = (name) => `--${namespace.value}-${name}`;
  const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
  return {
    namespace,
    b,
    e,
    m,
    be,
    em,
    bm,
    bem,
    is,
    cssVar,
    cssVarName,
    cssVarBlock,
    cssVarBlockName
  };
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$4.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$3.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$1 = Array.isArray;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray$1(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$1(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$1(value) {
  if (!isObject$1(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$1 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$2 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq$1(value, other) {
  return value === other || (value !== value && other !== other);
}

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }
  return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root, 'Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$1 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray$1(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * The inverse of `_.toPairs`; this method returns an object composed
 * from key-value `pairs`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} pairs The key-value pairs.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.fromPairs([['a', 1], ['b', 2]]);
 * // => { 'a': 1, 'b': 2 }
 */
function fromPairs(pairs) {
  var index = -1,
      length = pairs == null ? 0 : pairs.length,
      result = {};

  while (++index < length) {
    var pair = pairs[index];
    result[pair[0]] = pair[1];
  }
  return result;
}

const isUndefined = (val) => val === void 0;
const isBoolean = (val) => typeof val === "boolean";
const isNumber$1 = (val) => typeof val === "number";
const isElement = (e) => {
  if (typeof Element === "undefined")
    return false;
  return e instanceof Element;
};
const isStringNumber = (val) => {
  if (!isString$1(val)) {
    return false;
  }
  return !Number.isNaN(Number(val));
};

var _a;
const isClient = typeof window !== "undefined";
const isString = (val) => typeof val === "string";
const noop$1 = () => {
};
isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);

function resolveUnref(r) {
  return typeof r === "function" ? r() : unref(r);
}
function identity(arg) {
  return arg;
}

function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}

function tryOnMounted(fn, sync = true) {
  if (getCurrentInstance())
    onMounted(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}

function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = ref(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    isPending.value = false;
    clear();
  }
  function start(...args) {
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, resolveUnref(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start();
  }
  tryOnScopeDispose(stop);
  return {
    isPending: readonly(isPending),
    start,
    stop
  };
}

function unrefElement(elRef) {
  var _a;
  const plain = resolveUnref(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}

const defaultWindow = isClient ? window : void 0;

function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (isString(args[0]) || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop$1;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {
    cleanup();
    if (!el)
      return;
    cleanups.push(...events.flatMap((event) => {
      return listeners.map((listener) => register(el, event, listener, options2));
    }));
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}

function useSupported(callback, sync = false) {
  const isSupported = ref();
  const update = () => isSupported.value = Boolean(callback());
  update();
  tryOnMounted(update, sync);
  return isSupported;
}

const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};

var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
var __hasOwnProp$g = Object.prototype.hasOwnProperty;
var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$g)
    for (var prop of __getOwnPropSymbols$g(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useResizeObserver(target, callback, options = {}) {
  const _a = options, { window = defaultWindow } = _a, observerOptions = __objRest$2(_a, ["window"]);
  let observer;
  const isSupported = useSupported(() => window && "ResizeObserver" in window);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (isSupported.value && window && el) {
      observer = new ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  }, { immediate: true, flush: "post" });
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}

var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
__spreadValues({
  linear: identity
}, _TransitionPresets);

const initial = {
  current: 0
};
const zIndex = ref(0);
const defaultInitialZIndex = 2e3;
const ZINDEX_INJECTION_KEY = Symbol("elZIndexContextKey");
const zIndexContextKey = Symbol("zIndexContextKey");
const useZIndex = (zIndexOverrides) => {
  const increasingInjection = getCurrentInstance() ? inject(ZINDEX_INJECTION_KEY, initial) : initial;
  const zIndexInjection = zIndexOverrides || (getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0);
  const initialZIndex = computed(() => {
    const zIndexFromInjection = unref(zIndexInjection);
    return isNumber$1(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
  });
  const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
  const nextZIndex = () => {
    increasingInjection.current++;
    zIndex.value = increasingInjection.current;
    return currentZIndex.value;
  };
  if (!isClient && !inject(ZINDEX_INJECTION_KEY)) ;
  return {
    initialZIndex,
    currentZIndex,
    nextZIndex
  };
};

var English = {
  name: "en",
  el: {
    breadcrumb: {
      label: "Breadcrumb"
    },
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color.",
      alphaLabel: "pick alpha value"
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    mention: {
      loading: "Loading"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tour: {
      next: "Next",
      previous: "Previous",
      finish: "Finish"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    },
    carousel: {
      leftArrow: "Carousel arrow left",
      rightArrow: "Carousel arrow right",
      indicator: "Carousel switch to index {index}"
    }
  }
};

const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_, key) => {
  var _a;
  return `${(_a = option == null ? void 0 : option[key]) != null ? _a : `{${key}}`}`;
});
const buildLocaleContext = (locale) => {
  const lang = computed(() => unref(locale).name);
  const localeRef = isRef(locale) ? locale : ref(locale);
  return {
    lang,
    locale: localeRef,
    t: buildTranslator(locale)
  };
};
const localeContextKey = Symbol("localeContextKey");
const useLocale = (localeOverrides) => {
  const locale = localeOverrides || inject(localeContextKey, ref());
  return buildLocaleContext(computed(() => locale.value || English));
};

const epPropKey = "__epPropKey";
const definePropType = (val) => val;
const isEpProp = (val) => isObject$2(val) && !!val[epPropKey];
const buildProp = (prop, key) => {
  if (!isObject$2(prop) || isEpProp(prop))
    return prop;
  const { values, required, default: defaultValue, type, validator } = prop;
  const _validator = values || validator ? (val) => {
    let valid = false;
    let allowedValues = [];
    if (values) {
      allowedValues = Array.from(values);
      if (hasOwn(prop, "default")) {
        allowedValues.push(defaultValue);
      }
      valid || (valid = allowedValues.includes(val));
    }
    if (validator)
      valid || (valid = validator(val));
    if (!valid && allowedValues.length > 0) {
      const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
      warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
    }
    return valid;
  } : void 0;
  const epProp = {
    type,
    required: !!required,
    validator: _validator,
    [epPropKey]: true
  };
  if (hasOwn(prop, "default"))
    epProp.default = defaultValue;
  return epProp;
};
const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
  key,
  buildProp(option, key)
]));

const componentSizes = ["", "default", "small", "large"];

const useSizeProp = buildProp({
  type: String,
  values: componentSizes,
  required: false
});
const SIZE_INJECTION_KEY = Symbol("size");

const emptyValuesContextKey = Symbol("emptyValuesContextKey");
const useEmptyValuesProps = buildProps({
  emptyValues: Array,
  valueOnClear: {
    type: [String, Number, Boolean, Function],
    default: void 0,
    validator: (val) => isFunction$2(val) ? !val() : !val
  }
});

const keysOf = (arr) => Object.keys(arr);

const globalConfig = ref();
function useGlobalConfig(key, defaultValue = void 0) {
  const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
  {
    return config;
  }
}
function useGlobalComponentSettings(block, sizeFallback) {
  const config = useGlobalConfig();
  const ns = useNamespace(block, computed(() => {
    var _a;
    return ((_a = config.value) == null ? void 0 : _a.namespace) || defaultNamespace;
  }));
  const locale = useLocale(computed(() => {
    var _a;
    return (_a = config.value) == null ? void 0 : _a.locale;
  }));
  const zIndex = useZIndex(computed(() => {
    var _a;
    return ((_a = config.value) == null ? void 0 : _a.zIndex) || defaultInitialZIndex;
  }));
  const size = computed(() => {
    var _a;
    return unref(sizeFallback) || ((_a = config.value) == null ? void 0 : _a.size) || "";
  });
  provideGlobalConfig(computed(() => unref(config) || {}));
  return {
    ns,
    locale,
    zIndex,
    size
  };
}
const provideGlobalConfig = (config, app, global = false) => {
  var _a;
  const inSetup = !!getCurrentInstance();
  const oldConfig = inSetup ? useGlobalConfig() : void 0;
  const provideFn = (_a = void 0 ) != null ? _a : inSetup ? provide : void 0;
  if (!provideFn) {
    return;
  }
  const context = computed(() => {
    const cfg = unref(config);
    if (!(oldConfig == null ? void 0 : oldConfig.value))
      return cfg;
    return mergeConfig(oldConfig.value, cfg);
  });
  provideFn(configProviderContextKey, context);
  provideFn(localeContextKey, computed(() => context.value.locale));
  provideFn(namespaceContextKey, computed(() => context.value.namespace));
  provideFn(zIndexContextKey, computed(() => context.value.zIndex));
  provideFn(SIZE_INJECTION_KEY, {
    size: computed(() => context.value.size || "")
  });
  provideFn(emptyValuesContextKey, computed(() => ({
    emptyValues: context.value.emptyValues,
    valueOnClear: context.value.valueOnClear
  })));
  if (global || !globalConfig.value) {
    globalConfig.value = context.value;
  }
  return context;
};
const mergeConfig = (a, b) => {
  const keys = [.../* @__PURE__ */ new Set([...keysOf(a), ...keysOf(b)])];
  const obj = {};
  for (const key of keys) {
    obj[key] = b[key] !== void 0 ? b[key] : a[key];
  }
  return obj;
};

var _export_sfc$1 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

function addUnit(value, defaultUnit = "px") {
  if (!value)
    return "";
  if (isNumber$1(value) || isStringNumber(value)) {
    return `${value}${defaultUnit}`;
  } else if (isString$1(value)) {
    return value;
  }
}

const withInstall = (main, extra) => {
  main.install = (app) => {
    for (const comp of [main, ...Object.values({})]) {
      app.component(comp.name, comp);
    }
  };
  return main;
};
const withInstallFunction = (fn, name) => {
  fn.install = (app) => {
    fn._context = app._context;
    app.config.globalProperties[name] = fn;
  };
  return fn;
};

const iconProps = buildProps({
  size: {
    type: definePropType([Number, String])
  },
  color: {
    type: String
  }
});

const __default__$2 = defineComponent({
  name: "ElIcon",
  inheritAttrs: false
});
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  ...__default__$2,
  props: iconProps,
  setup(__props) {
    const props = __props;
    const ns = useNamespace("icon");
    const style = computed(() => {
      const { size, color } = props;
      if (!size && !color)
        return {};
      return {
        fontSize: isUndefined(size) ? void 0 : addUnit(size),
        "--color": color
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("i", mergeProps({
        class: unref(ns).b(),
        style: unref(style)
      }, _ctx.$attrs), [
        renderSlot(_ctx.$slots, "default")
      ], 16);
    };
  }
});
var Icon = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__file", "icon.vue"]]);

const ElIcon = withInstall(Icon);

/*! Element Plus Icons Vue v2.3.1 */

var circle_close_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  name: "CircleCloseFilled",
  __name: "circle-close-filled",
  setup(__props) {
    return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
      })
    ]));
  }
});

// src/components/circle-close-filled.vue
var circle_close_filled_default = circle_close_filled_vue_vue_type_script_setup_true_lang_default;
var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  name: "Close",
  __name: "close",
  setup(__props) {
    return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      createBaseVNode("path", {
        fill: "currentColor",
        d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
      })
    ]));
  }
});

// src/components/close.vue
var close_default = close_vue_vue_type_script_setup_true_lang_default;
var info_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  name: "InfoFilled",
  __name: "info-filled",
  setup(__props) {
    return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
      })
    ]));
  }
});

// src/components/info-filled.vue
var info_filled_default = info_filled_vue_vue_type_script_setup_true_lang_default;
var success_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  name: "SuccessFilled",
  __name: "success-filled",
  setup(__props) {
    return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
      })
    ]));
  }
});

// src/components/success-filled.vue
var success_filled_default = success_filled_vue_vue_type_script_setup_true_lang_default;
var warning_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  name: "WarningFilled",
  __name: "warning-filled",
  setup(__props) {
    return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
      })
    ]));
  }
});

// src/components/warning-filled.vue
var warning_filled_default = warning_filled_vue_vue_type_script_setup_true_lang_default;

const iconPropType = definePropType([
  String,
  Object,
  Function
]);
const TypeComponents = {
  Close: close_default};
const TypeComponentsMap = {
  primary: info_filled_default,
  success: success_filled_default,
  warning: warning_filled_default,
  error: circle_close_filled_default,
  info: info_filled_default
};

const mutable = (val) => val;

const EVENT_CODE = {
  esc: "Escape"};

const badgeProps = buildProps({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  },
  showZero: {
    type: Boolean,
    default: true
  },
  color: String,
  badgeStyle: {
    type: definePropType([String, Object, Array])
  },
  offset: {
    type: definePropType(Array),
    default: [0, 0]
  },
  badgeClass: {
    type: String
  }
});

const __default__$1 = defineComponent({
  name: "ElBadge"
});
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  ...__default__$1,
  props: badgeProps,
  setup(__props, { expose }) {
    const props = __props;
    const ns = useNamespace("badge");
    const content = computed(() => {
      if (props.isDot)
        return "";
      if (isNumber$1(props.value) && isNumber$1(props.max)) {
        return props.max < props.value ? `${props.max}+` : `${props.value}`;
      }
      return `${props.value}`;
    });
    const style = computed(() => {
      var _a, _b, _c, _d, _e;
      return [
        {
          backgroundColor: props.color,
          marginRight: addUnit(-((_b = (_a = props.offset) == null ? void 0 : _a[0]) != null ? _b : 0)),
          marginTop: addUnit((_d = (_c = props.offset) == null ? void 0 : _c[1]) != null ? _d : 0)
        },
        (_e = props.badgeStyle) != null ? _e : {}
      ];
    });
    expose({
      content
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(ns).b())
      }, [
        renderSlot(_ctx.$slots, "default"),
        createVNode(Transition, {
          name: `${unref(ns).namespace.value}-zoom-in-center`,
          persisted: ""
        }, {
          default: withCtx(() => [
            withDirectives(createBaseVNode("sup", {
              class: normalizeClass([
                unref(ns).e("content"),
                unref(ns).em("content", _ctx.type),
                unref(ns).is("fixed", !!_ctx.$slots.default),
                unref(ns).is("dot", _ctx.isDot),
                unref(ns).is("hide-zero", !_ctx.showZero && props.value === 0),
                _ctx.badgeClass
              ]),
              style: normalizeStyle(unref(style))
            }, [
              renderSlot(_ctx.$slots, "content", { value: unref(content) }, () => [
                createTextVNode(toDisplayString(unref(content)), 1)
              ])
            ], 6), [
              [vShow, !_ctx.hidden && (unref(content) || _ctx.isDot || _ctx.$slots.content)]
            ])
          ]),
          _: 3
        }, 8, ["name"])
      ], 2);
    };
  }
});
var Badge = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["__file", "badge.vue"]]);

const ElBadge = withInstall(Badge);

buildProps({
  a11y: {
    type: Boolean,
    default: true
  },
  locale: {
    type: definePropType(Object)
  },
  size: useSizeProp,
  button: {
    type: definePropType(Object)
  },
  link: {
    type: definePropType(Object)
  },
  experimentalFeatures: {
    type: definePropType(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: true
  },
  message: {
    type: definePropType(Object)
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  },
  ...useEmptyValuesProps
});

const messageConfig = {};

const messageTypes = [
  "primary",
  "success",
  "info",
  "warning",
  "error"
];
const messageDefaults = mutable({
  customClass: "",
  dangerouslyUseHTMLString: false,
  duration: 3e3,
  icon: void 0,
  id: "",
  message: "",
  onClose: void 0,
  showClose: false,
  type: "info",
  plain: false,
  offset: 16,
  zIndex: 0,
  grouping: false,
  repeatNum: 1,
  appendTo: isClient ? document.body : void 0
});
const messageProps = buildProps({
  customClass: {
    type: String,
    default: messageDefaults.customClass
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: messageDefaults.dangerouslyUseHTMLString
  },
  duration: {
    type: Number,
    default: messageDefaults.duration
  },
  icon: {
    type: iconPropType,
    default: messageDefaults.icon
  },
  id: {
    type: String,
    default: messageDefaults.id
  },
  message: {
    type: definePropType([
      String,
      Object,
      Function
    ]),
    default: messageDefaults.message
  },
  onClose: {
    type: definePropType(Function),
    default: messageDefaults.onClose
  },
  showClose: {
    type: Boolean,
    default: messageDefaults.showClose
  },
  type: {
    type: String,
    values: messageTypes,
    default: messageDefaults.type
  },
  plain: {
    type: Boolean,
    default: messageDefaults.plain
  },
  offset: {
    type: Number,
    default: messageDefaults.offset
  },
  zIndex: {
    type: Number,
    default: messageDefaults.zIndex
  },
  grouping: {
    type: Boolean,
    default: messageDefaults.grouping
  },
  repeatNum: {
    type: Number,
    default: messageDefaults.repeatNum
  }
});
const messageEmits = {
  destroy: () => true
};

const instances$1 = shallowReactive([]);
const getInstance = (id) => {
  const idx = instances$1.findIndex((instance) => instance.id === id);
  const current = instances$1[idx];
  let prev;
  if (idx > 0) {
    prev = instances$1[idx - 1];
  }
  return { current, prev };
};
const getLastOffset = (id) => {
  const { prev } = getInstance(id);
  if (!prev)
    return 0;
  return prev.vm.exposed.bottom.value;
};
const getOffsetOrSpace = (id, offset) => {
  const idx = instances$1.findIndex((instance) => instance.id === id);
  return idx > 0 ? 16 : offset;
};

const __default__ = defineComponent({
  name: "ElMessage"
});
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  ...__default__,
  props: messageProps,
  emits: messageEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const { Close } = TypeComponents;
    const isStartTransition = ref(false);
    const { ns, zIndex } = useGlobalComponentSettings("message");
    const { currentZIndex, nextZIndex } = zIndex;
    const messageRef = ref();
    const visible = ref(false);
    const height = ref(0);
    let stopTimer = void 0;
    const badgeType = computed(() => props.type ? props.type === "error" ? "danger" : props.type : "info");
    const typeClass = computed(() => {
      const type = props.type;
      return { [ns.bm("icon", type)]: type && TypeComponentsMap[type] };
    });
    const iconComponent = computed(() => props.icon || TypeComponentsMap[props.type] || "");
    const lastOffset = computed(() => getLastOffset(props.id));
    const offset = computed(() => getOffsetOrSpace(props.id, props.offset) + lastOffset.value);
    const bottom = computed(() => height.value + offset.value);
    const customStyle = computed(() => ({
      top: `${offset.value}px`,
      zIndex: currentZIndex.value
    }));
    function startTimer() {
      if (props.duration === 0)
        return;
      ({ stop: stopTimer } = useTimeoutFn(() => {
        close();
      }, props.duration));
    }
    function clearTimer() {
      stopTimer == null ? void 0 : stopTimer();
    }
    function close() {
      visible.value = false;
      nextTick(() => {
        var _a;
        if (!isStartTransition.value) {
          (_a = props.onClose) == null ? void 0 : _a.call(props);
          emit("destroy");
        }
      });
    }
    function keydown({ code }) {
      if (code === EVENT_CODE.esc) {
        close();
      }
    }
    onMounted(() => {
      startTimer();
      nextZIndex();
      visible.value = true;
    });
    watch(() => props.repeatNum, () => {
      clearTimer();
      startTimer();
    });
    useEventListener(document, "keydown", keydown);
    useResizeObserver(messageRef, () => {
      height.value = messageRef.value.getBoundingClientRect().height;
    });
    expose({
      visible,
      bottom,
      close
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        name: unref(ns).b("fade"),
        onBeforeEnter: ($event) => isStartTransition.value = true,
        onBeforeLeave: _ctx.onClose,
        onAfterLeave: ($event) => _ctx.$emit("destroy"),
        persisted: ""
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            id: _ctx.id,
            ref_key: "messageRef",
            ref: messageRef,
            class: normalizeClass([
              unref(ns).b(),
              { [unref(ns).m(_ctx.type)]: _ctx.type },
              unref(ns).is("closable", _ctx.showClose),
              unref(ns).is("plain", _ctx.plain),
              _ctx.customClass
            ]),
            style: normalizeStyle(unref(customStyle)),
            role: "alert",
            onMouseenter: clearTimer,
            onMouseleave: startTimer
          }, [
            _ctx.repeatNum > 1 ? (openBlock(), createBlock(unref(ElBadge), {
              key: 0,
              value: _ctx.repeatNum,
              type: unref(badgeType),
              class: normalizeClass(unref(ns).e("badge"))
            }, null, 8, ["value", "type", "class"])) : createCommentVNode("v-if", true),
            unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
              key: 1,
              class: normalizeClass([unref(ns).e("icon"), unref(typeClass)])
            }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
              ]),
              _: 1
            }, 8, ["class"])) : createCommentVNode("v-if", true),
            renderSlot(_ctx.$slots, "default", {}, () => [
              !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", {
                key: 0,
                class: normalizeClass(unref(ns).e("content"))
              }, toDisplayString(_ctx.message), 3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                createBaseVNode("p", {
                  class: normalizeClass(unref(ns).e("content")),
                  innerHTML: _ctx.message
                }, null, 10, ["innerHTML"])
              ], 2112))
            ]),
            _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
              key: 2,
              class: normalizeClass(unref(ns).e("closeBtn")),
              onClick: withModifiers(close, ["stop"])
            }, {
              default: withCtx(() => [
                createVNode(unref(Close))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
          ], 46, ["id"]), [
            [vShow, visible.value]
          ])
        ]),
        _: 3
      }, 8, ["name", "onBeforeEnter", "onBeforeLeave", "onAfterLeave"]);
    };
  }
});
var MessageConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["__file", "message.vue"]]);

let seed = 1;
const normalizeOptions = (params) => {
  const options = !params || isString$1(params) || isVNode(params) || isFunction$2(params) ? { message: params } : params;
  const normalized = {
    ...messageDefaults,
    ...options
  };
  if (!normalized.appendTo) {
    normalized.appendTo = document.body;
  } else if (isString$1(normalized.appendTo)) {
    let appendTo = document.querySelector(normalized.appendTo);
    if (!isElement(appendTo)) {
      appendTo = document.body;
    }
    normalized.appendTo = appendTo;
  }
  if (isBoolean(messageConfig.grouping) && !normalized.grouping) {
    normalized.grouping = messageConfig.grouping;
  }
  if (isNumber$1(messageConfig.duration) && normalized.duration === 3e3) {
    normalized.duration = messageConfig.duration;
  }
  if (isNumber$1(messageConfig.offset) && normalized.offset === 16) {
    normalized.offset = messageConfig.offset;
  }
  if (isBoolean(messageConfig.showClose) && !normalized.showClose) {
    normalized.showClose = messageConfig.showClose;
  }
  if (isBoolean(messageConfig.plain) && !normalized.plain) {
    normalized.plain = messageConfig.plain;
  }
  return normalized;
};
const closeMessage = (instance) => {
  const idx = instances$1.indexOf(instance);
  if (idx === -1)
    return;
  instances$1.splice(idx, 1);
  const { handler } = instance;
  handler.close();
};
const createMessage = ({ appendTo, ...options }, context) => {
  const id = `message_${seed++}`;
  const userOnClose = options.onClose;
  const container = document.createElement("div");
  const props = {
    ...options,
    id,
    onClose: () => {
      userOnClose == null ? void 0 : userOnClose();
      closeMessage(instance);
    },
    onDestroy: () => {
      render(null, container);
    }
  };
  const vnode = createVNode(MessageConstructor, props, isFunction$2(props.message) || isVNode(props.message) ? {
    default: isFunction$2(props.message) ? props.message : () => props.message
  } : null);
  vnode.appContext = context || message._context;
  render(vnode, container);
  appendTo.appendChild(container.firstElementChild);
  const vm = vnode.component;
  const handler = {
    close: () => {
      vm.exposed.close();
    }
  };
  const instance = {
    id,
    vnode,
    vm,
    handler,
    props: vnode.component.props
  };
  return instance;
};
const message = (options = {}, context) => {
  if (!isClient)
    return { close: () => void 0 };
  const normalized = normalizeOptions(options);
  if (normalized.grouping && instances$1.length) {
    const instance2 = instances$1.find(({ vnode: vm }) => {
      var _a;
      return ((_a = vm.props) == null ? void 0 : _a.message) === normalized.message;
    });
    if (instance2) {
      instance2.props.repeatNum += 1;
      instance2.props.type = normalized.type;
      return instance2.handler;
    }
  }
  if (isNumber$1(messageConfig.max) && instances$1.length >= messageConfig.max) {
    return { close: () => void 0 };
  }
  const instance = createMessage(normalized, context);
  instances$1.push(instance);
  return instance.handler;
};
messageTypes.forEach((type) => {
  message[type] = (options = {}, appContext) => {
    const normalized = normalizeOptions(options);
    return message({ ...normalized, type }, appContext);
  };
});
function closeAll(type) {
  const instancesToClose = [...instances$1];
  for (const instance of instancesToClose) {
    if (!type || type === instance.props.type) {
      instance.handler.close();
    }
  }
}
message.closeAll = closeAll;
message._context = null;

const ElMessage = withInstallFunction(message, "$message");

const _imports_0$4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAZpJREFUaEPt2M8qxFEYxvHve0HcjZG/SSKJRBFLRRSJJJJElLKxsLOwU7bcg3IF7B79dBbTZEw/55yXqTPL6ZzT83mf30xnxujyl3V5fgrgrxssDZQGIidQHqHIAUZvLw1EjzDygD9pQFKvmT1HZv/a7g6QtAY0gHEze4xFuAIkbQArIfQbMGJm9zEIN4CkLWCpJewHMGBmt79FuAAk7QALbUI2zOzm3wIk7QFzOcJn/xBLOgBmcoXPCpB0BEzlDJ8NIOkEmMgdPgtA0hkw5hE+OUDSRfXd7hU+KUDSFTDoGT4ZQNI10O8dvgCaJy7pEhjybiHpVULSOTDqiUgKqIJLOq2uyl6I5ICAOAYmPRBZAAFxCEznRmQDBMQ+MJsTkRUQELvAfC5EdkBAbAOLORAugIDYBJZbEO/VD3wzu2uD6/i2GyAg1oHVkOoVGDazh44pf1jgCgiI6m+VvurKbWZPMeGT3YXqhpDUY2Yvdfd9t969gRShm88ogNQTrXteaaDuxFKvLw2knmjd80oDdSeWen1pIPVE6573CUfahDF6uW/lAAAAAElFTkSuQmCC";

const _style_0$8 = ".header[data-v-0933e640]{height:60px;background-color:#1e3a8a;color:#fff;position:relative}.header-container[data-v-0933e640]{display:flex;justify-content:flex-start;align-items:center;height:100%;padding:0 20px;max-width:1400px;margin:0 auto}.back-button[data-v-0933e640]{background:none;border:none;color:#fff;font-size:30px;cursor:pointer;padding:0 10px;display:flex;align-items:center}.logo[data-v-0933e640]{font-size:20px;font-weight:700;margin-left:10px}";

const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

const _hoisted_1$8 = { class: "header" };


const _sfc_main$9 = {
  __name: 'Header',
  props: {
  title: {
    type: String,
    default: '系统标题' // 默认标题
  }
},
  setup(__props) {

// 返回逻辑（示例：模拟返回上一页，可自定义）
const handleBack = () => {
  console.log('触发返回操作');
  // 实际使用时替换为真实逻辑（如window.history.back()或路由返回）
  window.history.back();
  // 或 $router.go(-1)（若使用Vue Router）
};

return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("header", _hoisted_1$8, [
    createBaseVNode("div", { class: "header-container" }, [
      createBaseVNode("img", {
        src: _imports_0$4,
        style: {"width":"30px","height":"30px"},
        onClick: handleBack
      }),
      _cache[0] || (_cache[0] = createBaseVNode("div", { class: "logo" }, "Energy management system", -1))
    ])
  ]))
}
}

};
const Header = /*#__PURE__*/_export_sfc(_sfc_main$9, [['styles',[_style_0$8]],['__scopeId',"data-v-0933e640"]]);

const _style_0$7 = ".flow-diagram[data-v-d456e112]{background-color:#fff;border-radius:8px;box-shadow:0 2px 4px #0000001a;padding:10px;margin-bottom:20px}.section-title[data-v-d456e112]{margin-top:0;margin-bottom:15px;color:#333}.chart-container[data-v-d456e112]{width:100%;height:100%;display:flex;justify-content:center;align-items:center;background-color:#f8fafc;border-radius:6px}canvas[data-v-d456e112]{max-width:125%;max-height:150%}";

const _hoisted_1$7 = { class: "flow-diagram" };
const _hoisted_2$6 = { class: "chart-container" };


const _sfc_main$8 = {
  __name: 'FlowDiagram',
  props: {
  powerData: {
    type: Object,
    default: () => ({})
  }
},
  setup(__props) {

const props = __props;

const flowCanvasRef = ref(null);
let canvas = null;
let ctx = null;
let animationFrameId = null;

// 流动图节点数据（重点修改节点坐标和层级分布）
const flowNodes = {
  top: [ // 顶层：能源输入端
    { id: 'solar', x: 400, y: 80, radius: 50, label: 'PV', color: '#22c55e', imageUrl: 'https://cdn.shuoxd.com/HomeAssistant/solar.png' },
    { id: 'grid', x: 400, y: 480, radius: 50, label: 'Grid', color: '#3b82f6', imageUrl: 'https://cdn.shuoxd.com/HomeAssistant/grid.png' }
  ],
  middle: [ // 中间层：核心处理节点
    { id: 'device', x: 400, y: 280, radius: 50, label: 'Device', color: '#64748b', imageUrl: 'https://cdn.shuoxd.com/HomeAssistant/Device.png' }
  ],
  bottom: [ // 底层：输出与存储节点
    { id: 'battery', x: 200, y: 280, radius: 50, label: 'Bat', color: '#8b5cf6', imageUrl: 'https://cdn.shuoxd.com/HomeAssistant/bat.png' },
    { id: 'totalLoad', x: 600, y: 280, radius: 50, label: 'Load', color: '#ef4444', imageUrl: 'https://cdn.shuoxd.com/HomeAssistant/load.png' },
    { id: 'smartDevice', x: 600, y: 480, radius: 50, label: 'Smart', color: '#f59e0b', imageUrl: 'https://cdn.shuoxd.com/HomeAssistant/socket.png' }
  ]
};

// 获取动态流动线路
const getDynamicFlowLines = () => {
  const lines = [];
  const { solar, solarWorkMode, grid, gridWorkMode, smartDevice, loadWorkMode, battery, batWorkMode, totalLoad, homeWorkMode } = props.powerData;

  // 光伏向设备供电
  if (parseFloat(solarWorkMode.value) > 0) {
    lines.push({ from: 'solar', to: 'device', color: '#22c55e', value: parseFloat(solar.value) });
  } else if (parseFloat(solarWorkMode.value) === 0) {
    lines.push({ from: 'solar', to: 'device', color: '#22c55e', value: 0 });
  }

  // 电网向设备供电
  const gridValue = parseFloat(grid.value);
  if (parseFloat(gridWorkMode.value) > 0) {
    lines.push({ from: 'grid', to: 'device', color: '#1e4871', value: gridValue });
  } else if (parseFloat(gridWorkMode.value) < 0) {
    lines.push({ from: 'device', to: 'grid', color: '#1e4871', value: Math.abs(gridValue) });
  } else if (parseFloat(gridWorkMode.value) === 0) {
    lines.push({ from: 'grid', to: 'device', color: '#1e4871', value: 0 });
  }

  // 设备向智能设备供电
  if (parseFloat(loadWorkMode.value) > 0) {
    lines.push({ from: 'totalLoad', to: 'smartDevice', color: '##f28d4b', value: parseFloat(smartDevice.value) });
  } else if (parseFloat(loadWorkMode.value) === 0) {
    lines.push({ from: 'totalLoad', to: 'smartDevice', color: '#1e4871', value: 0 });
  }

  // 设备向总负载供电
  if (parseFloat(homeWorkMode.value) > 0) {
    lines.push({ from: 'device', to: 'totalLoad', color: '#f28d4b', value: parseFloat(totalLoad.value) });
  } else if (parseFloat(homeWorkMode.value) === 0) {
    lines.push({ from: 'device', to: 'totalLoad', color: '#f28d4b', value: 0 });
  } else if (parseFloat(homeWorkMode.value) < 0) {
    lines.push({ from: 'totalLoad', to: 'device', color: '#f28d4b', value: parseFloat(totalLoad.value) });
  }

  // 电池充放电
  const batteryValue = parseFloat(battery.value);
  if (batWorkMode.value > 0) {
    lines.push({ from: 'device', to: 'battery', color: '#22c55e', value: batteryValue });
  } else if (batWorkMode.value < 0) {
    lines.push({ from: 'battery', to: 'device', color: '#22c55e', value: Math.abs(batteryValue) });
  } else if (batWorkMode.value === 0) {
    lines.push({ from: 'device', to: 'battery', color: '#22c55e', value: 0 });
  }

  return lines;
};

// 存储加载好的图片对象
const nodeImages = ref({});

// 预加载所有节点图片
const loadImages = () => {
  const allNodes = [...flowNodes.top, ...flowNodes.middle, ...flowNodes.bottom];
  const imagePromises = allNodes.map(node => {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        nodeImages.value[node.id] = img;
        resolve();
      };
      img.onerror = () => {
        console.error(`图片加载失败: ${node.imageUrl}`);
        resolve();
      };
      img.src = node.imageUrl;
    });
  });
  return Promise.all(imagePromises);
};

// 绘制节点
const drawNodes = () => {
  const allNodes = [...flowNodes.top, ...flowNodes.middle, ...flowNodes.bottom];
  allNodes.forEach(node => {
    const img = nodeImages.value[node.id];
    if (!img) return;

    const imgSize = node.radius * 2;
    const x = node.x - imgSize / 2;
    const y = node.y - imgSize / 2;

    // 绘制白色背景圆形和图片（保持不变）
    ctx.beginPath();
    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
    ctx.fillStyle = 'white';
    ctx.fill();

    ctx.save();
    ctx.beginPath();
    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
    ctx.clip();
    ctx.drawImage(img, x, y, imgSize, imgSize);
    ctx.restore();

    // 绘制标签（保持不变）
    ctx.fillStyle = 'black';
    ctx.font = 'bold 30px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(node.label, node.x + 50, node.y + node.radius + 38);

    // 绘制功率和 SOC（重点修改此处）
    if (node.id === 'battery') {
      // 电池节点：显示功率 + SOC
      const powerInfo = props.powerData.battery || {};
      const socInfo = props.powerData.batterySoc || {};

      if (powerInfo.value !== undefined && socInfo.value !== undefined) {
        ctx.font = '25px Arial';
        ctx.fillText(
          `${powerInfo.value} ${powerInfo.unit} · ${socInfo.value}${socInfo.unit}`,
          node.x + 80,
          node.y + node.radius + 68
        );
      }
    } else {
      // 其他节点：正常显示功率
      const powerInfo = props.powerData[node.id];
      if (powerInfo) {
        ctx.font = '25px Arial';
        ctx.fillText(`${powerInfo.value} ${powerInfo.unit}`, node.x + 50, node.y + node.radius + 68);
      }
    }
  });
};

// 绘制流动线路（当功率>0时显示流动点，功率=0时只显示直线）
const drawFlowLines = (timestamp) => {
  const lines = getDynamicFlowLines();
  lines.forEach(line => {
    const fromNode = findNodeById(line.from);
    const toNode = findNodeById(line.to);
    if (!fromNode || !toNode) return;

    // 计算向量和坐标
    const dx = toNode.x - fromNode.x;
    const dy = toNode.y - fromNode.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const unitX = dx / distance;
    const unitY = dy / distance;
    const startX = fromNode.x + unitX * fromNode.radius;
    const startY = fromNode.y + unitY * fromNode.radius;
    const endX = toNode.x - unitX * toNode.radius;
    const endY = toNode.y - unitY * toNode.radius;

    // 线条宽度与功率成正比（最小2px，最大值10px）
    const lineWidth = line.value > 0
      ? Math.min(Math.max(line.value / 50, 2), 3)
      : 2; // 功率为0时使用最小宽度

    // 绘制主线路
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.strokeStyle = line.color;
    ctx.lineWidth = lineWidth;
    ctx.stroke();

    // 绘制箭头（固定大小）
    drawArrowhead(endX, endY, unitX, unitY, line.color);

    // 当功率>0时绘制流动点
    if (line.value > 0) {
      const flowSpeed = 0.001; // 固定流动速度
      const flowSize = 4; // 固定流动点大小
      const flowCount = Math.floor(distance / 20); // 流动点数量

      for (let i = 0; i < flowCount; i++) {
        const position = ((timestamp * flowSpeed + i * 1.5) % 1);
        const flowX = startX + position * (endX - startX);
        const flowY = startY + position * (endY - startY);

        ctx.beginPath();
        ctx.arc(flowX, flowY, flowSize, 0, Math.PI * 2);
        ctx.fillStyle = line.color;
        ctx.globalAlpha = 0.6;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
  });
};

// 绘制箭头（固定大小）
const drawArrowhead = (x, y, unitX, unitY, color) => {
  const arrowSize = 5; // 固定箭头大小
  const perpX = -unitY;
  const perpY = unitX;

  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x - unitX * arrowSize - perpX * arrowSize, y - unitY * arrowSize - perpY * arrowSize);
  ctx.lineTo(x - unitX * arrowSize + perpX * arrowSize, y - unitY * arrowSize + perpY * arrowSize);
  ctx.closePath();
  ctx.fillStyle = color;
  ctx.fill();
};

// 根据ID查找节点
const findNodeById = (id) => {
  const allNodes = [...flowNodes.top, ...flowNodes.middle, ...flowNodes.bottom];
  return allNodes.find(node => node.id === id);
};

// 动画循环（重点修改绘制顺序）
const animate = (timestamp) => {
  if (!ctx) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 先绘制线路（底层）
  drawFlowLines(timestamp);

  // 再绘制节点和文字（上层，覆盖线路）
  drawNodes();

  animationFrameId = requestAnimationFrame(animate);
};

onMounted(async () => {
  canvas = flowCanvasRef.value;
  ctx = canvas.getContext('2d');
  await loadImages();
  animationFrameId = requestAnimationFrame(animate);
});

onUnmounted(() => {
  if (animationFrameId) cancelAnimationFrame(animationFrameId);
});

return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", _hoisted_1$7, [
    _cache[0] || (_cache[0] = createBaseVNode("h3", { class: "section-title" }, "Energy flow diagram", -1)),
    createBaseVNode("div", _hoisted_2$6, [
      createBaseVNode("canvas", {
        ref_key: "flowCanvasRef",
        ref: flowCanvasRef,
        width: "800",
        height: "600"
      }, null, 512)
    ])
  ]))
}
}

};
const FlowDiagram = /*#__PURE__*/_export_sfc(_sfc_main$8, [['styles',[_style_0$7]],['__scopeId',"data-v-d456e112"]]);

const _imports_0$3 = "data:image/png;base64,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";

const _imports_1$2 = "data:image/png;base64,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";

const _style_0$6 = ".device-control[data-v-44c0e620]{background-color:#fff;border-radius:8px;box-shadow:0 2px 4px #0000001a;padding:20px;margin-bottom:20px}.devices-grid[data-v-44c0e620]{display:grid;grid-template-columns:repeat(auto-fill,minmax(250px,1fr));gap:15px}.device-card[data-v-44c0e620]{border:1px solid #e0e0e0;border-radius:6px;padding:15px;transition:all .3s ease;cursor:pointer}.device-card[data-v-44c0e620]:hover{box-shadow:0 4px 12px #0000001a;transform:translateY(-2px)}.device-header[data-v-44c0e620]{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}.device-header h4[data-v-44c0e620]{margin:0;color:#333}.device-info p[data-v-44c0e620]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:100%}.device-icon[data-v-44c0e620]{width:80px;height:70px}.switch[data-v-44c0e620]{position:relative;display:inline-block;width:60px;height:34px}.switch input[data-v-44c0e620]{opacity:0;width:0;height:0}.slider[data-v-44c0e620]{position:absolute;cursor:pointer;inset:0;background-color:#ccc;-webkit-transition:.4s;transition:.4s}.slider[data-v-44c0e620]:before{position:absolute;content:\"\";height:26px;width:26px;left:4px;bottom:4px;background-color:#fff;-webkit-transition:.4s;transition:.4s}input:checked+.slider[data-v-44c0e620]{background-color:#2196f3}input:focus+.slider[data-v-44c0e620]{box-shadow:0 0 1px #2196f3}input:checked+.slider[data-v-44c0e620]:before{-webkit-transform:translateX(26px);-ms-transform:translateX(26px);transform:translate(26px)}.slider.round[data-v-44c0e620]{border-radius:34px}.slider.round[data-v-44c0e620]:before{border-radius:50%}.status-active[data-v-44c0e620]{color:#22c55e;font-weight:700}.status-inactive[data-v-44c0e620]{color:#ef4444;font-weight:700}.modal-overlay[data-v-44c0e620]{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:1000;animation:fadeIn-44c0e620 .3s ease}.modal-content[data-v-44c0e620]{background-color:#fff;border-radius:8px;box-shadow:0 10px 25px #0000001a;width:90%;max-width:600px;max-height:90vh;display:flex;flex-direction:column;overflow:hidden;padding:20px}.modal-header[data-v-44c0e620]{display:flex;justify-content:space-between;align-items:center;padding:0 0 15px;border-bottom:1px solid #e0e0e0;margin-bottom:20px}.modal-header h3[data-v-44c0e620]{margin:0;color:#333;display:flex;align-items:center}.modal-body[data-v-44c0e620]{flex-grow:1;overflow-y:auto}.device-details[data-v-44c0e620]{text-align:center;margin-bottom:20px}.device-details-img[data-v-44c0e620]{display:block;margin:0 auto;max-width:100%;height:auto}.chart-container[data-v-44c0e620]{border-top:1px solid #e0e0e0;padding-top:20px}.data-scroll-container[data-v-44c0e620]{max-height:300px;overflow-y:auto;margin-top:15px}.data-grid[data-v-44c0e620]{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:16px;padding:16px}.data-item[data-v-44c0e620]{border:1px solid #e0e0e0;border-radius:4px;padding:12px;text-align:center}.data-label[data-v-44c0e620]{color:#666;font-weight:500;margin-bottom:4px}.data-value[data-v-44c0e620]{color:#333}@media (max-width: 768px){.data-grid[data-v-44c0e620]{grid-template-columns:repeat(2,1fr)}.devices-grid[data-v-44c0e620]{grid-template-columns:repeat(2,1fr);gap:15px}.device-card[data-v-44c0e620]{padding:33px;text-align:center;width:100px}.device-header[data-v-44c0e620]{flex-direction:column;align-items:center;margin-bottom:12px}.device-card .switch[data-v-44c0e620]{display:block;margin:0 auto}.modal-content[data-v-44c0e620]{max-width:95%;padding:15px}.data-scroll-container[data-v-44c0e620]{max-height:200px}}@keyframes fadeIn-44c0e620{0%{opacity:0}to{opacity:1}}@keyframes slideUp-44c0e620{0%{transform:translateY(20px);opacity:0}to{transform:translateY(0);opacity:1}}";

const _hoisted_1$6 = { class: "device-control" };
const _hoisted_2$5 = { class: "devices-grid" };
const _hoisted_3$4 = ["onClick"];
const _hoisted_4$4 = { class: "device-header" };
const _hoisted_5$3 = ["src"];
const _hoisted_6$3 = {
  key: 0,
  class: "device-info"
};
const _hoisted_7$2 = {
  key: 1,
  class: "device-info"
};
const _hoisted_8$2 = {
  key: 2,
  class: "device-info"
};
const _hoisted_9$2 = {
  key: 3,
  class: "device-info"
};
const _hoisted_10$2 = {
  key: 4,
  class: "device-info"
};
const _hoisted_11$2 = ["onClick"];
const _hoisted_12$2 = ["onClick"];
const _hoisted_13$2 = { class: "modal-header" };
const _hoisted_14$2 = { class: "modal-body" };
const _hoisted_15$1 = { class: "device-details" };
const _hoisted_16$1 = ["src"];
const _hoisted_17 = {
  key: 0,
  class: "chart-container"
};
const _hoisted_18 = { class: "data-grid" };
const _hoisted_19 = { class: "data-label" };
const _hoisted_20 = { class: "data-value" };

const _sfc_main$7 = {
  __name: 'DeviceControl',
  props: {
  smartDeviceDataList: {
    type: Object,
    required: true
  },
  smartDeviceDetails: {
    type: Object,
    required: true
  },
},
  emits: ['increment'],
  setup(__props, { emit: __emit }) {

const emit = __emit;

const props = __props;

// 获取图片路径
const getDeviceImageUrl = (device) => {
  // 从 smartDeviceDetails 中获取对应设备的 imageUrl
  const deviceDetails = props.smartDeviceDetails[device.deviceSn];
  if (deviceDetails && deviceDetails.imageUrl) {
    return deviceDetails.imageUrl;
  }
};


// 设备数据（添加了详细信息）
props.smartDeviceDataList;
props.smartDeviceDetails;

// 关闭弹窗
const getValue = () => {
  console.log('传值List', props.smartDeviceDataList);
  console.log('传值详情List', props.smartDeviceDetails);
};

// 当前活跃的设备（用于弹窗显示）
const activeDevice = ref(null);
const iconType = ref(null);

// 显示设备详情弹窗
const showDeviceDetail = (device) => {
  iconType.value = device.iconType;
  const targetKey = device.deviceSn;
  const newObject = props.smartDeviceDetails[targetKey] || {}; // 若未找到，默认空对象
  activeDevice.value = JSON.parse(JSON.stringify(newObject));
  console.log('设备信息详情总列表1', newObject.imageUrl);
  console.log('设备信息详情总列表2', activeDevice);
};

// 关闭弹窗
const closeModal = () => {
  activeDevice.value = null;
};

// 切换设备状态
const toggleDevice = (device) => {
  console.log('设备开关', device);
  const deviceId = device.deviceSn;
  const deviceIndex = props.smartDeviceDataList.findIndex(d => d.deviceSn === deviceId); // 找到设备索引

  //   if (deviceIndex !== -1) {
  //   // 直接修改响应式数组中的状态（关键！）
  //   props.smartDeviceDataList[deviceIndex].switchStatus = !device.switchStatus;
  // }

  if (deviceIndex === -1) {
    return;
  }

  const deviceSwitch = device.switchStatus ? 'turn_off' : 'turn_on'; // 注意状态取反逻辑
  console.log('编号--状态', formatDeviceId(deviceId), deviceSwitch);
  emit('increment', formatDeviceId(deviceId), deviceSwitch);

  // props.smartDeviceDataList[deviceIndex].switchStatus = !device.switchStatus;
};

function formatDeviceId(deviceId) {
  return `switch.${deviceId.toLowerCase()}_switch`;
}

onMounted(() => {
  console.log('传值List', props.smartDeviceDataList);
});

return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", _hoisted_1$6, [
    createBaseVNode("h3", {
      class: "section-title",
      onClick: getValue
    }, "Device control "),
    createBaseVNode("div", _hoisted_2$5, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(props.smartDeviceDataList, (device) => {
        return (openBlock(), createElementBlock("div", {
          key: device.id,
          class: "device-card",
          onClick: $event => (showDeviceDetail(device))
        }, [
          createBaseVNode("div", _hoisted_4$4, [
            createBaseVNode("img", {
              src: getDeviceImageUrl(device),
              class: "device-icon"
            }, null, 8, _hoisted_5$3)
          ]),
          (device.iconType === 6)
            ? (openBlock(), createElementBlock("div", _hoisted_6$3, [
                createBaseVNode("p", null, toDisplayString(device.deviceSn), 1),
                createBaseVNode("p", null, "Power: " + toDisplayString(device.power) + "W", 1)
              ]))
            : createCommentVNode("", true),
          (device.iconType === 5)
            ? (openBlock(), createElementBlock("div", _hoisted_7$2, [
                createBaseVNode("p", null, toDisplayString(device.deviceSn), 1),
                createBaseVNode("p", null, "Power: " + toDisplayString(device.power) + "W", 1)
              ]))
            : createCommentVNode("", true),
          (device.iconType === 9)
            ? (openBlock(), createElementBlock("div", _hoisted_8$2, [
                createBaseVNode("p", null, toDisplayString(device.deviceSn), 1),
                createBaseVNode("p", null, "Power: " + toDisplayString(device.power) + "W", 1)
              ]))
            : createCommentVNode("", true),
          (device.iconType === 1)
            ? (openBlock(), createElementBlock("div", _hoisted_9$2, [
                createBaseVNode("p", null, toDisplayString(device.deviceSn), 1)
              ]))
            : createCommentVNode("", true),
          (device.iconType === 7)
            ? (openBlock(), createElementBlock("div", _hoisted_10$2, [
                createBaseVNode("p", null, toDisplayString(device.deviceSn), 1)
              ]))
            : createCommentVNode("", true),
          (device.iconType !== 1 && device.iconType !== 7)
            ? (openBlock(), createElementBlock("div", {
                key: 5,
                onClick: _cache[0] || (_cache[0] = withModifiers(() => {}, ["stop"]))
              }, [
                (device.switchStatus)
                  ? (openBlock(), createElementBlock("img", {
                      key: 0,
                      src: _imports_0$3,
                      style: {"width":"50px","height":"50px"},
                      onClick: $event => (toggleDevice(device))
                    }, null, 8, _hoisted_11$2))
                  : (openBlock(), createElementBlock("img", {
                      key: 1,
                      src: _imports_1$2,
                      style: {"width":"50px","height":"50px"},
                      onClick: $event => (toggleDevice(device))
                    }, null, 8, _hoisted_12$2))
              ]))
            : createCommentVNode("", true)
        ], 8, _hoisted_3$4))
      }), 128))
    ]),
    (activeDevice.value)
      ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "modal-overlay",
          onClick: closeModal
        }, [
          createBaseVNode("div", {
            class: "modal-content",
            onClick: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"]))
          }, [
            createBaseVNode("div", _hoisted_13$2, [
              createBaseVNode("h3", null, toDisplayString(activeDevice.value.datalogSn), 1),
              createBaseVNode("button", {
                class: "close-btn",
                onClick: closeModal
              }, "×")
            ]),
            createBaseVNode("div", _hoisted_14$2, [
              createBaseVNode("div", _hoisted_15$1, [
                (activeDevice.value.imageUrl)
                  ? (openBlock(), createElementBlock("img", {
                      key: 0,
                      src: activeDevice.value.imageUrl,
                      class: "device-details-img",
                      style: {"width":"200px","height":"200px"}
                    }, null, 8, _hoisted_16$1))
                  : createCommentVNode("", true)
              ]),
              (activeDevice.value.displayMap)
                ? (openBlock(), createElementBlock("div", _hoisted_17, [
                    _cache[2] || (_cache[2] = createBaseVNode("h4", null, "Device Data", -1)),
                    createBaseVNode("div", _hoisted_18, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(activeDevice.value.displayMap, (value, key) => {
                        return (openBlock(), createElementBlock("div", {
                          class: "data-item",
                          key: key
                        }, [
                          createBaseVNode("span", _hoisted_19, toDisplayString(key) + ":", 1),
                          createBaseVNode("span", _hoisted_20, toDisplayString(value), 1)
                        ]))
                      }), 128))
                    ])
                  ]))
                : createCommentVNode("", true)
            ])
          ])
        ]))
      : createCommentVNode("", true)
  ]))
}
}

};
const DeviceControl = /*#__PURE__*/_export_sfc(_sfc_main$7, [['styles',[_style_0$6]],['__scopeId',"data-v-44c0e620"]]);

const _style_0$5 = ".ai-control[data-v-c7ee6385]{background-color:#fff;border-radius:8px;box-shadow:0 2px 4px #0000001a;padding:20px;margin-bottom:20px}.ai-status[data-v-c7ee6385]{display:flex;align-items:center;margin-bottom:20px;padding:15px;background-color:#e9f5ff;border-radius:6px}.ai-indicator[data-v-c7ee6385]{display:flex;align-items:center;width:100%}.ai-icon[data-v-c7ee6385]{font-size:36px;color:#3b82f6;margin-right:15px}.ai-text[data-v-c7ee6385]{flex:1}.ai-mode[data-v-c7ee6385]{margin:0;font-weight:700}.active-mode[data-v-c7ee6385]{color:#3b82f6}.ai-status-text[data-v-c7ee6385]{margin:5px 0 0;color:#64748b}.savings[data-v-c7ee6385]{color:#22c55e;font-weight:700}.optimization-suggestions[data-v-c7ee6385]{margin-top:20px}.suggestions-list[data-v-c7ee6385]{list-style:none;padding:0;margin:0}.suggestion-item[data-v-c7ee6385]{display:flex;align-items:center;justify-content:space-between;padding:10px 15px;border:1px solid #e2e8f0;border-radius:6px;margin-bottom:10px;transition:background-color .3s ease}.suggestion-item[data-v-c7ee6385]:hover{background-color:#f8fafc}.suggestion-content[data-v-c7ee6385]{display:flex;align-items:center;flex:1}.suggestion-icon[data-v-c7ee6385]{font-size:20px;color:#f59e0b;margin-right:10px}.suggestion-item p[data-v-c7ee6385]{margin:0;color:#334155}.apply-btn[data-v-c7ee6385]{background-color:#3b82f6;color:#fff;border:none;border-radius:4px;padding:8px 16px;cursor:pointer;transition:background-color .3s ease;margin-left:15px}.apply-btn[data-v-c7ee6385]:hover{background-color:#2563eb}.apply-btn[data-v-c7ee6385]:disabled{background-color:#94a3b8;cursor:not-allowed}.data-title[data-v-c7ee6385]{font-size:16px;font-weight:500;color:#334155;margin-bottom:5px}.data-metrics[data-v-c7ee6385]{display:flex;align-items:baseline;margin-bottom:8px}.metric-value[data-v-c7ee6385]{font-size:20px;font-weight:600;color:#2563eb}.metric-unit[data-v-c7ee6385]{font-size:14px;color:#64748b;margin-left:4px}.data-desc[data-v-c7ee6385]{font-size:14px;color:#64748b;line-height:1.4}";

const _hoisted_1$5 = { class: "ai-control" };
const _hoisted_2$4 = { class: "ai-status" };
const _hoisted_3$3 = { class: "ai-indicator" };
const _hoisted_4$3 = { class: "ai-text" };
const _hoisted_5$2 = { class: "ai-mode" };
const _hoisted_6$2 = { class: "active-mode" };


const _sfc_main$6 = {
  __name: 'AIControl',
  props: {
  modeData: {
    type: Object,
    required: true
  },
  
},
  setup(__props) {

return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", _hoisted_1$5, [
    _cache[2] || (_cache[2] = createBaseVNode("h3", { class: "section-title" }, "AI intelligent regulation and control", -1)),
    createBaseVNode("div", _hoisted_2$4, [
      createBaseVNode("div", _hoisted_3$3, [
        _cache[1] || (_cache[1] = createBaseVNode("div", { class: "ai-icon" }, [
          createBaseVNode("i", { class: "fa fa-brain" })
        ], -1)),
        createBaseVNode("div", _hoisted_4$3, [
          createBaseVNode("p", _hoisted_5$2, [
            _cache[0] || (_cache[0] = createTextVNode("AI Mode: ")),
            createBaseVNode("span", _hoisted_6$2, toDisplayString(__props.modeData.mode.value), 1)
          ])
        ])
      ])
    ])
  ]))
}
}

};
const AIControl = /*#__PURE__*/_export_sfc(_sfc_main$6, [['styles',[_style_0$5]],['__scopeId',"data-v-c7ee6385"]]);

const _imports_0$2 = "data:image/png;base64,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";

const _imports_1$1 = "data:image/png;base64,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";

const _imports_2$1 = "data:image/png;base64,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";

const _imports_3$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMwAAADICAYAAACksw7kAAAAAXNSR0IArs4c6QAAG9JJREFUeF7tXQmUHGW1/m71TJLp6iEiggj42BJBhumahH1REhGSdHUIi8TgAqiI7A9kO8hT4D3igygIssmqgGxRn4Tp7oRFAohJ0JCZ6pCwQwQFkS0wXT1Zpuu+VBaYDJOZWruqe26f45Fzcu93v/+79U3VX/XXXwT5DWkFckbXNIJyHICvAlhORMsZvByMN0lJXJtpHfHQkBaoz+BJxBiaCrR3dF2sKIljAP7CQAoQ0V0V4LrJ6eT8oanUxqMWwwzBo2CdWZSL3AydiGZk0snz3eTUY6wYph67OsCYvJhlAxwBDySgnDlBa3p1iMn20XDFMEOo837M8rFp6HkQn5VJq7OHkHRimKHW7MIz5QOsCj9BgBLE2Al0VkZLXhUEVi1hyBmmlrrlg2vBMOcwMMEHxCdTGTfqbepJgWLGHEwME/MGBUEvZ5TPIfDPgsDqi0FEjxErJ03SRjwfBn7cMMUwcetIwHzyHaU2KMqTAKsBQ/eC438R85mZtub7wqsRD2QxTDz6EBqLvGH+AcCRoRXoBUyEizJp9b+rUSuqGmKYqJSvQt2cYZ5MwPVVKNX7bHOPrqW+Ud2a1asmhqme1lWt1N7xwWhSGuYTsEVVCwMgYFHF6pk2eczIF6tdO+x6YpiwFY4Iv2CYtzNwbETl7bJlMJ+kt6XujJBD4KXFMIFLGj1gfnH3t2FZd3hhQsASBlq85Pabw3yl3pY6OzC8iIHEMBE3IOjyc5aan6usxl8BbOcFmxoaWtDTcxkDk73k95tDyOtpNRsYXoRAYpgIxQ+jdN4wbwDg7WEi0wy9LXn+3Fd5RPeH3Zcx+D+D4khEL1lQJmTTI14JCjMKHDFMFKqHVDPXWT6SiO3byK5/BLyR0dRteyfmF5fPgIXLAG5yDbipBFK+qaeb7g4Mr8pAYpgqCx5WucKLvJlllp8mwigvNRJQvjxRa/pz39z8YjNLFuxLtMDmNUR0TSadPMMLz6hzxDBRdyCg+vli+Uown+UR7lZdU0/YVO79i7p2G5ZQgp3XgP6sa8kve+QbWZoYxoH0M+dx0/Dh5uhEQhmlKBiFCr+wqoGePrw1+bqD9NBDcp2lCUQ0x1Mhxjt6m7qlk9yCUb4qyHkNgLcVa9Xek8ZsvsxJ/TjEiGEG6MLsYnk/i61pAE0DsFU/oYvB/AhZPCsztvnxKBo6cyYn1F3KHQBavdQnwhGZtHq/09ww5jUM65is1nyvUw5RxolhNqF+wTBnMnC0i+YsAPMsTvCsbGvzsy7yfIXmDfOnAC7wBMK4X29Tj3Cbm+swdUXB5UHOawC+WtdSZ7rlUu14MUw/inswy0Yo9qu8UDAr06reFmZD7ZfCuMJPeqlBwAevr05u+YM9abWX/Fxx+U4KN14V6PMa4CldU/f1wqdaOWKYPkr7NctGcIx3mDArwfy7SW2pB4Nuar7T/CsIe3nBZeCErKbe6iW3d04I85qVDQqNnhCT+WFffcQwvRQpFLt/wmxd4vcg6jefsBSMWY3Dce2hu6pv+K1RKJo/Zoa3pfQBP3kvdJZPY8KMIJ/XKERTJ6WTv/OrU9D5Ypj1iuaL5hQwHE9+/TTCfktxzX5gd2fS6s1ecAqd5hgmLPKSC6AbK3knfe/Uvzzm95s22ygdzKCrA53XMF+gt6UuC5KnXywxDID80u7tsZofGmxTO79i981nYBUR3U+MX2S05AKn+Hmj/DjAnp5hEPH5mXRqhtNabuJmLTK3aUzgV0HOa0ihMzKtyWvc8AgzVgwDINB5i/du/QOE3zRw8rIJGpmbgskbpXMB8nbAMx7W29RDvVN0lpkvlq8A8w+dRQ8eZVnWJZPHNF88eGT4EUPeMAWj+0cMa3r4UjuvYL+AxQpdrrcmZ/bOerC4ctce7vF2y5pRocaGdKZl+FLnTLxH5g3zBIB+GcS8xl7npjRiz4m7qW96ZxRM5pA2jP08gRTkgpEyNJQ7WGm4LNs6/Nl80XwQDE9nCGZclG2r7vv2hY7yAVD4xiDmNXE5ywxZw7R3lrdVyHoUoAE34w7NBi6BifAus7fXje2bDJl0crzLkoGEz1nywaetSuMtzOz6AWkfAh26po4NhJQPkCFrmLxRuhugY3xoVzOpm1qJXM0BFAxz+pqbHD/yXpPKupYMcasoZ8yGpGEKxfJ5zHy5M4n6jXoHwGd85FcvlXCpnlZ/XL2Cm640e3H3tyyLb/I6r0k0JEZPbBnxUpRjGXKG8bWy194RheiuTDr5rfyzK76AVZVzAWxyWXyUjV1bmzBPT6sHRM6jF4Fc0dwDFt9KRJpbXpZljZ88pvkxt3lBxg8pw8xaXPpsg4UnPM9bCEutzyT3mrwNlXs3Id9pZkmhc5j5oCCb4xeLmSdmQ1iS45dX+0JOJoZ155l5nBssMYwbtQKI9TtvoQQdmNk9+ZdNUXl4IY9c1WB+l4jOYWCbACh7h1j/fr53gHAzC8XyXDFMuBr7Qs91ls4mop97BSGi0zPp5LVO8+3lKxbh+wSc7DQnwLiF/1id3N/rSuQAeWwSSgxTDZU91mg3SgcroEc8poMIt2XS6ve85DMz5Yqlowj0AwLZH14N/WcBh03W1PbQC/koIIbxIV6YqY88++EWK1cp8zzPW8DPm2m1ZSpRxS/PwuIVO4N7jmKLTgFhe794/eUz+KqslvL6bn8YlPrFFMNUTWp3hfzOW6BgL71VXeiu6uDR7Z2lQxWFjlzzee8fDB7tOCKXfC95xPjx1OM4I6JAMUxEwg9U1v+8BSd6XYLvVI7Coq4tWVGOggLbPIc4zesnboG1ujJ58p6b2c+IYv8Tw8SsRe0dXeMURZnrlRYBN2Q09RSv+V7y8kZ5HwBHAXwUgJ2cYhDQvrqn54dT9hgZ6UM9p3ztODGMG7VCjn144XsjVzUO+6vneQvRa3o6Gcocw8nQCy/ycO42jwIrR643T79ptlFYwU16qxr3BaSf4C+GcXIkVCnG97yFGtJ6evjiKtEdsIy9eLHSg9FEiVGVCo9uUBLPMbCMG6xlekuwb01Wc7ximGqqPUAt3/MWKMdltCZPn4qIiQQ1QUMME4M2+Z23MPj2rJY6PgZDqXsKYpiIWjxzyZJhqdXbj2NgPMj++Knn91ve0TVnW6ZGNNS6KiuGqWI7CwuX72w1No4D8/g1L0fZC/g2+kyDJyqc2EVvG/GCp1xJcq2AGMa1ZO4SCsXug5it8QCPB8jTjimbqkjg4zJaSuYt7lriK1oM40u+TyYXjPJ2pNC4im0SxngCdgy4xDo4opl6Ovn1ULAFdJMKiGECODjai+X9FKZxWHsmWTsnaQgAdgCIeLz2Gu4Y44kuhvHQl3XLQjCeSBnH6y61dvUA4z2lUdlB363p794BJNOrAmIYh8rNMcyxPR9P1u0zSTQbGzBO1tvUXzmkLWEBKyCGGUDQXEd5f1KsqbDvaDFcv8sdcK9suJyuqcF9VjsEgvUOKYbpp8MFo7yvxXye/ZWrOB0AuqYOqb0M4qT9Bi5imD5dWbdVKDztTh9Wg5nxUrZNHR0WvuA6V8CLYda8dPfrBqKLovx2TCh/aQuG+UCQO7g7b8OAkbN1Tc0EhCUwPhXwZJgNNQk3Vli5/DCt6VWfNFynB26YwuLy2Wyx580mXI9g0AR+lJC4XRZUDipUVQOC+KNKhGvYSlxbzRUagRomV+TNicsGgM9XVf1PFltIRI8yW3N1LeXtc9wRD6Deyxc6zRuZcGIQ4yTQVUpD4paJLcOXBIE3EEaghskb5TPsr+GGTbof/PcIeNICz00oeHRSa6oYAQcp6UKBnNE1naD42Gv5k8UYuF5h3JJpU+3PsIfyC9gwpv0VLfs129B/DH5GQeLJNbtNzk02NT06fheqiXfZQxemRgrYW8YSI/DNRezhE+iKjJY8JwwpAjNMzujanaCE95Yi4UNizLcY89bsRv/opLYmT5/bDkNEwfSmQJCXZX0ZrP2OaCJxatAfkArMMGFcjjH4OdskIJq3avXquUfs+amXvbVGsuKowOzFK9OW1fMQgM+Gwo+oi5m/ldXUB4LCD84wRfN+MKb4I0ZlAuYz83xLwfzu0ntzp+7/+W5/mJIdZwVmG+VpFviesDgG/TGpQAxjL6JEQvknA41uB24/TCTi+Qye35AYPm/i7sPsu2zyG0IKtHd0XawoiXMBToYxbAZOzWrq9UFgB2OYzvLXmfhet4TY4rMU5rsyY5vfdpsr8fWlwLrN2/k8Ak0LYWQvU8XaL4jjLBjDFM0bmV3eU2f+EIyD9DGpzhAEEsgaVSBfNO3L+lO8fvx2U8Nm8LlZLeX7gXpQhnmDGZ9z1SPC/XpajdWiTFf8JThUBfJG+RgGn0LAgQEVWqBr6n5+sXwbxuvWRvblWHZM6iq/A5D8+lYg31E6Hgk6DYw9/I5UAX91kpb6kx8c34YpLDYvZQsXuiSxEhbvK5djLlUbwuFrjaPQeQC+6EOGX+ma6usDV74NkzdM+2Hl7m4GQcADGU31eQvaTUWJrRcF1hvnIgA7eBjT27qmbuUh76MUX4bJPd31RWpQlrolIJdjbhWT+L4K5AzzNwQc51YZv1tq+TJMvrN0FoiudEsaFo+RyzHXqklCLwXsL1eD4OGzhPyIrqU8f4fHl2G8vAREwIMZTZ0o3RcF/CqQM8yn11zej3WLYzFtN7kt+U+3eXa8Z8Osf/flPddFiX6op5O/cJ0nCaJAHwXyRukCgH7qXhj+ka6l/td9ng/D5Du7vw2y3G+vKpdjXvokOf0o0N6xYnRCqSxxuyTLz/oyz2eYvGH+ft3n5Zz//BB1XkUih5ICeaN8N8DHuBmzn+NwI8O0L+SkkjCnQsEYIiU9CIn9mHm4G6IgeoWA11zlSLAoMJACzFsy0OJSpOVENOCSLGZeSoTO1RYWTun1BudHhln/Btx11Xpj0uUAJVwUiEQBBkognJ1Nqzd9NOkvLC6fzhb/MhJGUlQUqAEFiPG9TJt6G81ZsmJUpafyYg1wFoqiQMQK0L6UN8ozAD43YiZSXhSIvQIMzKeCYc5Z8x8TYs9WCIoCESvAwCpas7zlgzXLWzaLmIuUFwVqQgHKGybXBFMhKQrEQAExTAyaIBRqRwExTO30SpjGQAExTAyaIBRqRwExTO30SpjGQAExTAyaIBRqRwHXhvGz0rN2ZBGmQ0GBNXeI7b0BLnYzVjGMG7Uktq4UEMPUVTtlMGErIIYJW2HBrysFxDB11U4ZTNgKiGHCVljw60qBdZ/ZUOyJv+OfTPodSyWB9aaAnGHqraMynlAVkDNMqPIKeL0pIIapt47KeEJVQAwTqrwCXm8KiGHqraMynlAVEMOEKq+A15sCYph666iMJ1QFqmaYSqVySagjEXBRoDoKjAv9wWV1xiFVRIF4KuD6SX88hyGsRIHqKCCGqY7OUqVOFBDD1EkjZRjVUUAMUx2dpUqdKCCGqZNGyjCqo4BtmNcBbFedclJFFKhtBezd+2cycHRtD0PYiwLhK8DAu+TlaWf41KSCKBBLBf6w9huXBcP8JwPbxJKikBIFYqEAlZlWbbfWMHnjg32AhgWx4CUkRIEYKkCMsZk2teOjrygvXMiNbzWUfwHCqTHkK5REgYgUoD8zKcdn0yNesQl8ZJgNbAoLl+9MDcPSPVzR+mPodrGaZVmyUDOiVg/Fsm6PT3vr40ql8nhfrSiRWKIkEksyLcOX9v63TxhmIJG97LJhWdb4yWOaHxuKzZMxV18Bt1/Uc7tXuBim+j2ViiEqIIYJUVyBrj8FxDD111MZUYgKiGFCFFeg608BMUz99VRGFKICYpgQxRXo+lMgVobxsu5MbivX30EZ5xGJYeLcHeEWOwXEMLFriRCKswJimDh3R7jFTgExTOxaIoTirECsDCNryeJ8qAg3W4FYGUbukslBGXcFYmUYOcPE/XARfrEyjJxh5ICMuwKxMoycYeJ+uAi/WBlGzjByQMZdgVgZRs4wcT9chF+sDCNnGDkg465ArAwjZ5i4Hy7CL1aGkTOMHJBxVyBWhpEzTNwPF+EnhpFjQBRwoYAYxoVYEioKiGHkGBAFXCgQK8PIpN9F5yQ0EgXEMJHILkVrVQExTK12TnhHooAYJhLZpWitKiCGqdXOCe9IFBDDRCK7FK1VBcQwtdo54R2JAmKYSGSXorWqgBimVjsnvCNRQAwTiexStFYVEMPUaueEdyQKiGEikV2K1qoCYpha7ZzwjkQBMUwkskvRWlVADFOrnRPekSggholEdilaqwqIYWq1c8I7EgXEMJHILkVrVQExjIvOtXeWtyVgH4K1DynK3mDekoGtAGwJ4B2A3wXoHQLNZ+InG4fhb4fuqr7hooSEAsgZXbsTKweA+ACAdgHwGQK2YCAJ4N8A3gZhGVf4cUrwomQitWh8C5WqIZ4YxoHKBaP7K4zKcQAd6yB8oxAC3cvE9+ppdZbb3KEUP+s5bm5cVZ7GTNMA/oqrsRP+BYvuoMbE7ZmW4Utd5boMFsMMINgDHeZeCQUXApjiUtdPhBPhb5Uea8bksc2/94tVb/m5zq7TiZSzAWzvZ2wErGbwDQ3g6RO0ZvtMFPhPDLMJSXOGeSGBLgS4KUjVGbiZKsp0fWzT34PErUWsB4zuHRPgSwH+RqD8iZ5TiKZPam36baC48sm+/uXMdZZ+S0TfDFrsj/H4+QZqPHxCevhz4dWIN3Jhycrd0NMzk4GW0JgSzdDTyfODxJczTB8180b5rsD/4vXfsXdGDk/udOCu1BVkQ2sByzYL9/QsqQpXxnV6m3paULXEML2UzBnlRwh8cFDiOsHRNZWcxNVLTHtneW+F+KlqjoeAUzKaekMQNcUw61XMG6Yt6ElBiOoOg+7WtWSIl3/u2IQZve62PL9IhEDnhY44V6yD9LHNTziKHSAoVoZZN9HGpa4GpWCy3qrmXOX0CS4Y3ccyrNv9YPjJJWB6RlP/yw9GLeTmjdKfAHJ3yzi4gb3GsPSs1vyMV8g/drz/qWHKsPfd5BPQntHUw5zmuLrcyBnmyQRc7xTcjrMs65LJY5ovdpPTO3bmPG5KpcoLmJH2ihFEHiXowMzuyb8EgRVHjMLi8uls8S8j5Ub4jZ5Wv+OVQ6HDPJwV/NFNPgF3ZDT1OKc5rgzT3tn1dYWUe52C23EEPJjR1IlucnrHForl85j5cq/5QeUR6L6MlpwWFF6ccOYs+eDTPasbniLCqKh5MSUOyaZHPOKFh5e9vwl0dUZLnum0nivD5Iorvkpcedgp+IY4Yjo905a81m3ewy/zyFWlsn23Zlu3uWHEKwR9UlothIEdJaaXAy1Evu26i0ukDTxmzv13Sv206vqOptsrIFeGKbzIm3G5/IEHsZbrmrq527z8YjMLC+1u83rFL2NgKVvW34iUNBGlAd7ZB96tuqae4CM/lql5o/QEQF/yTo6LIFoECysArNWZwSmveJUGZfvDWppec5Nf6DRvZMKJbnLsWMuyxk8e0/yY0zxXhrFBC8XyXGYe57TARnHMx+ptqTud5uaN0u1e1ocB/B4UOq6/mw35TvMkIvqZl4YyeHlWS7k2vtPxRhE3Z6n5ucpqeFqASoybKNFw3aTW4cXe3Gd3dO9gJayLwDje05iYL9DbUpc5yc13lI6HQhcB2MFJfJ8Y13/IXRsmgNP3W0QwKhVr/mADVBTFFsLt7y1dU7ceLClvmAsB7DFYXN9/t0/hbnPiHu9FZyaamk0nfzfY2Nze5l2Pt9iyrP8bCDuQKwbC/XpaPWKwMfT+d9eGyXWWJhDRHDdFqhnruJFLSlujh+yVs3V1xqiG1kR4KJNWJziplSuaJxLjRiex1Y9Rvq9rTbe4qevaMDZ4wTDtNUZHuylUpdg/6Jr6Nae18kbpXIBmOI2XuHUKKET7T0onB71C2KBX3jDtlcn2O0kx+tETupY8yC0hT4bJF7u+DFYed1ss7HgGLsxq6k+d1on72dLpOKoct2qHhmRzSwutclrX17zXaRGXcU6vRPrCejKMDZI3um4GlFjdMWIF2WyrmneqnY+7fk5L1GPcQl1T93IzsHxn6UoQneUmJ8xYAn6f0VRPV0ieDfOgwWoPzHmAfas2Hj8GTshq6q1O2VR1Va5TUvGPe13X1P9wQzNml/BPNaDr4Ana1qabMWyI9WwYG+BBo3vHHliveCkcRg4zrs22qac7xV5/S/LXTuMlbp0CiqXsOGlM0zKnehQM85lQ36txSgRAohHbTNxNfdNFykahvgyz7tKsvA/AC7wSCDaPi7qW0pxi5jvN20DwvHbJaZ16i2PwuVkt9XMn48oVzT2IYd/Cj8GvZ19dG+nr1QXfhll3puGtelC2l4y4fq4RvIp0p64lB90MI1csH03MM4OvPzQQnb4nlDdM+7iYFLEqnT0KT5zSmnrLL49ADLOBRL5YvhLM0U/uBnmloNBZPo2Jr/Er3hDPX8C0OpNNf2qTy+nDf5V88A4Q0VWZdDKwYzJQw9j0Z3eWj7AIp7neimfwsbuKYOYriPFbfUyq82NDl1rBOMfbchtX5YdMsP22JFnK7A1zmkee/XCLFSvpIKLElQD72mXGn4h0D1u4NjsmOc8fzsbZgRvmo4Ozs/QdgE4GwdUtyCAHtx5rORF1MlsaQPJUPwSB10HSyyBeBcYXQysxCLC9jZPFPFNRGu7KpEfMDoNHaIbZQLa9o2ucoij2PW/7fzF72huGpIJZFQXI3pyE7cvB9wn0Plt0W6JxVX5iy8j3wqwfumF6k5/15NvNNCK1OSmVzUHs6K+9klC+BsapYYrgDJvO1LXk1c5iay8qXyzdB6ap0TLnZ3UttVu0HAauXlXDeBUiXzTfBGPQFche8QfNIzykO1xsOChWTAPsrWAbVpbtv9iJyCiScpCebvK9EUaY/GvFMFPAuD9MIQbALvcovN+U1tRG73xExCXUsoWi+X1m3BRqkU2AM6zpWa059huN1IRhbI0LRvkeBlf9nXpiPifTlroiioMoipp5o/ynCO5wrtA1tfpbO3kQuGYMY4/N48tIHmTZkEL36XW68cVAouQN037AZ38mpCo/YozNtKkdVSnms0hNGaaaZxoiuiaTTp7hU9+aTc8bpasBCnv8bzEl9s+mR8RmPeJgDas5w6w1TcjX2sz4SbZN/Z/BxKv3f893lr4NojvCGKebtzbDqO8VsyYNs/bybHHpEFi4DqDRXgffXx4RTsyk1ZuDxKxlrJzR/SWFrCuYA3sAvYJA12a05Lm1qEvNGmataZaUtqYe+i4D3wXgZ/ukt8F8p2XhjsljU0YtNjJszoWieTiDj/H8rIawlCzcqzQm7pnYMuKlsPmGhV/ThtkgSmHBu5txU9N3ALaN4/yFNsJSWHxnj0V3TBkr37p0cpC1P1PSqAfHgOgQWvdHauQAeS+D8BxBuaf03Ih7p06lipMacY6pC8NsEHjmTE6kdilnmHkUFNqZGaMUsv+fR635pswLBHqeiV5kq7KMoLz62Z7kg3vuSavj3KC4c7P3IOtRKjsniHYCeHNU6AVq4FfYXLkss+8WH8adv1t+/w/yFnbJnLvtjAAAAABJRU5ErkJggg==";

/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function round(v) {
  return v + 0.5 | 0;
}
const lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}

const map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
const hex = [...'0123456789ABCDEF'];
const h1 = b => hex[b & 0xF];
const h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];
const eq = b => ((b & 0xF0) >> 4) === (b & 0xF);
const isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === '#') {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255
      };
    }
  }
  return ret;
}
const alpha = (a, f) => a < 255 ? f(a) : '';
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v
    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)
    : undefined;
}

const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return ((g - b) / d) + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (
    Array.isArray(a)
      ? f(a[0], a[1], a[2])
      : f(a, b, c)
  ).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === 'hwb') {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === 'hsv') {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a: a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255
    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
    : `hsl(${h}, ${s}%, ${l}%)`;
}

const map$2 = {
	x: 'dark',
	Z: 'light',
	Y: 're',
	X: 'blu',
	W: 'gr',
	V: 'medium',
	U: 'slate',
	A: 'ee',
	T: 'ol',
	S: 'or',
	B: 'ra',
	C: 'lateg',
	D: 'ights',
	R: 'in',
	Q: 'turquois',
	E: 'hi',
	P: 'ro',
	O: 'al',
	N: 'le',
	M: 'de',
	L: 'yello',
	F: 'en',
	K: 'ch',
	G: 'arks',
	H: 'ea',
	I: 'ightg',
	J: 'wh'
};
const names$1 = {
	OiceXe: 'f0f8ff',
	antiquewEte: 'faebd7',
	aqua: 'ffff',
	aquamarRe: '7fffd4',
	azuY: 'f0ffff',
	beige: 'f5f5dc',
	bisque: 'ffe4c4',
	black: '0',
	blanKedOmond: 'ffebcd',
	Xe: 'ff',
	XeviTet: '8a2be2',
	bPwn: 'a52a2a',
	burlywood: 'deb887',
	caMtXe: '5f9ea0',
	KartYuse: '7fff00',
	KocTate: 'd2691e',
	cSO: 'ff7f50',
	cSnflowerXe: '6495ed',
	cSnsilk: 'fff8dc',
	crimson: 'dc143c',
	cyan: 'ffff',
	xXe: '8b',
	xcyan: '8b8b',
	xgTMnPd: 'b8860b',
	xWay: 'a9a9a9',
	xgYF: '6400',
	xgYy: 'a9a9a9',
	xkhaki: 'bdb76b',
	xmagFta: '8b008b',
	xTivegYF: '556b2f',
	xSange: 'ff8c00',
	xScEd: '9932cc',
	xYd: '8b0000',
	xsOmon: 'e9967a',
	xsHgYF: '8fbc8f',
	xUXe: '483d8b',
	xUWay: '2f4f4f',
	xUgYy: '2f4f4f',
	xQe: 'ced1',
	xviTet: '9400d3',
	dAppRk: 'ff1493',
	dApskyXe: 'bfff',
	dimWay: '696969',
	dimgYy: '696969',
	dodgerXe: '1e90ff',
	fiYbrick: 'b22222',
	flSOwEte: 'fffaf0',
	foYstWAn: '228b22',
	fuKsia: 'ff00ff',
	gaRsbSo: 'dcdcdc',
	ghostwEte: 'f8f8ff',
	gTd: 'ffd700',
	gTMnPd: 'daa520',
	Way: '808080',
	gYF: '8000',
	gYFLw: 'adff2f',
	gYy: '808080',
	honeyMw: 'f0fff0',
	hotpRk: 'ff69b4',
	RdianYd: 'cd5c5c',
	Rdigo: '4b0082',
	ivSy: 'fffff0',
	khaki: 'f0e68c',
	lavFMr: 'e6e6fa',
	lavFMrXsh: 'fff0f5',
	lawngYF: '7cfc00',
	NmoncEffon: 'fffacd',
	ZXe: 'add8e6',
	ZcSO: 'f08080',
	Zcyan: 'e0ffff',
	ZgTMnPdLw: 'fafad2',
	ZWay: 'd3d3d3',
	ZgYF: '90ee90',
	ZgYy: 'd3d3d3',
	ZpRk: 'ffb6c1',
	ZsOmon: 'ffa07a',
	ZsHgYF: '20b2aa',
	ZskyXe: '87cefa',
	ZUWay: '778899',
	ZUgYy: '778899',
	ZstAlXe: 'b0c4de',
	ZLw: 'ffffe0',
	lime: 'ff00',
	limegYF: '32cd32',
	lRF: 'faf0e6',
	magFta: 'ff00ff',
	maPon: '800000',
	VaquamarRe: '66cdaa',
	VXe: 'cd',
	VScEd: 'ba55d3',
	VpurpN: '9370db',
	VsHgYF: '3cb371',
	VUXe: '7b68ee',
	VsprRggYF: 'fa9a',
	VQe: '48d1cc',
	VviTetYd: 'c71585',
	midnightXe: '191970',
	mRtcYam: 'f5fffa',
	mistyPse: 'ffe4e1',
	moccasR: 'ffe4b5',
	navajowEte: 'ffdead',
	navy: '80',
	Tdlace: 'fdf5e6',
	Tive: '808000',
	TivedBb: '6b8e23',
	Sange: 'ffa500',
	SangeYd: 'ff4500',
	ScEd: 'da70d6',
	pOegTMnPd: 'eee8aa',
	pOegYF: '98fb98',
	pOeQe: 'afeeee',
	pOeviTetYd: 'db7093',
	papayawEp: 'ffefd5',
	pHKpuff: 'ffdab9',
	peru: 'cd853f',
	pRk: 'ffc0cb',
	plum: 'dda0dd',
	powMrXe: 'b0e0e6',
	purpN: '800080',
	YbeccapurpN: '663399',
	Yd: 'ff0000',
	Psybrown: 'bc8f8f',
	PyOXe: '4169e1',
	saddNbPwn: '8b4513',
	sOmon: 'fa8072',
	sandybPwn: 'f4a460',
	sHgYF: '2e8b57',
	sHshell: 'fff5ee',
	siFna: 'a0522d',
	silver: 'c0c0c0',
	skyXe: '87ceeb',
	UXe: '6a5acd',
	UWay: '708090',
	UgYy: '708090',
	snow: 'fffafa',
	sprRggYF: 'ff7f',
	stAlXe: '4682b4',
	tan: 'd2b48c',
	teO: '8080',
	tEstN: 'd8bfd8',
	tomato: 'ff6347',
	Qe: '40e0d0',
	viTet: 'ee82ee',
	JHt: 'f5deb3',
	wEte: 'ffffff',
	wEtesmoke: 'f5f5f5',
	Lw: 'ffff00',
	LwgYF: '9acd32'
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map$2);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map$2[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];
  }
  return unpacked;
}

let names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}

const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function rgbString(v) {
  return v && (
    v.a < 255
      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
      : `rgb(${v.r}, ${v.g}, ${v.b})`
  );
}

const to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;
const from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate$1(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}

function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone$1(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = {r: 0, g: 0, b: 0, a: 255};
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = {r: input[0], g: input[1], b: input[2], a: 255};
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone$1(input, {r: 0, g: 0, b: 0, a: 1});
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === 'r') {
    return rgbParse(str);
  }
  return hueParse(str);
}
class Color {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === 'object') {
      v = fromObject(input);
    } else if (type === 'string') {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone$1(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : undefined;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : undefined;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : undefined;
  }
  mix(color, weight) {
    if (color) {
      const c1 = this.rgb;
      const c2 = color.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
      w2 = 1 - w1;
      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color, t) {
    if (color) {
      this._rgb = interpolate$1(this._rgb, color._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
}

/*!
 * Chart.js v4.4.9
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */

/**
 * @namespace Chart.helpers
 */ /**
 * An empty function that can be used, for example, for optional callback.
 */ function noop() {
/* noop */ }
/**
 * Returns a unique id, sequentially generated from a global variable.
 */ const uid = (()=>{
    let id = 0;
    return ()=>id++;
})();
/**
 * Returns true if `value` is neither null nor undefined, else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */ function isNullOrUndef(value) {
    return value === null || value === undefined;
}
/**
 * Returns true if `value` is an array (including typed arrays), else returns false.
 * @param value - The value to test.
 * @function
 */ function isArray(value) {
    if (Array.isArray && Array.isArray(value)) {
        return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {
        return true;
    }
    return false;
}
/**
 * Returns true if `value` is an object (excluding null), else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */ function isObject(value) {
    return value !== null && Object.prototype.toString.call(value) === '[object Object]';
}
/**
 * Returns true if `value` is a finite number, else returns false
 * @param value  - The value to test.
 */ function isNumberFinite(value) {
    return (typeof value === 'number' || value instanceof Number) && isFinite(+value);
}
/**
 * Returns `value` if finite, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is not finite.
 */ function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
}
/**
 * Returns `value` if defined, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is undefined.
 */ function valueOrDefault(value, defaultValue) {
    return typeof value === 'undefined' ? defaultValue : value;
}
const toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;
const toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;
/**
 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
 * @param fn - The function to call.
 * @param args - The arguments with which `fn` should be called.
 * @param [thisArg] - The value of `this` provided for the call to `fn`.
 */ function callback(fn, args, thisArg) {
    if (fn && typeof fn.call === 'function') {
        return fn.apply(thisArg, args);
    }
}
function each(loopable, fn, thisArg, reverse) {
    let i, len, keys;
    if (isArray(loopable)) {
        len = loopable.length;
        {
            for(i = 0; i < len; i++){
                fn.call(thisArg, loopable[i], i);
            }
        }
    } else if (isObject(loopable)) {
        keys = Object.keys(loopable);
        len = keys.length;
        for(i = 0; i < len; i++){
            fn.call(thisArg, loopable[keys[i]], keys[i]);
        }
    }
}
/**
 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
 * @param a0 - The array to compare
 * @param a1 - The array to compare
 * @private
 */ function _elementsEqual(a0, a1) {
    let i, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
        return false;
    }
    for(i = 0, ilen = a0.length; i < ilen; ++i){
        v0 = a0[i];
        v1 = a1[i];
        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
            return false;
        }
    }
    return true;
}
/**
 * Returns a deep copy of `source` without keeping references on objects and arrays.
 * @param source - The value to clone.
 */ function clone(source) {
    if (isArray(source)) {
        return source.map(clone);
    }
    if (isObject(source)) {
        const target = Object.create(null);
        const keys = Object.keys(source);
        const klen = keys.length;
        let k = 0;
        for(; k < klen; ++k){
            target[keys[k]] = clone(source[keys[k]]);
        }
        return target;
    }
    return source;
}
function isValidKey(key) {
    return [
        '__proto__',
        'prototype',
        'constructor'
    ].indexOf(key) === -1;
}
/**
 * The default merger when Chart.helpers.merge is called without merger option.
 * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
 * @private
 */ function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
        return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        merge(tval, sval, options);
    } else {
        target[key] = clone(sval);
    }
}
function merge(target, source, options) {
    const sources = isArray(source) ? source : [
        source
    ];
    const ilen = sources.length;
    if (!isObject(target)) {
        return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    let current;
    for(let i = 0; i < ilen; ++i){
        current = sources[i];
        if (!isObject(current)) {
            continue;
        }
        const keys = Object.keys(current);
        for(let k = 0, klen = keys.length; k < klen; ++k){
            merger(keys[k], target, current, options);
        }
    }
    return target;
}
function mergeIf(target, source) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return merge(target, source, {
        merger: _mergerIf
    });
}
/**
 * Merges source[key] in target[key] only if target[key] is undefined.
 * @private
 */ function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
        return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
        mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
        target[key] = clone(sval);
    }
}
// resolveObjectKey resolver cache
const keyResolvers = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    '': (v)=>v,
    // default resolvers
    x: (o)=>o.x,
    y: (o)=>o.y
};
/**
 * @private
 */ function _splitKey(key) {
    const parts = key.split('.');
    const keys = [];
    let tmp = '';
    for (const part of parts){
        tmp += part;
        if (tmp.endsWith('\\')) {
            tmp = tmp.slice(0, -1) + '.';
        } else {
            keys.push(tmp);
            tmp = '';
        }
    }
    return keys;
}
function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj)=>{
        for (const k of keys){
            if (k === '') {
                break;
            }
            obj = obj && obj[k];
        }
        return obj;
    };
}
function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
}
/**
 * @private
 */ function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value)=>typeof value !== 'undefined';
const isFunction = (value)=>typeof value === 'function';
// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384
const setsEqual = (a, b)=>{
    if (a.size !== b.size) {
        return false;
    }
    for (const item of a){
        if (!b.has(item)) {
            return false;
        }
    }
    return true;
};
/**
 * @param e - The event
 * @private
 */ function _isClickEvent(e) {
    return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';
}

/**
 * @alias Chart.helpers.math
 * @namespace
 */ const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function almostEquals(x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
}
/**
 * Implementation of the nice number algorithm used in determining where axis labels will go
 */ function niceNum(range) {
    const roundedRange = Math.round(range);
    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
    const niceRange = Math.pow(10, Math.floor(log10(range)));
    const fraction = range / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
}
/**
 * Returns an array of factors sorted from 1 to sqrt(value)
 * @private
 */ function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i;
    for(i = 1; i < sqrt; i++){
        if (value % i === 0) {
            result.push(i);
            result.push(value / i);
        }
    }
    if (sqrt === (sqrt | 0)) {
        result.push(sqrt);
    }
    result.sort((a, b)=>a - b).pop();
    return result;
}
/**
 * Verifies that attempting to coerce n to string or number won't throw a TypeError.
 */ function isNonPrimitive(n) {
    return typeof n === 'symbol' || typeof n === 'object' && n !== null && !(Symbol.toPrimitive in n || 'toString' in n || 'valueOf' in n);
}
function isNumber(n) {
    return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
    const rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
}
/**
 * @private
 */ function _setMinAndMaxByKey(array, target, property) {
    let i, ilen, value;
    for(i = 0, ilen = array.length; i < ilen; i++){
        value = array[i][property];
        if (!isNaN(value)) {
            target.min = Math.min(target.min, value);
            target.max = Math.max(target.max, value);
        }
    }
}
function toRadians(degrees) {
    return degrees * (PI / 180);
}
function toDegrees(radians) {
    return radians * (180 / PI);
}
/**
 * Returns the number of decimal places
 * i.e. the number of digits after the decimal point, of the value of this Number.
 * @param x - A number.
 * @returns The number of decimal places.
 * @private
 */ function _decimalPlaces(x) {
    if (!isNumberFinite(x)) {
        return;
    }
    let e = 1;
    let p = 0;
    while(Math.round(x * e) / e !== x){
        e *= 10;
        p++;
    }
    return p;
}
// Gets the angle from vertical upright to the point about a centre.
function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
    }
    return {
        angle,
        distance: radialDistanceFromCenter
    };
}
function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
/**
 * Shortest distance between angles, in either direction.
 * @private
 */ function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
}
/**
 * Normalize angle to be between 0 and 2*PI
 * @private
 */ function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
}
/**
 * @private
 */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
    const a = _normalizeAngle(angle);
    const s = _normalizeAngle(start);
    const e = _normalizeAngle(end);
    const angleToStart = _normalizeAngle(s - a);
    const angleToEnd = _normalizeAngle(e - a);
    const startToAngle = _normalizeAngle(a - s);
    const endToAngle = _normalizeAngle(a - e);
    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
/**
 * Limit `value` between `min` and `max`
 * @param value
 * @param min
 * @param max
 * @private
 */ function _limitValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
/**
 * @param {number} value
 * @private
 */ function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
}
/**
 * @param value
 * @param start
 * @param end
 * @param [epsilon]
 * @private
 */ function _isBetween(value, start, end, epsilon = 1e-6) {
    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}

function _lookup(table, value, cmp) {
    cmp = cmp || ((index)=>table[index] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while(hi - lo > 1){
        mid = lo + hi >> 1;
        if (cmp(mid)) {
            lo = mid;
        } else {
            hi = mid;
        }
    }
    return {
        lo,
        hi
    };
}
/**
 * Binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @param last - lookup last index
 * @private
 */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{
        const ti = table[index][key];
        return ti < value || ti === value && table[index + 1][key] === value;
    } : (index)=>table[index][key] < value);
/**
 * Reverse binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @private
 */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);
/**
 * Return subset of `values` between `min` and `max` inclusive.
 * Values are assumed to be in sorted order.
 * @param values - sorted array of values
 * @param min - min value
 * @param max - max value
 */ function _filterBetween(values, min, max) {
    let start = 0;
    let end = values.length;
    while(start < end && values[start] < min){
        start++;
    }
    while(end > start && values[end - 1] > max){
        end--;
    }
    return start > 0 || end < values.length ? values.slice(start, end) : values;
}
const arrayEvents = [
    'push',
    'pop',
    'shift',
    'splice',
    'unshift'
];
function listenArrayEvents(array, listener) {
    if (array._chartjs) {
        array._chartjs.listeners.push(listener);
        return;
    }
    Object.defineProperty(array, '_chartjs', {
        configurable: true,
        enumerable: false,
        value: {
            listeners: [
                listener
            ]
        }
    });
    arrayEvents.forEach((key)=>{
        const method = '_onData' + _capitalize(key);
        const base = array[key];
        Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value (...args) {
                const res = base.apply(this, args);
                array._chartjs.listeners.forEach((object)=>{
                    if (typeof object[method] === 'function') {
                        object[method](...args);
                    }
                });
                return res;
            }
        });
    });
}
function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
        return;
    }
    const listeners = stub.listeners;
    const index = listeners.indexOf(listener);
    if (index !== -1) {
        listeners.splice(index, 1);
    }
    if (listeners.length > 0) {
        return;
    }
    arrayEvents.forEach((key)=>{
        delete array[key];
    });
    delete array._chartjs;
}
/**
 * @param items
 */ function _arrayUnique(items) {
    const set = new Set(items);
    if (set.size === items.length) {
        return items;
    }
    return Array.from(set);
}
/**
* Request animation polyfill
*/ const requestAnimFrame = function() {
    if (typeof window === 'undefined') {
        return function(callback) {
            return callback();
        };
    }
    return window.requestAnimationFrame;
}();
/**
 * Throttles calling `fn` once per animation frame
 * Latest arguments are used on the actual call
 */ function throttled(fn, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function(...args) {
        // Save the args for use later
        argsToUse = args;
        if (!ticking) {
            ticking = true;
            requestAnimFrame.call(window, ()=>{
                ticking = false;
                fn.apply(thisArg, argsToUse);
            });
        }
    };
}
/**
 * Debounces calling `fn` for `delay` ms
 */ function debounce(fn, delay) {
    let timeout;
    return function(...args) {
        if (delay) {
            clearTimeout(timeout);
            timeout = setTimeout(fn, delay, args);
        } else {
            fn.apply(this, args);
        }
        return delay;
    };
}
/**
 * Converts 'start' to 'left', 'end' to 'right' and others to 'center'
 * @private
 */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
/**
 * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`
 * @private
 */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
/**
 * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`
 * @private
 */ const _textX = (align, left, right, rtl)=>{
    const check = rtl ? 'left' : 'right';
    return align === check ? right : align === 'center' ? (left + right) / 2 : left;
};
/**
 * Return start and count of visible points.
 * @private
 */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start = 0;
    let count = pointCount;
    if (meta._sorted) {
        const { iScale , vScale , _parsed  } = meta;
        const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;
        const axis = iScale.axis;
        const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();
        if (minDefined) {
            start = Math.min(// @ts-expect-error Need to type _parsed
            _lookupByKey(_parsed, axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey
            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);
            if (spanGaps) {
                const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point)=>!isNullOrUndef(point[vScale.axis]));
                start -= Math.max(0, distanceToDefinedLo);
            }
            start = _limitValue(start, 0, pointCount - 1);
        }
        if (maxDefined) {
            let end = Math.max(// @ts-expect-error Need to type _parsed
            _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey
            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);
            if (spanGaps) {
                const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point)=>!isNullOrUndef(point[vScale.axis]));
                end += Math.max(0, distanceToDefinedHi);
            }
            count = _limitValue(end, start, pointCount) - start;
        } else {
            count = pointCount - start;
        }
    }
    return {
        start,
        count
    };
}
/**
 * Checks if the scale ranges have changed.
 * @param {object} meta - dataset meta.
 * @returns {boolean}
 * @private
 */ function _scaleRangesChanged(meta) {
    const { xScale , yScale , _scaleRanges  } = meta;
    const newRanges = {
        xmin: xScale.min,
        xmax: xScale.max,
        ymin: yScale.min,
        ymax: yScale.max
    };
    if (!_scaleRanges) {
        meta._scaleRanges = newRanges;
        return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
}

const atEdge = (t)=>t === 0 || t === 1;
const elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
const elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
/**
 * Easing functions adapted from Robert Penner's easing equations.
 * @namespace Chart.helpers.easing.effects
 * @see http://www.robertpenner.com/easing/
 */ const effects = {
    linear: (t)=>t,
    easeInQuad: (t)=>t * t,
    easeOutQuad: (t)=>-t * (t - 2),
    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
    easeInCubic: (t)=>t * t * t,
    easeOutCubic: (t)=>(t -= 1) * t * t + 1,
    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
    easeInQuart: (t)=>t * t * t * t,
    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),
    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
    easeInQuint: (t)=>t * t * t * t * t,
    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,
    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,
    easeOutSine: (t)=>Math.sin(t * HALF_PI),
    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),
    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),
    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
    easeInOutElastic (t) {
        const s = 0.1125;
        const p = 0.45;
        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
    },
    easeInBack (t) {
        const s = 1.70158;
        return t * t * ((s + 1) * t - s);
    },
    easeOutBack (t) {
        const s = 1.70158;
        return (t -= 1) * t * ((s + 1) * t + s) + 1;
    },
    easeInOutBack (t) {
        let s = 1.70158;
        if ((t /= 0.5) < 1) {
            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }
        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    },
    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),
    easeOutBounce (t) {
        const m = 7.5625;
        const d = 2.75;
        if (t < 1 / d) {
            return m * t * t;
        }
        if (t < 2 / d) {
            return m * (t -= 1.5 / d) * t + 0.75;
        }
        if (t < 2.5 / d) {
            return m * (t -= 2.25 / d) * t + 0.9375;
        }
        return m * (t -= 2.625 / d) * t + 0.984375;
    },
    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};

function isPatternOrGradient(value) {
    if (value && typeof value === 'object') {
        const type = value.toString();
        return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';
    }
    return false;
}
function color(value) {
    return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}

const numbers = [
    'x',
    'y',
    'borderWidth',
    'radius',
    'tension'
];
const colors = [
    'color',
    'borderColor',
    'backgroundColor'
];
function applyAnimationsDefaults(defaults) {
    defaults.set('animation', {
        delay: undefined,
        duration: 1000,
        easing: 'easeOutQuart',
        fn: undefined,
        from: undefined,
        loop: undefined,
        to: undefined,
        type: undefined
    });
    defaults.describe('animation', {
        _fallback: false,
        _indexable: false,
        _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'
    });
    defaults.set('animations', {
        colors: {
            type: 'color',
            properties: colors
        },
        numbers: {
            type: 'number',
            properties: numbers
        }
    });
    defaults.describe('animations', {
        _fallback: 'animation'
    });
    defaults.set('transitions', {
        active: {
            animation: {
                duration: 400
            }
        },
        resize: {
            animation: {
                duration: 0
            }
        },
        show: {
            animations: {
                colors: {
                    from: 'transparent'
                },
                visible: {
                    type: 'boolean',
                    duration: 0
                }
            }
        },
        hide: {
            animations: {
                colors: {
                    to: 'transparent'
                },
                visible: {
                    type: 'boolean',
                    easing: 'linear',
                    fn: (v)=>v | 0
                }
            }
        }
    });
}

function applyLayoutsDefaults(defaults) {
    defaults.set('layout', {
        autoPadding: true,
        padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }
    });
}

const intlCache = new Map();
function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
        formatter = new Intl.NumberFormat(locale, options);
        intlCache.set(cacheKey, formatter);
    }
    return formatter;
}
function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
}

const formatters = {
 values (value) {
        return isArray(value) ?  value : '' + value;
    },
 numeric (tickValue, index, ticks) {
        if (tickValue === 0) {
            return '0';
        }
        const locale = this.chart.options.locale;
        let notation;
        let delta = tickValue;
        if (ticks.length > 1) {
            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
            if (maxTick < 1e-4 || maxTick > 1e+15) {
                notation = 'scientific';
            }
            delta = calculateDelta(tickValue, ticks);
        }
        const logDelta = log10(Math.abs(delta));
        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
        const options = {
            notation,
            minimumFractionDigits: numDecimal,
            maximumFractionDigits: numDecimal
        };
        Object.assign(options, this.options.ticks.format);
        return formatNumber(tickValue, locale, options);
    },
 logarithmic (tickValue, index, ticks) {
        if (tickValue === 0) {
            return '0';
        }
        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
        if ([
            1,
            2,
            3,
            5,
            10,
            15
        ].includes(remain) || index > 0.8 * ticks.length) {
            return formatters.numeric.call(this, tickValue, index, ticks);
        }
        return '';
    }
};
function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
        delta = tickValue - Math.floor(tickValue);
    }
    return delta;
}
 var Ticks = {
    formatters
};

function applyScaleDefaults(defaults) {
    defaults.set('scale', {
        display: true,
        offset: false,
        reverse: false,
        beginAtZero: false,
 bounds: 'ticks',
        clip: true,
 grace: 0,
        grid: {
            display: true,
            lineWidth: 1,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: (_ctx, options)=>options.lineWidth,
            tickColor: (_ctx, options)=>options.color,
            offset: false
        },
        border: {
            display: true,
            dash: [],
            dashOffset: 0.0,
            width: 1
        },
        title: {
            display: false,
            text: '',
            padding: {
                top: 4,
                bottom: 4
            }
        },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: '',
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: 'center',
            crossAlign: 'near',
            showLabelBackdrop: false,
            backdropColor: 'rgba(255, 255, 255, 0.75)',
            backdropPadding: 2
        }
    });
    defaults.route('scale.ticks', 'color', '', 'color');
    defaults.route('scale.grid', 'color', '', 'borderColor');
    defaults.route('scale.border', 'color', '', 'borderColor');
    defaults.route('scale.title', 'color', '', 'color');
    defaults.describe('scale', {
        _fallback: false,
        _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',
        _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'
    });
    defaults.describe('scales', {
        _fallback: 'scale'
    });
    defaults.describe('scale.ticks', {
        _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',
        _indexable: (name)=>name !== 'backdropPadding'
    });
}

const overrides = Object.create(null);
const descriptors = Object.create(null);
 function getScope$1(node, key) {
    if (!key) {
        return node;
    }
    const keys = key.split('.');
    for(let i = 0, n = keys.length; i < n; ++i){
        const k = keys[i];
        node = node[k] || (node[k] = Object.create(null));
    }
    return node;
}
function set(root, scope, values) {
    if (typeof scope === 'string') {
        return merge(getScope$1(root, scope), values);
    }
    return merge(getScope$1(root, ''), scope);
}
 class Defaults {
    constructor(_descriptors, _appliers){
        this.animation = undefined;
        this.backgroundColor = 'rgba(0,0,0,0.1)';
        this.borderColor = 'rgba(0,0,0,0.1)';
        this.color = '#666';
        this.datasets = {};
        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();
        this.elements = {};
        this.events = [
            'mousemove',
            'mouseout',
            'click',
            'touchstart',
            'touchmove'
        ];
        this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: 'normal',
            lineHeight: 1.2,
            weight: null
        };
        this.hover = {};
        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);
        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);
        this.hoverColor = (ctx, options)=>getHoverColor(options.color);
        this.indexAxis = 'x';
        this.interaction = {
            mode: 'nearest',
            intersect: true,
            includeInvisible: false
        };
        this.maintainAspectRatio = true;
        this.onHover = null;
        this.onClick = null;
        this.parsing = true;
        this.plugins = {};
        this.responsive = true;
        this.scale = undefined;
        this.scales = {};
        this.showLine = true;
        this.drawActiveElementsOnTop = true;
        this.describe(_descriptors);
        this.apply(_appliers);
    }
 set(scope, values) {
        return set(this, scope, values);
    }
 get(scope) {
        return getScope$1(this, scope);
    }
 describe(scope, values) {
        return set(descriptors, scope, values);
    }
    override(scope, values) {
        return set(overrides, scope, values);
    }
 route(scope, name, targetScope, targetName) {
        const scopeObject = getScope$1(this, scope);
        const targetScopeObject = getScope$1(this, targetScope);
        const privateName = '_' + name;
        Object.defineProperties(scopeObject, {
            [privateName]: {
                value: scopeObject[name],
                writable: true
            },
            [name]: {
                enumerable: true,
                get () {
                    const local = this[privateName];
                    const target = targetScopeObject[targetName];
                    if (isObject(local)) {
                        return Object.assign({}, target, local);
                    }
                    return valueOrDefault(local, target);
                },
                set (value) {
                    this[privateName] = value;
                }
            }
        });
    }
    apply(appliers) {
        appliers.forEach((apply)=>apply(this));
    }
}
var defaults = /* #__PURE__ */ new Defaults({
    _scriptable: (name)=>!name.startsWith('on'),
    _indexable: (name)=>name !== 'events',
    hover: {
        _fallback: 'interaction'
    },
    interaction: {
        _scriptable: false,
        _indexable: false
    }
}, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
]);

/**
 * Converts the given font object into a CSS font string.
 * @param font - A font object.
 * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
 * @private
 */ function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
        return null;
    }
    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
}
/**
 * @private
 */ function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
        textWidth = data[string] = ctx.measureText(string).width;
        gc.push(string);
    }
    if (textWidth > longest) {
        longest = textWidth;
    }
    return longest;
}
/**
 * @private
 */ // eslint-disable-next-line complexity
function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = cache.data = cache.data || {};
    let gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
        data = cache.data = {};
        gc = cache.garbageCollect = [];
        cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i, j, jlen, thing, nestedThing;
    for(i = 0; i < ilen; i++){
        thing = arrayOfThings[i];
        // Undefined strings and arrays should not be measured
        if (thing !== undefined && thing !== null && !isArray(thing)) {
            longest = _measureText(ctx, data, gc, longest, thing);
        } else if (isArray(thing)) {
            // if it is an array lets measure each element
            // to do maybe simplify this function a bit so we can do this more recursively?
            for(j = 0, jlen = thing.length; j < jlen; j++){
                nestedThing = thing[j];
                // Undefined strings and arrays should not be measured
                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {
                    longest = _measureText(ctx, data, gc, longest, nestedThing);
                }
            }
        }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
        for(i = 0; i < gcLen; i++){
            delete data[gc[i]];
        }
        gc.splice(0, gcLen);
    }
    return longest;
}
/**
 * Returns the aligned pixel value to avoid anti-aliasing blur
 * @param chart - The chart instance.
 * @param pixel - A pixel value.
 * @param width - The width of the element.
 * @returns The aligned pixel value.
 * @private
 */ function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
/**
 * Clears the entire canvas.
 */ function clearCanvas(canvas, ctx) {
    if (!ctx && !canvas) {
        return;
    }
    ctx = ctx || canvas.getContext('2d');
    ctx.save();
    // canvas.width and canvas.height do not consider the canvas transform,
    // while clearRect does
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
}
function drawPoint(ctx, options, x, y) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    drawPointLegend(ctx, options, x, y, null);
}
// eslint-disable-next-line complexity
function drawPointLegend(ctx, options, x, y, w) {
    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === 'object') {
        type = style.toString();
        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rad);
            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
            ctx.restore();
            return;
        }
    }
    if (isNaN(radius) || radius <= 0) {
        return;
    }
    ctx.beginPath();
    switch(style){
        // Default includes circle
        default:
            if (w) {
                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
            } else {
                ctx.arc(x, y, radius, 0, TAU);
            }
            ctx.closePath();
            break;
        case 'triangle':
            width = w ? w / 2 : radius;
            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;
        case 'rectRounded':
            // NOTE: the rounded rect implementation changed to use `arc` instead of
            // `quadraticCurveTo` since it generates better results when rect is
            // almost a circle. 0.516 (instead of 0.5) produces results with visually
            // closer proportion to the previous impl and it is inscribed in the
            // circle with `radius`. For more details, see the following PRs:
            // https://github.com/chartjs/Chart.js/issues/5597
            // https://github.com/chartjs/Chart.js/issues/5858
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;
        case 'rect':
            if (!rotation) {
                size = Math.SQRT1_2 * radius;
                width = w ? w / 2 : size;
                ctx.rect(x - width, y - size, 2 * width, 2 * size);
                break;
            }
            rad += QUARTER_PI;
        /* falls through */ case 'rectRot':
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            ctx.closePath();
            break;
        case 'crossRot':
            rad += QUARTER_PI;
        /* falls through */ case 'cross':
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            break;
        case 'star':
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            rad += QUARTER_PI;
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            break;
        case 'line':
            xOffset = w ? w / 2 : Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;
        case 'dash':
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
            break;
        case false:
            ctx.closePath();
            break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
        ctx.stroke();
    }
}
/**
 * Returns true if the point is inside the rectangle
 * @param point - The point to test
 * @param area - The rectangle
 * @param margin - allowed margin
 * @private
 */ function _isPointInArea(point, area, margin) {
    margin = margin || 0.5; // margin - default is to match rounded decimals
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
}
function unclipArea(ctx) {
    ctx.restore();
}
/**
 * @private
 */ function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) {
        return ctx.lineTo(target.x, target.y);
    }
    if (mode === 'middle') {
        const midpoint = (previous.x + target.x) / 2.0;
        ctx.lineTo(midpoint, previous.y);
        ctx.lineTo(midpoint, target.y);
    } else if (mode === 'after' !== !!flip) {
        ctx.lineTo(previous.x, target.y);
    } else {
        ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
}
/**
 * @private
 */ function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) {
        return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
    if (opts.translation) {
        ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
        ctx.rotate(opts.rotation);
    }
    if (opts.color) {
        ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
        ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
        ctx.textBaseline = opts.textBaseline;
    }
}
function decorateText(ctx, x, y, line, opts) {
    if (opts.strikethrough || opts.underline) {
        /**
     * Now that IE11 support has been dropped, we can use more
     * of the TextMetrics object. The actual bounding boxes
     * are unflagged in Chrome, Firefox, Edge, and Safari so they
     * can be safely used.
     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility
     */ const metrics = ctx.measureText(line);
        const left = x - metrics.actualBoundingBoxLeft;
        const right = x + metrics.actualBoundingBoxRight;
        const top = y - metrics.actualBoundingBoxAscent;
        const bottom = y + metrics.actualBoundingBoxDescent;
        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.beginPath();
        ctx.lineWidth = opts.decorationWidth || 2;
        ctx.moveTo(left, yDecoration);
        ctx.lineTo(right, yDecoration);
        ctx.stroke();
    }
}
function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
}
/**
 * Render text onto the canvas
 */ function renderText(ctx, text, x, y, font, opts = {}) {
    const lines = isArray(text) ? text : [
        text
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
    let i, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for(i = 0; i < lines.length; ++i){
        line = lines[i];
        if (opts.backdrop) {
            drawBackdrop(ctx, opts.backdrop);
        }
        if (stroke) {
            if (opts.strokeColor) {
                ctx.strokeStyle = opts.strokeColor;
            }
            if (!isNullOrUndef(opts.strokeWidth)) {
                ctx.lineWidth = opts.strokeWidth;
            }
            ctx.strokeText(line, x, y, opts.maxWidth);
        }
        ctx.fillText(line, x, y, opts.maxWidth);
        decorateText(ctx, x, y, line, opts);
        y += Number(font.lineHeight);
    }
    ctx.restore();
}
/**
 * Add a path of a rectangle with rounded corners to the current sub-path
 * @param ctx - Context
 * @param rect - Bounding rect
 */ function addRoundedRectPath(ctx, rect) {
    const { x , y , w , h , radius  } = rect;
    // top left arc
    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
    // line from top left to bottom left
    ctx.lineTo(x, y + h - radius.bottomLeft);
    // bottom left arc
    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    // line from bottom left to bottom right
    ctx.lineTo(x + w - radius.bottomRight, y + h);
    // bottom right arc
    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    // line from bottom right to top right
    ctx.lineTo(x + w, y + radius.topRight);
    // top right arc
    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    // line from top right to top left
    ctx.lineTo(x + radius.topLeft, y);
}

const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
/**
 * @alias Chart.helpers.options
 * @namespace
 */ /**
 * Converts the given line height `value` in pixels for a specific font `size`.
 * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
 * @param size - The font size (in pixels) used to resolve relative `value`.
 * @returns The effective line height in pixels (size * 1.2 if value is invalid).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
 * @since 2.7.0
 */ function toLineHeight(value, size) {
    const matches = ('' + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === 'normal') {
        return size * 1.2;
    }
    value = +matches[2];
    switch(matches[3]){
        case 'px':
            return value;
        case '%':
            value /= 100;
            break;
    }
    return size * value;
}
const numberOrZero = (v)=>+v || 0;
function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;
    for (const prop of keys){
        ret[prop] = numberOrZero(read(prop));
    }
    return ret;
}
/**
 * Converts the given value into a TRBL object.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left)
 * @since 3.0.0
 */ function toTRBL(value) {
    return _readValueToProps(value, {
        top: 'y',
        right: 'x',
        bottom: 'y',
        left: 'x'
    });
}
/**
 * Converts the given value into a TRBL corners object (similar with css border-radius).
 * @param value - If a number, set the value to all TRBL corner components,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)
 * @since 3.0.0
 */ function toTRBLCorners(value) {
    return _readValueToProps(value, [
        'topLeft',
        'topRight',
        'bottomLeft',
        'bottomRight'
    ]);
}
/**
 * Converts the given value into a padding object with pre-computed width/height.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left, width, height)
 * @since 2.7.0
 */ function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
}
/**
 * Parses font options and returns the font object.
 * @param options - A object that contains font options to be parsed.
 * @param fallback - A object that contains fallback font options.
 * @return The font object.
 * @private
 */ function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === 'string') {
        size = parseInt(size, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !('' + style).match(FONT_STYLE)) {
        console.warn('Invalid font style specified: "' + style + '"');
        style = undefined;
    }
    const font = {
        family: valueOrDefault(options.family, fallback.family),
        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
        size,
        style,
        weight: valueOrDefault(options.weight, fallback.weight),
        string: ''
    };
    font.string = toFontString(font);
    return font;
}
/**
 * Evaluates the given `inputs` sequentially and returns the first defined value.
 * @param inputs - An array of values, falling back to the last value.
 * @param context - If defined and the current value is a function, the value
 * is called with `context` as first argument and the result becomes the new input.
 * @param index - If defined and the current value is an array, the value
 * at `index` become the new input.
 * @param info - object to return information about resolution in
 * @param info.cacheable - Will be set to `false` if option is not cacheable.
 * @since 2.7.0
 */ function resolve(inputs, context, index, info) {
    let i, ilen, value;
    for(i = 0, ilen = inputs.length; i < ilen; ++i){
        value = inputs[i];
        if (value === undefined) {
            continue;
        }
        if (value !== undefined) {
            return value;
        }
    }
}
/**
 * @param minmax
 * @param grace
 * @param beginAtZero
 * @private
 */ function _addGrace(minmax, grace, beginAtZero) {
    const { min , max  } = minmax;
    const change = toDimension(grace, (max - min) / 2);
    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;
    return {
        min: keepZero(min, -Math.abs(change)),
        max: keepZero(max, change)
    };
}
function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
}

/**
 * Creates a Proxy for resolving raw values for options.
 * @param scopes - The option scopes to look for values, in resolution order
 * @param prefixes - The prefixes for values, in resolution order.
 * @param rootScopes - The root option scopes
 * @param fallback - Parent scopes fallback
 * @param getTarget - callback for getting the target for changed values
 * @returns Proxy
 * @private
 */ function _createResolver(scopes, prefixes = [
    ''
], rootScopes, fallback, getTarget = ()=>scopes[0]) {
    const finalRootScopes = rootScopes || scopes;
    if (typeof fallback === 'undefined') {
        fallback = _resolve('_fallback', scopes);
    }
    const cache = {
        [Symbol.toStringTag]: 'Object',
        _cacheable: true,
        _scopes: scopes,
        _rootScopes: finalRootScopes,
        _fallback: fallback,
        _getTarget: getTarget,
        override: (scope)=>_createResolver([
                scope,
                ...scopes
            ], prefixes, finalRootScopes, fallback)
    };
    return new Proxy(cache, {
        /**
     * A trap for the delete operator.
     */ deleteProperty (target, prop) {
            delete target[prop]; // remove from cache
            delete target._keys; // remove cached keys
            delete scopes[0][prop]; // remove from top level scope
            return true;
        },
        /**
     * A trap for getting property values.
     */ get (target, prop) {
            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));
        },
        /**
     * A trap for Object.getOwnPropertyDescriptor.
     * Also used by Object.hasOwnProperty.
     */ getOwnPropertyDescriptor (target, prop) {
            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
        },
        /**
     * A trap for Object.getPrototypeOf.
     */ getPrototypeOf () {
            return Reflect.getPrototypeOf(scopes[0]);
        },
        /**
     * A trap for the in operator.
     */ has (target, prop) {
            return getKeysFromAllScopes(target).includes(prop);
        },
        /**
     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
     */ ownKeys (target) {
            return getKeysFromAllScopes(target);
        },
        /**
     * A trap for setting property values.
     */ set (target, prop, value) {
            const storage = target._storage || (target._storage = getTarget());
            target[prop] = storage[prop] = value; // set to top level scope + cache
            delete target._keys; // remove cached keys
            return true;
        }
    });
}
/**
 * Returns an Proxy for resolving option values with context.
 * @param proxy - The Proxy returned by `_createResolver`
 * @param context - Context object for scriptable/indexable options
 * @param subProxy - The proxy provided for scriptable options
 * @param descriptorDefaults - Defaults for descriptors
 * @private
 */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
        _cacheable: false,
        _proxy: proxy,
        _context: context,
        _subProxy: subProxy,
        _stack: new Set(),
        _descriptors: _descriptors(proxy, descriptorDefaults),
        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),
        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
        /**
     * A trap for the delete operator.
     */ deleteProperty (target, prop) {
            delete target[prop]; // remove from cache
            delete proxy[prop]; // remove from proxy
            return true;
        },
        /**
     * A trap for getting property values.
     */ get (target, prop, receiver) {
            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));
        },
        /**
     * A trap for Object.getOwnPropertyDescriptor.
     * Also used by Object.hasOwnProperty.
     */ getOwnPropertyDescriptor (target, prop) {
            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
                enumerable: true,
                configurable: true
            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);
        },
        /**
     * A trap for Object.getPrototypeOf.
     */ getPrototypeOf () {
            return Reflect.getPrototypeOf(proxy);
        },
        /**
     * A trap for the in operator.
     */ has (target, prop) {
            return Reflect.has(proxy, prop);
        },
        /**
     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
     */ ownKeys () {
            return Reflect.ownKeys(proxy);
        },
        /**
     * A trap for setting property values.
     */ set (target, prop, value) {
            proxy[prop] = value; // set to proxy
            delete target[prop]; // remove from cache
            return true;
        }
    });
}
/**
 * @private
 */ function _descriptors(proxy, defaults = {
    scriptable: true,
    indexable: true
}) {
    const { _scriptable =defaults.scriptable , _indexable =defaults.indexable , _allKeys =defaults.allKeys  } = proxy;
    return {
        allKeys: _allKeys,
        scriptable: _scriptable,
        indexable: _indexable,
        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,
        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable
    };
}
const readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value)=>isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve) {
    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {
        return target[prop];
    }
    const value = resolve();
    // cache the resolved value
    target[prop] = value;
    return value;
}
function _resolveWithContext(target, prop, receiver) {
    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;
    let value = _proxy[prop]; // resolve from proxy
    // resolve with context
    if (isFunction(value) && descriptors.isScriptable(prop)) {
        value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray(value) && value.length) {
        value = _resolveArray(prop, value, target, descriptors.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
        // if the resolved value is an object, create a sub resolver for it
        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
    }
    return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
    const { _proxy , _context , _subProxy , _stack  } = target;
    if (_stack.has(prop)) {
        throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
    }
    _stack.add(prop);
    let value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
        // When scriptable option returns an object, create a resolver on that.
        value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
}
function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;
    if (typeof _context.index !== 'undefined' && isIndexable(prop)) {
        return value[_context.index % value.length];
    } else if (isObject(value[0])) {
        // Array of objects, return array or resolvers
        const arr = value;
        const scopes = _proxy._scopes.filter((s)=>s !== arr);
        value = [];
        for (const item of arr){
            const resolver = createSubResolver(scopes, _proxy, prop, item);
            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
        }
    }
    return value;
}
function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;
function addScopes(set, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes){
        const scope = getScope(key, parent);
        if (scope) {
            set.add(scope);
            const fallback = resolveFallback(scope._fallback, key, value);
            if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {
                // When we reach the descriptor that defines a new _fallback, return that.
                // The fallback will resume to that new scope.
                return fallback;
            }
        } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {
            // Fallback to `false` results to `false`, when falling back to different key.
            // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`
            return null;
        }
    }
    return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
        ...parentScopes,
        ...rootScopes
    ];
    const set = new Set();
    set.add(value);
    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
    if (key === null) {
        return false;
    }
    if (typeof fallback !== 'undefined' && fallback !== prop) {
        key = addScopesFromKey(set, allScopes, fallback, key, value);
        if (key === null) {
            return false;
        }
    }
    return _createResolver(Array.from(set), [
        ''
    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set, allScopes, key, fallback, item) {
    while(key){
        key = addScopes(set, allScopes, key, fallback, item);
    }
    return key;
}
function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
        parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject(value)) {
        // For array of objects, the object is used to store updated values
        return value;
    }
    return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes){
        value = _resolve(readKey(prefix, prop), scopes);
        if (typeof value !== 'undefined') {
            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
        }
    }
}
function _resolve(key, scopes) {
    for (const scope of scopes){
        if (!scope) {
            continue;
        }
        const value = scope[key];
        if (typeof value !== 'undefined') {
            return value;
        }
    }
}
function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
        keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
}
function resolveKeysFromAllScopes(scopes) {
    const set = new Set();
    for (const scope of scopes){
        for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){
            set.add(key);
        }
    }
    return Array.from(set);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
    const { iScale  } = meta;
    const { key ='r'  } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for(i = 0, ilen = count; i < ilen; ++i){
        index = i + start;
        item = data[index];
        parsed[i] = {
            r: iScale.parse(resolveObjectKey(item, key), index)
        };
    }
    return parsed;
}

const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];
const getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
    // Props to Rob Spencer at scaled innovation for his post on splining between points
    // http://scaledinnovation.com/analytics/splines/aboutSplines.html
    // This function must also respect "skipped" points
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    // If all points are the same, s01 & s02 will be inf
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t * s01; // scaling factor for triangle Ta
    const fb = t * s12;
    return {
        previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
        },
        next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
        }
    };
}
/**
 * Adjust tangents to ensure monotonic properties
 */ function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(let i = 0; i < pointsLen - 1; ++i){
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent || !pointAfter) {
            continue;
        }
        if (almostEquals(deltaK[i], 0, EPSILON)) {
            mK[i] = mK[i + 1] = 0;
            continue;
        }
        alphaK = mK[i] / deltaK[i];
        betaK = mK[i + 1] / deltaK[i];
        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
        if (squaredMagnitude <= 9) {
            continue;
        }
        tauK = 3 / Math.sqrt(squaredMagnitude);
        mK[i] = alphaK * tauK * deltaK[i];
        mK[i + 1] = betaK * tauK * deltaK[i];
    }
}
function monotoneCompute(points, mK, indexAxis = 'x') {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(let i = 0; i < pointsLen; ++i){
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) {
            continue;
        }
        const iPixel = pointCurrent[indexAxis];
        const vPixel = pointCurrent[valueAxis];
        if (pointBefore) {
            delta = (iPixel - pointBefore[indexAxis]) / 3;
            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
        }
        if (pointAfter) {
            delta = (pointAfter[indexAxis] - iPixel) / 3;
            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
        }
    }
}
/**
 * This function calculates Bézier control points in a similar way than |splineCurve|,
 * but preserves monotonicity of the provided data and ensures no local extremums are added
 * between the dataset discrete points due to the interpolation.
 * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
 */ function splineCurveMonotone(points, indexAxis = 'x') {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    // Calculate slopes (deltaK) and initialize tangents (mK)
    let i, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(i = 0; i < pointsLen; ++i){
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) {
            continue;
        }
        if (pointAfter) {
            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0
            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
        }
        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
    return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
    let i, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for(i = 0, ilen = points.length; i < ilen; ++i){
        inAreaPrev = inArea;
        inArea = inAreaNext;
        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
        if (!inArea) {
            continue;
        }
        point = points[i];
        if (inAreaPrev) {
            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
        }
        if (inAreaNext) {
            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
        }
    }
}
/**
 * @private
 */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i, ilen, point, controlPoints;
    // Only consider points that are drawn in case the spanGaps option is used
    if (options.spanGaps) {
        points = points.filter((pt)=>!pt.skip);
    }
    if (options.cubicInterpolationMode === 'monotone') {
        splineCurveMonotone(points, indexAxis);
    } else {
        let prev = loop ? points[points.length - 1] : points[0];
        for(i = 0, ilen = points.length; i < ilen; ++i){
            point = points[i];
            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
            point.cp1x = controlPoints.previous.x;
            point.cp1y = controlPoints.previous.y;
            point.cp2x = controlPoints.next.x;
            point.cp2y = controlPoints.next.y;
            prev = point;
        }
    }
    if (options.capBezierPoints) {
        capBezierPoints(points, area);
    }
}

/**
 * @private
 */ function _isDomSupported() {
    return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * @private
 */ function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === '[object ShadowRoot]') {
        parent = parent.host;
    }
    return parent;
}
/**
 * convert max-width/max-height values that may be percentages into a number
 * @private
 */ function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === 'string') {
        valueInPixels = parseInt(styleValue, 10);
        if (styleValue.indexOf('%') !== -1) {
            // percentage * size in dimension
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
        }
    } else {
        valueInPixels = styleValue;
    }
    return valueInPixels;
}
const getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
    return getComputedStyle(el).getPropertyValue(property);
}
const positions = [
    'top',
    'right',
    'bottom',
    'left'
];
function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? '-' + suffix : '';
    for(let i = 0; i < 4; i++){
        const pos = positions[i];
        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
}
const useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);
/**
 * @param e
 * @param canvas
 * @returns Canvas position
 */ function getCanvasPosition(e, canvas) {
    const touches = e.touches;
    const source = touches && touches.length ? touches[0] : e;
    const { offsetX , offsetY  } = source;
    let box = false;
    let x, y;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
        x = offsetX;
        y = offsetY;
    } else {
        const rect = canvas.getBoundingClientRect();
        x = source.clientX - rect.left;
        y = source.clientY - rect.top;
        box = true;
    }
    return {
        x,
        y,
        box
    };
}
/**
 * Gets an event's x, y coordinates, relative to the chart area
 * @param event
 * @param chart
 * @returns x and y coordinates of the event
 */ function getRelativePosition(event, chart) {
    if ('native' in event) {
        return event;
    }
    const { canvas , currentDevicePixelRatio  } = chart;
    const style = getComputedStyle(canvas);
    const borderBox = style.boxSizing === 'border-box';
    const paddings = getPositionedStyle(style, 'padding');
    const borders = getPositionedStyle(style, 'border', 'width');
    const { x , y , box  } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width , height  } = chart;
    if (borderBox) {
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    return {
        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
}
function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === undefined || height === undefined) {
        const container = canvas && _getParentNode(canvas);
        if (!container) {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
        } else {
            const rect = container.getBoundingClientRect(); // this is the border box of the container
            const containerStyle = getComputedStyle(container);
            const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
            const containerPadding = getPositionedStyle(containerStyle, 'padding');
            width = rect.width - containerPadding.width - containerBorder.width;
            height = rect.height - containerPadding.height - containerBorder.height;
            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
        }
    }
    return {
        width,
        height,
        maxWidth: maxWidth || INFINITY,
        maxHeight: maxHeight || INFINITY
    };
}
const round1 = (v)=>Math.round(v * 10) / 10;
// eslint-disable-next-line complexity
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle(canvas);
    const margins = getPositionedStyle(style, 'margin');
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width , height  } = containerSize;
    if (style.boxSizing === 'content-box') {
        const borders = getPositionedStyle(style, 'border', 'width');
        const paddings = getPositionedStyle(style, 'padding');
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
        // https://github.com/chartjs/Chart.js/issues/4659
        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)
        height = round1(width / 2);
    }
    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
        height = containerSize.height;
        width = round1(Math.floor(height * aspectRatio));
    }
    return {
        width,
        height
    };
}
/**
 * @param chart
 * @param forceRatio
 * @param forceStyle
 * @returns True if the canvas context size or transformation has changed.
 */ function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = Math.floor(chart.height);
    chart.width = Math.floor(chart.width);
    const canvas = chart.canvas;
    // If no style has been set on the canvas, the render size is used as display size,
    // making the chart visually bigger, so let's enforce it to the "correct" values.
    // See https://github.com/chartjs/Chart.js/issues/3575
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
        canvas.style.height = `${chart.height}px`;
        canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
        chart.currentDevicePixelRatio = pixelRatio;
        canvas.height = deviceHeight;
        canvas.width = deviceWidth;
        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        return true;
    }
    return false;
}
/**
 * Detects support for options object argument in addEventListener.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
 * @private
 */ const supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
        const options = {
            get passive () {
                passiveSupported = true;
                return false;
            }
        };
        if (_isDomSupported()) {
            window.addEventListener('test', null, options);
            window.removeEventListener('test', null, options);
        }
    } catch (e) {
    // continue regardless of error
    }
    return passiveSupported;
}();
/**
 * The "used" size is the final value of a dimension property after all calculations have
 * been performed. This method uses the computed style of `element` but returns undefined
 * if the computed style is not expressed in pixels. That can happen in some cases where
 * `element` has a size relative to its parent and this last one is not yet displayed,
 * for example because of `display: none` on a parent node.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 * @returns Size in pixels or undefined if unknown.
 */ function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : undefined;
}

/**
 * @private
 */ function _pointInLine(p1, p2, t, mode) {
    return {
        x: p1.x + t * (p2.x - p1.x),
        y: p1.y + t * (p2.y - p1.y)
    };
}
/**
 * @private
 */ function _steppedInterpolation(p1, p2, t, mode) {
    return {
        x: p1.x + t * (p2.x - p1.x),
        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
    };
}
/**
 * @private
 */ function _bezierInterpolation(p1, p2, t, mode) {
    const cp1 = {
        x: p1.cp2x,
        y: p1.cp2y
    };
    const cp2 = {
        x: p2.cp1x,
        y: p2.cp1y
    };
    const a = _pointInLine(p1, cp1, t);
    const b = _pointInLine(cp1, cp2, t);
    const c = _pointInLine(cp2, p2, t);
    const d = _pointInLine(a, b, t);
    const e = _pointInLine(b, c, t);
    return _pointInLine(d, e, t);
}

const getRightToLeftAdapter = function(rectX, width) {
    return {
        x (x) {
            return rectX + rectX + width - x;
        },
        setWidth (w) {
            width = w;
        },
        textAlign (align) {
            if (align === 'center') {
                return align;
            }
            return align === 'right' ? 'left' : 'right';
        },
        xPlus (x, value) {
            return x - value;
        },
        leftForLtr (x, itemWidth) {
            return x - itemWidth;
        }
    };
};
const getLeftToRightAdapter = function() {
    return {
        x (x) {
            return x;
        },
        setWidth (w) {},
        textAlign (align) {
            return align;
        },
        xPlus (x, value) {
            return x + value;
        },
        leftForLtr (x, _itemWidth) {
            return x;
        }
    };
};
function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === 'ltr' || direction === 'rtl') {
        style = ctx.canvas.style;
        original = [
            style.getPropertyValue('direction'),
            style.getPropertyPriority('direction')
        ];
        style.setProperty('direction', direction, 'important');
        ctx.prevTextDirection = original;
    }
}
function restoreTextDirection(ctx, original) {
    if (original !== undefined) {
        delete ctx.prevTextDirection;
        ctx.canvas.style.setProperty('direction', original[0], original[1]);
    }
}

function propertyFn(property) {
    if (property === 'angle') {
        return {
            between: _angleBetween,
            compare: _angleDiff,
            normalize: _normalizeAngle
        };
    }
    return {
        between: _isBetween,
        compare: (a, b)=>a - b,
        normalize: (x)=>x
    };
}
function normalizeSegment({ start , end , count , loop , style  }) {
    return {
        start: start % count,
        end: end % count,
        loop: loop && (end - start + 1) % count === 0,
        style
    };
}
function getSegment(segment, points, bounds) {
    const { property , start: startBound , end: endBound  } = bounds;
    const { between , normalize  } = propertyFn(property);
    const count = points.length;
    let { start , end , loop  } = segment;
    let i, ilen;
    if (loop) {
        start += count;
        end += count;
        for(i = 0, ilen = count; i < ilen; ++i){
            if (!between(normalize(points[start % count][property]), startBound, endBound)) {
                break;
            }
            start--;
            end--;
        }
        start %= count;
        end %= count;
    }
    if (end < start) {
        end += count;
    }
    return {
        start,
        end,
        loop,
        style: segment.style
    };
}
 function _boundSegment(segment, points, bounds) {
    if (!bounds) {
        return [
            segment
        ];
    }
    const { property , start: startBound , end: endBound  } = bounds;
    const count = points.length;
    const { compare , between , normalize  } = propertyFn(property);
    const { start , end , loop , style  } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = ()=>inside || startIsBefore();
    const shouldStop = ()=>!inside || endIsBefore();
    for(let i = start, prev = start; i <= end; ++i){
        point = points[i % count];
        if (point.skip) {
            continue;
        }
        value = normalize(point[property]);
        if (value === prevValue) {
            continue;
        }
        inside = between(value, startBound, endBound);
        if (subStart === null && shouldStart()) {
            subStart = compare(value, startBound) === 0 ? i : prev;
        }
        if (subStart !== null && shouldStop()) {
            result.push(normalizeSegment({
                start: subStart,
                end: i,
                loop,
                count,
                style
            }));
            subStart = null;
        }
        prev = i;
        prevValue = value;
    }
    if (subStart !== null) {
        result.push(normalizeSegment({
            start: subStart,
            end,
            loop,
            count,
            style
        }));
    }
    return result;
}
 function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for(let i = 0; i < segments.length; i++){
        const sub = _boundSegment(segments[i], line.points, bounds);
        if (sub.length) {
            result.push(...sub);
        }
    }
    return result;
}
 function findStartAndEnd(points, count, loop, spanGaps) {
    let start = 0;
    let end = count - 1;
    if (loop && !spanGaps) {
        while(start < count && !points[start].skip){
            start++;
        }
    }
    while(start < count && points[start].skip){
        start++;
    }
    start %= count;
    if (loop) {
        end += start;
    }
    while(end > start && points[end % count].skip){
        end--;
    }
    end %= count;
    return {
        start,
        end
    };
}
 function solidSegments(points, start, max, loop) {
    const count = points.length;
    const result = [];
    let last = start;
    let prev = points[start];
    let end;
    for(end = start + 1; end <= max; ++end){
        const cur = points[end % count];
        if (cur.skip || cur.stop) {
            if (!prev.skip) {
                loop = false;
                result.push({
                    start: start % count,
                    end: (end - 1) % count,
                    loop
                });
                start = last = cur.stop ? end : null;
            }
        } else {
            last = end;
            if (prev.skip) {
                start = end;
            }
        }
        prev = cur;
    }
    if (last !== null) {
        result.push({
            start: start % count,
            end: last % count,
            loop
        });
    }
    return result;
}
 function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
        return [];
    }
    const loop = !!line._loop;
    const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
        return splitByStyles(line, [
            {
                start,
                end,
                loop
            }
        ], points, segmentOptions);
    }
    const max = end < start ? end + count : end;
    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
 function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
        return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
}
 function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start = segments[0].start;
    let i = start;
    function addStyle(s, e, l, st) {
        const dir = spanGaps ? -1 : 1;
        if (s === e) {
            return;
        }
        s += count;
        while(points[s % count].skip){
            s -= dir;
        }
        while(points[e % count].skip){
            e += dir;
        }
        if (s % count !== e % count) {
            result.push({
                start: s % count,
                end: e % count,
                loop: l,
                style: st
            });
            prevStyle = st;
            start = e % count;
        }
    }
    for (const segment of segments){
        start = spanGaps ? start : segment.start;
        let prev = points[start % count];
        let style;
        for(i = start + 1; i <= segment.end; i++){
            const pt = points[i % count];
            style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                type: 'segment',
                p0: prev,
                p1: pt,
                p0DataIndex: (i - 1) % count,
                p1DataIndex: i % count,
                datasetIndex
            })));
            if (styleChanged(style, prevStyle)) {
                addStyle(start, i - 1, segment.loop, prevStyle);
            }
            prev = pt;
            prevStyle = style;
        }
        if (start < i - 1) {
            addStyle(start, i - 1, segment.loop, prevStyle);
        }
    }
    return result;
}
function readStyle(options) {
    return {
        backgroundColor: options.backgroundColor,
        borderCapStyle: options.borderCapStyle,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderJoinStyle: options.borderJoinStyle,
        borderWidth: options.borderWidth,
        borderColor: options.borderColor
    };
}
function styleChanged(style, prevStyle) {
    if (!prevStyle) {
        return false;
    }
    const cache = [];
    const replacer = function(key, value) {
        if (!isPatternOrGradient(value)) {
            return value;
        }
        if (!cache.includes(value)) {
            cache.push(value);
        }
        return cache.indexOf(value);
    };
    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}

function getSizeForArea(scale, chartArea, field) {
    return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
    const { xScale , yScale  } = meta;
    if (xScale && yScale) {
        return {
            left: getSizeForArea(xScale, chartArea, 'left'),
            right: getSizeForArea(xScale, chartArea, 'right'),
            top: getSizeForArea(yScale, chartArea, 'top'),
            bottom: getSizeForArea(yScale, chartArea, 'bottom')
        };
    }
    return chartArea;
}
function getDatasetClipArea(chart, meta) {
    const clip = meta._clip;
    if (clip.disabled) {
        return false;
    }
    const area = getDatasetArea(meta, chart.chartArea);
    return {
        left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),
        right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),
        top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),
        bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)
    };
}

/*!
 * Chart.js v4.4.9
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */

class Animator {
    constructor(){
        this._request = null;
        this._charts = new Map();
        this._running = false;
        this._lastDate = undefined;
    }
 _notify(chart, anims, date, type) {
        const callbacks = anims.listeners[type];
        const numSteps = anims.duration;
        callbacks.forEach((fn)=>fn({
                chart,
                initial: anims.initial,
                numSteps,
                currentStep: Math.min(date - anims.start, numSteps)
            }));
    }
 _refresh() {
        if (this._request) {
            return;
        }
        this._running = true;
        this._request = requestAnimFrame.call(window, ()=>{
            this._update();
            this._request = null;
            if (this._running) {
                this._refresh();
            }
        });
    }
 _update(date = Date.now()) {
        let remaining = 0;
        this._charts.forEach((anims, chart)=>{
            if (!anims.running || !anims.items.length) {
                return;
            }
            const items = anims.items;
            let i = items.length - 1;
            let draw = false;
            let item;
            for(; i >= 0; --i){
                item = items[i];
                if (item._active) {
                    if (item._total > anims.duration) {
                        anims.duration = item._total;
                    }
                    item.tick(date);
                    draw = true;
                } else {
                    items[i] = items[items.length - 1];
                    items.pop();
                }
            }
            if (draw) {
                chart.draw();
                this._notify(chart, anims, date, 'progress');
            }
            if (!items.length) {
                anims.running = false;
                this._notify(chart, anims, date, 'complete');
                anims.initial = false;
            }
            remaining += items.length;
        });
        this._lastDate = date;
        if (remaining === 0) {
            this._running = false;
        }
    }
 _getAnims(chart) {
        const charts = this._charts;
        let anims = charts.get(chart);
        if (!anims) {
            anims = {
                running: false,
                initial: true,
                items: [],
                listeners: {
                    complete: [],
                    progress: []
                }
            };
            charts.set(chart, anims);
        }
        return anims;
    }
 listen(chart, event, cb) {
        this._getAnims(chart).listeners[event].push(cb);
    }
 add(chart, items) {
        if (!items || !items.length) {
            return;
        }
        this._getAnims(chart).items.push(...items);
    }
 has(chart) {
        return this._getAnims(chart).items.length > 0;
    }
 start(chart) {
        const anims = this._charts.get(chart);
        if (!anims) {
            return;
        }
        anims.running = true;
        anims.start = Date.now();
        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);
        this._refresh();
    }
    running(chart) {
        if (!this._running) {
            return false;
        }
        const anims = this._charts.get(chart);
        if (!anims || !anims.running || !anims.items.length) {
            return false;
        }
        return true;
    }
 stop(chart) {
        const anims = this._charts.get(chart);
        if (!anims || !anims.items.length) {
            return;
        }
        const items = anims.items;
        let i = items.length - 1;
        for(; i >= 0; --i){
            items[i].cancel();
        }
        anims.items = [];
        this._notify(chart, anims, Date.now(), 'complete');
    }
 remove(chart) {
        return this._charts.delete(chart);
    }
}
var animator = /* #__PURE__ */ new Animator();

const transparent = 'transparent';
const interpolators = {
    boolean (from, to, factor) {
        return factor > 0.5 ? to : from;
    },
 color (from, to, factor) {
        const c0 = color(from || transparent);
        const c1 = c0.valid && color(to || transparent);
        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
    },
    number (from, to, factor) {
        return from + (to - from) * factor;
    }
};
class Animation {
    constructor(cfg, target, prop, to){
        const currentValue = target[prop];
        to = resolve([
            cfg.to,
            to,
            currentValue,
            cfg.from
        ]);
        const from = resolve([
            cfg.from,
            currentValue,
            to
        ]);
        this._active = true;
        this._fn = cfg.fn || interpolators[cfg.type || typeof from];
        this._easing = effects[cfg.easing] || effects.linear;
        this._start = Math.floor(Date.now() + (cfg.delay || 0));
        this._duration = this._total = Math.floor(cfg.duration);
        this._loop = !!cfg.loop;
        this._target = target;
        this._prop = prop;
        this._from = from;
        this._to = to;
        this._promises = undefined;
    }
    active() {
        return this._active;
    }
    update(cfg, to, date) {
        if (this._active) {
            this._notify(false);
            const currentValue = this._target[this._prop];
            const elapsed = date - this._start;
            const remain = this._duration - elapsed;
            this._start = date;
            this._duration = Math.floor(Math.max(remain, cfg.duration));
            this._total += elapsed;
            this._loop = !!cfg.loop;
            this._to = resolve([
                cfg.to,
                to,
                currentValue,
                cfg.from
            ]);
            this._from = resolve([
                cfg.from,
                currentValue,
                to
            ]);
        }
    }
    cancel() {
        if (this._active) {
            this.tick(Date.now());
            this._active = false;
            this._notify(false);
        }
    }
    tick(date) {
        const elapsed = date - this._start;
        const duration = this._duration;
        const prop = this._prop;
        const from = this._from;
        const loop = this._loop;
        const to = this._to;
        let factor;
        this._active = from !== to && (loop || elapsed < duration);
        if (!this._active) {
            this._target[prop] = to;
            this._notify(true);
            return;
        }
        if (elapsed < 0) {
            this._target[prop] = from;
            return;
        }
        factor = elapsed / duration % 2;
        factor = loop && factor > 1 ? 2 - factor : factor;
        factor = this._easing(Math.min(1, Math.max(0, factor)));
        this._target[prop] = this._fn(from, to, factor);
    }
    wait() {
        const promises = this._promises || (this._promises = []);
        return new Promise((res, rej)=>{
            promises.push({
                res,
                rej
            });
        });
    }
    _notify(resolved) {
        const method = resolved ? 'res' : 'rej';
        const promises = this._promises || [];
        for(let i = 0; i < promises.length; i++){
            promises[i][method]();
        }
    }
}

class Animations {
    constructor(chart, config){
        this._chart = chart;
        this._properties = new Map();
        this.configure(config);
    }
    configure(config) {
        if (!isObject(config)) {
            return;
        }
        const animationOptions = Object.keys(defaults.animation);
        const animatedProps = this._properties;
        Object.getOwnPropertyNames(config).forEach((key)=>{
            const cfg = config[key];
            if (!isObject(cfg)) {
                return;
            }
            const resolved = {};
            for (const option of animationOptions){
                resolved[option] = cfg[option];
            }
            (isArray(cfg.properties) && cfg.properties || [
                key
            ]).forEach((prop)=>{
                if (prop === key || !animatedProps.has(prop)) {
                    animatedProps.set(prop, resolved);
                }
            });
        });
    }
 _animateOptions(target, values) {
        const newOptions = values.options;
        const options = resolveTargetOptions(target, newOptions);
        if (!options) {
            return [];
        }
        const animations = this._createAnimations(options, newOptions);
        if (newOptions.$shared) {
            awaitAll(target.options.$animations, newOptions).then(()=>{
                target.options = newOptions;
            }, ()=>{
            });
        }
        return animations;
    }
 _createAnimations(target, values) {
        const animatedProps = this._properties;
        const animations = [];
        const running = target.$animations || (target.$animations = {});
        const props = Object.keys(values);
        const date = Date.now();
        let i;
        for(i = props.length - 1; i >= 0; --i){
            const prop = props[i];
            if (prop.charAt(0) === '$') {
                continue;
            }
            if (prop === 'options') {
                animations.push(...this._animateOptions(target, values));
                continue;
            }
            const value = values[prop];
            let animation = running[prop];
            const cfg = animatedProps.get(prop);
            if (animation) {
                if (cfg && animation.active()) {
                    animation.update(cfg, value, date);
                    continue;
                } else {
                    animation.cancel();
                }
            }
            if (!cfg || !cfg.duration) {
                target[prop] = value;
                continue;
            }
            running[prop] = animation = new Animation(cfg, target, prop, value);
            animations.push(animation);
        }
        return animations;
    }
 update(target, values) {
        if (this._properties.size === 0) {
            Object.assign(target, values);
            return;
        }
        const animations = this._createAnimations(target, values);
        if (animations.length) {
            animator.add(this._chart, animations);
            return true;
        }
    }
}
function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for(let i = 0; i < keys.length; i++){
        const anim = animations[keys[i]];
        if (anim && anim.active()) {
            running.push(anim.wait());
        }
    }
    return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
        return;
    }
    let options = target.options;
    if (!options) {
        target.options = newOptions;
        return;
    }
    if (options.$shared) {
        target.options = options = Object.assign({}, options, {
            $shared: false,
            $animations: {}
        });
    }
    return options;
}

function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min = opts.min === undefined ? allowedOverflow : 0;
    const max = opts.max === undefined ? allowedOverflow : 0;
    return {
        start: reverse ? max : min,
        end: reverse ? min : max
    };
}
function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
        return false;
    }
    const x = scaleClip(xScale, allowedOverflow);
    const y = scaleClip(yScale, allowedOverflow);
    return {
        top: y.end,
        right: x.end,
        bottom: y.start,
        left: x.start
    };
}
function toClip(value) {
    let t, r, b, l;
    if (isObject(value)) {
        t = value.top;
        r = value.right;
        b = value.bottom;
        l = value.left;
    } else {
        t = r = b = l = value;
    }
    return {
        top: t,
        right: r,
        bottom: b,
        left: l,
        disabled: value === false
    };
}
function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i, ilen;
    for(i = 0, ilen = metasets.length; i < ilen; ++i){
        keys.push(metasets[i].index);
    }
    return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === 'single';
    let i, ilen, datasetIndex, otherValue;
    if (value === null) {
        return;
    }
    let found = false;
    for(i = 0, ilen = keys.length; i < ilen; ++i){
        datasetIndex = +keys[i];
        if (datasetIndex === dsIndex) {
            found = true;
            if (options.all) {
                continue;
            }
            break;
        }
        otherValue = stack.values[datasetIndex];
        if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
            value += otherValue;
        }
    }
    if (!found && !options.all) {
        return 0;
    }
    return value;
}
function convertObjectDataToArray(data, meta) {
    const { iScale , vScale  } = meta;
    const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';
    const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i, ilen, key;
    for(i = 0, ilen = keys.length; i < ilen; ++i){
        key = keys[i];
        adata[i] = {
            [iAxisKey]: key,
            [vAxisKey]: data[key]
        };
    }
    return adata;
}
function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === undefined && meta.stack !== undefined;
}
function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
    const { min , max , minDefined , maxDefined  } = scale.getUserBounds();
    return {
        min: minDefined ? min : Number.NEGATIVE_INFINITY,
        max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){
        const value = stack[meta.index];
        if (positive && value > 0 || !positive && value < 0) {
            return meta.index;
        }
    }
    return null;
}
function updateStacks(controller, parsed) {
    const { chart , _cachedMeta: meta  } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale , vScale , index: datasetIndex  } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for(let i = 0; i < ilen; ++i){
        const item = parsed[i];
        const { [iAxis]: index , [vAxis]: value  } = item;
        const itemStacks = item._stacks || (item._stacks = {});
        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
        stack[datasetIndex] = value;
        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
        const visualValues = stack._visualValues || (stack._visualValues = {});
        visualValues[datasetIndex] = value;
    }
}
function getFirstScaleId(chart, axis) {
    const scales = chart.scales;
    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
    return createContext(parent, {
        active: false,
        dataset: undefined,
        datasetIndex: index,
        index,
        mode: 'default',
        type: 'dataset'
    });
}
function createDataContext(parent, index, element) {
    return createContext(parent, {
        active: false,
        dataIndex: index,
        parsed: undefined,
        raw: undefined,
        element,
        index,
        mode: 'default',
        type: 'data'
    });
}
function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
        return;
    }
    items = items || meta._parsed;
    for (const parsed of items){
        const stacks = parsed._stacks;
        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
            return;
        }
        delete stacks[axis][datasetIndex];
        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {
            delete stacks[axis]._visualValues[datasetIndex];
        }
    }
}
const isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';
const cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {
        keys: getSortedDatasetIndices(chart, true),
        values: null
    };
class DatasetController {
 static defaults = {};
 static datasetElementType = null;
 static dataElementType = null;
 constructor(chart, datasetIndex){
        this.chart = chart;
        this._ctx = chart.ctx;
        this.index = datasetIndex;
        this._cachedDataOpts = {};
        this._cachedMeta = this.getMeta();
        this._type = this._cachedMeta.type;
        this.options = undefined;
         this._parsing = false;
        this._data = undefined;
        this._objectData = undefined;
        this._sharedOptions = undefined;
        this._drawStart = undefined;
        this._drawCount = undefined;
        this.enableOptionSharing = false;
        this.supportsDecimation = false;
        this.$context = undefined;
        this._syncList = [];
        this.datasetElementType = new.target.datasetElementType;
        this.dataElementType = new.target.dataElementType;
        this.initialize();
    }
    initialize() {
        const meta = this._cachedMeta;
        this.configure();
        this.linkScales();
        meta._stacked = isStacked(meta.vScale, meta);
        this.addElements();
        if (this.options.fill && !this.chart.isPluginEnabled('filler')) {
            console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
        }
    }
    updateIndex(datasetIndex) {
        if (this.index !== datasetIndex) {
            clearStacks(this._cachedMeta);
        }
        this.index = datasetIndex;
    }
    linkScales() {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;
        const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));
        const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));
        const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));
        const indexAxis = meta.indexAxis;
        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
        meta.xScale = this.getScaleForId(xid);
        meta.yScale = this.getScaleForId(yid);
        meta.rScale = this.getScaleForId(rid);
        meta.iScale = this.getScaleForId(iid);
        meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
        return this.chart.data.datasets[this.index];
    }
    getMeta() {
        return this.chart.getDatasetMeta(this.index);
    }
 getScaleForId(scaleID) {
        return this.chart.scales[scaleID];
    }
 _getOtherScale(scale) {
        const meta = this._cachedMeta;
        return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
        this._update('reset');
    }
 _destroy() {
        const meta = this._cachedMeta;
        if (this._data) {
            unlistenArrayEvents(this._data, this);
        }
        if (meta._stacked) {
            clearStacks(meta);
        }
    }
 _dataCheck() {
        const dataset = this.getDataset();
        const data = dataset.data || (dataset.data = []);
        const _data = this._data;
        if (isObject(data)) {
            const meta = this._cachedMeta;
            this._data = convertObjectDataToArray(data, meta);
        } else if (_data !== data) {
            if (_data) {
                unlistenArrayEvents(_data, this);
                const meta = this._cachedMeta;
                clearStacks(meta);
                meta._parsed = [];
            }
            if (data && Object.isExtensible(data)) {
                listenArrayEvents(data, this);
            }
            this._syncList = [];
            this._data = data;
        }
    }
    addElements() {
        const meta = this._cachedMeta;
        this._dataCheck();
        if (this.datasetElementType) {
            meta.dataset = new this.datasetElementType();
        }
    }
    buildOrUpdateElements(resetNewElements) {
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        let stackChanged = false;
        this._dataCheck();
        const oldStacked = meta._stacked;
        meta._stacked = isStacked(meta.vScale, meta);
        if (meta.stack !== dataset.stack) {
            stackChanged = true;
            clearStacks(meta);
            meta.stack = dataset.stack;
        }
        this._resyncElements(resetNewElements);
        if (stackChanged || oldStacked !== meta._stacked) {
            updateStacks(this, meta._parsed);
            meta._stacked = isStacked(meta.vScale, meta);
        }
    }
 configure() {
        const config = this.chart.config;
        const scopeKeys = config.datasetScopeKeys(this._type);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
        this.options = config.createResolver(scopes, this.getContext());
        this._parsing = this.options.parsing;
        this._cachedDataOpts = {};
    }
 parse(start, count) {
        const { _cachedMeta: meta , _data: data  } = this;
        const { iScale , _stacked  } = meta;
        const iAxis = iScale.axis;
        let sorted = start === 0 && count === data.length ? true : meta._sorted;
        let prev = start > 0 && meta._parsed[start - 1];
        let i, cur, parsed;
        if (this._parsing === false) {
            meta._parsed = data;
            meta._sorted = true;
            parsed = data;
        } else {
            if (isArray(data[start])) {
                parsed = this.parseArrayData(meta, data, start, count);
            } else if (isObject(data[start])) {
                parsed = this.parseObjectData(meta, data, start, count);
            } else {
                parsed = this.parsePrimitiveData(meta, data, start, count);
            }
            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
            for(i = 0; i < count; ++i){
                meta._parsed[i + start] = cur = parsed[i];
                if (sorted) {
                    if (isNotInOrderComparedToPrev()) {
                        sorted = false;
                    }
                    prev = cur;
                }
            }
            meta._sorted = sorted;
        }
        if (_stacked) {
            updateStacks(this, parsed);
        }
    }
 parsePrimitiveData(meta, data, start, count) {
        const { iScale , vScale  } = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = new Array(count);
        let i, ilen, index;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            parsed[i] = {
                [iAxis]: singleScale || iScale.parse(labels[index], index),
                [vAxis]: vScale.parse(data[index], index)
            };
        }
        return parsed;
    }
 parseArrayData(meta, data, start, count) {
        const { xScale , yScale  } = meta;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            item = data[index];
            parsed[i] = {
                x: xScale.parse(item[0], index),
                y: yScale.parse(item[1], index)
            };
        }
        return parsed;
    }
 parseObjectData(meta, data, start, count) {
        const { xScale , yScale  } = meta;
        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            item = data[index];
            parsed[i] = {
                x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
                y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
            };
        }
        return parsed;
    }
 getParsed(index) {
        return this._cachedMeta._parsed[index];
    }
 getDataElement(index) {
        return this._cachedMeta.data[index];
    }
 applyStack(scale, parsed, mode) {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const value = parsed[scale.axis];
        const stack = {
            keys: getSortedDatasetIndices(chart, true),
            values: parsed._stacks[scale.axis]._visualValues
        };
        return applyStack(stack, value, meta.index, {
            mode
        });
    }
 updateRangeFromParsed(range, scale, parsed, stack) {
        const parsedValue = parsed[scale.axis];
        let value = parsedValue === null ? NaN : parsedValue;
        const values = stack && parsed._stacks[scale.axis];
        if (stack && values) {
            stack.values = values;
            value = applyStack(stack, parsedValue, this._cachedMeta.index);
        }
        range.min = Math.min(range.min, value);
        range.max = Math.max(range.max, value);
    }
 getMinMax(scale, canStack) {
        const meta = this._cachedMeta;
        const _parsed = meta._parsed;
        const sorted = meta._sorted && scale === meta.iScale;
        const ilen = _parsed.length;
        const otherScale = this._getOtherScale(scale);
        const stack = createStack(canStack, meta, this.chart);
        const range = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        };
        const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);
        let i, parsed;
        function _skip() {
            parsed = _parsed[i];
            const otherValue = parsed[otherScale.axis];
            return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
        }
        for(i = 0; i < ilen; ++i){
            if (_skip()) {
                continue;
            }
            this.updateRangeFromParsed(range, scale, parsed, stack);
            if (sorted) {
                break;
            }
        }
        if (sorted) {
            for(i = ilen - 1; i >= 0; --i){
                if (_skip()) {
                    continue;
                }
                this.updateRangeFromParsed(range, scale, parsed, stack);
                break;
            }
        }
        return range;
    }
    getAllParsedValues(scale) {
        const parsed = this._cachedMeta._parsed;
        const values = [];
        let i, ilen, value;
        for(i = 0, ilen = parsed.length; i < ilen; ++i){
            value = parsed[i][scale.axis];
            if (isNumberFinite(value)) {
                values.push(value);
            }
        }
        return values;
    }
 getMaxOverflow() {
        return false;
    }
 getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const parsed = this.getParsed(index);
        return {
            label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
            value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
        };
    }
 _update(mode) {
        const meta = this._cachedMeta;
        this.update(mode || 'default');
        meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
 update(mode) {}
    draw() {
        const ctx = this._ctx;
        const chart = this.chart;
        const meta = this._cachedMeta;
        const elements = meta.data || [];
        const area = chart.chartArea;
        const active = [];
        const start = this._drawStart || 0;
        const count = this._drawCount || elements.length - start;
        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
        let i;
        if (meta.dataset) {
            meta.dataset.draw(ctx, area, start, count);
        }
        for(i = start; i < start + count; ++i){
            const element = elements[i];
            if (element.hidden) {
                continue;
            }
            if (element.active && drawActiveElementsOnTop) {
                active.push(element);
            } else {
                element.draw(ctx, area);
            }
        }
        for(i = 0; i < active.length; ++i){
            active[i].draw(ctx, area);
        }
    }
 getStyle(index, active) {
        const mode = active ? 'active' : 'default';
        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
    }
 getContext(index, active, mode) {
        const dataset = this.getDataset();
        let context;
        if (index >= 0 && index < this._cachedMeta.data.length) {
            const element = this._cachedMeta.data[index];
            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
            context.parsed = this.getParsed(index);
            context.raw = dataset.data[index];
            context.index = context.dataIndex = index;
        } else {
            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
            context.dataset = dataset;
            context.index = context.datasetIndex = this.index;
        }
        context.active = !!active;
        context.mode = mode;
        return context;
    }
 resolveDatasetElementOptions(mode) {
        return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
 resolveDataElementOptions(index, mode) {
        return this._resolveElementOptions(this.dataElementType.id, mode, index);
    }
 _resolveElementOptions(elementType, mode = 'default', index) {
        const active = mode === 'active';
        const cache = this._cachedDataOpts;
        const cacheKey = elementType + '-' + mode;
        const cached = cache[cacheKey];
        const sharing = this.enableOptionSharing && defined(index);
        if (cached) {
            return cloneIfNotShared(cached, sharing);
        }
        const config = this.chart.config;
        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
        const prefixes = active ? [
            `${elementType}Hover`,
            'hover',
            elementType,
            ''
        ] : [
            elementType,
            ''
        ];
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        const names = Object.keys(defaults.elements[elementType]);
        const context = ()=>this.getContext(index, active, mode);
        const values = config.resolveNamedOptions(scopes, names, context, prefixes);
        if (values.$shared) {
            values.$shared = sharing;
            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
        }
        return values;
    }
 _resolveAnimations(index, transition, active) {
        const chart = this.chart;
        const cache = this._cachedDataOpts;
        const cacheKey = `animation-${transition}`;
        const cached = cache[cacheKey];
        if (cached) {
            return cached;
        }
        let options;
        if (chart.options.animation !== false) {
            const config = this.chart.config;
            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            options = config.createResolver(scopes, this.getContext(index, active, transition));
        }
        const animations = new Animations(chart, options && options.animations);
        if (options && options._cacheable) {
            cache[cacheKey] = Object.freeze(animations);
        }
        return animations;
    }
 getSharedOptions(options) {
        if (!options.$shared) {
            return;
        }
        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
 includeOptions(mode, sharedOptions) {
        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
 _getSharedOptions(start, mode) {
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const previouslySharedOptions = this._sharedOptions;
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
        return {
            sharedOptions,
            includeOptions
        };
    }
 updateElement(element, index, properties, mode) {
        if (isDirectUpdateMode(mode)) {
            Object.assign(element, properties);
        } else {
            this._resolveAnimations(index, mode).update(element, properties);
        }
    }
 updateSharedOptions(sharedOptions, mode, newOptions) {
        if (sharedOptions && !isDirectUpdateMode(mode)) {
            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
        }
    }
 _setStyle(element, index, mode, active) {
        element.active = active;
        const options = this.getStyle(index, active);
        this._resolveAnimations(index, mode, active).update(element, {
            options: !active && this.getSharedOptions(options) || options
        });
    }
    removeHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, 'active', false);
    }
    setHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, 'active', true);
    }
 _removeDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
            this._setStyle(element, undefined, 'active', false);
        }
    }
 _setDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
            this._setStyle(element, undefined, 'active', true);
        }
    }
 _resyncElements(resetNewElements) {
        const data = this._data;
        const elements = this._cachedMeta.data;
        for (const [method, arg1, arg2] of this._syncList){
            this[method](arg1, arg2);
        }
        this._syncList = [];
        const numMeta = elements.length;
        const numData = data.length;
        const count = Math.min(numData, numMeta);
        if (count) {
            this.parse(0, count);
        }
        if (numData > numMeta) {
            this._insertElements(numMeta, numData - numMeta, resetNewElements);
        } else if (numData < numMeta) {
            this._removeElements(numData, numMeta - numData);
        }
    }
 _insertElements(start, count, resetNewElements = true) {
        const meta = this._cachedMeta;
        const data = meta.data;
        const end = start + count;
        let i;
        const move = (arr)=>{
            arr.length += count;
            for(i = arr.length - 1; i >= end; i--){
                arr[i] = arr[i - count];
            }
        };
        move(data);
        for(i = start; i < end; ++i){
            data[i] = new this.dataElementType();
        }
        if (this._parsing) {
            move(meta._parsed);
        }
        this.parse(start, count);
        if (resetNewElements) {
            this.updateElements(data, start, count, 'reset');
        }
    }
    updateElements(element, start, count, mode) {}
 _removeElements(start, count) {
        const meta = this._cachedMeta;
        if (this._parsing) {
            const removed = meta._parsed.splice(start, count);
            if (meta._stacked) {
                clearStacks(meta, removed);
            }
        }
        meta.data.splice(start, count);
    }
 _sync(args) {
        if (this._parsing) {
            this._syncList.push(args);
        } else {
            const [method, arg1, arg2] = args;
            this[method](arg1, arg2);
        }
        this.chart._dataChanges.push([
            this.index,
            ...args
        ]);
    }
    _onDataPush() {
        const count = arguments.length;
        this._sync([
            '_insertElements',
            this.getDataset().data.length - count,
            count
        ]);
    }
    _onDataPop() {
        this._sync([
            '_removeElements',
            this._cachedMeta.data.length - 1,
            1
        ]);
    }
    _onDataShift() {
        this._sync([
            '_removeElements',
            0,
            1
        ]);
    }
    _onDataSplice(start, count) {
        if (count) {
            this._sync([
                '_removeElements',
                start,
                count
            ]);
        }
        const newCount = arguments.length - 2;
        if (newCount) {
            this._sync([
                '_insertElements',
                start,
                newCount
            ]);
        }
    }
    _onDataUnshift() {
        this._sync([
            '_insertElements',
            0,
            arguments.length
        ]);
    }
}

function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
        const visibleMetas = scale.getMatchingVisibleMetas(type);
        let values = [];
        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){
            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
        }
        scale._cache.$bar = _arrayUnique(values.sort((a, b)=>a - b));
    }
    return scale._cache.$bar;
}
 function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min = scale._length;
    let i, ilen, curr, prev;
    const updateMinAndPrev = ()=>{
        if (curr === 32767 || curr === -32768) {
            return;
        }
        if (defined(prev)) {
            min = Math.min(min, Math.abs(curr - prev) || min);
        }
        prev = curr;
    };
    for(i = 0, ilen = values.length; i < ilen; ++i){
        curr = scale.getPixelForValue(values[i]);
        updateMinAndPrev();
    }
    prev = undefined;
    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){
        curr = scale.getPixelForTick(i);
        updateMinAndPrev();
    }
    return min;
}
 function computeFitCategoryTraits(index, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if (isNullOrUndef(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
    } else {
        size = thickness * stackCount;
        ratio = 1;
    }
    return {
        chunk: size / stackCount,
        ratio,
        start: ruler.pixels[index] - size / 2
    };
}
 function computeFlexCategoryTraits(index, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index];
    let prev = index > 0 ? pixels[index - 1] : null;
    let next = index < pixels.length - 1 ? pixels[index + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
        next = curr + curr - prev;
    }
    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
        chunk: size / stackCount,
        ratio: options.barPercentage,
        start
    };
}
function parseFloatBar(entry, item, vScale, i) {
    const startValue = vScale.parse(entry[0], i);
    const endValue = vScale.parse(entry[1], i);
    const min = Math.min(startValue, endValue);
    const max = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
        barStart = max;
        barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
        barStart,
        barEnd,
        start: startValue,
        end: endValue,
        min,
        max
    };
}
function parseValue(entry, item, vScale, i) {
    if (isArray(entry)) {
        parseFloatBar(entry, item, vScale, i);
    } else {
        item[vScale.axis] = vScale.parse(entry, i);
    }
    return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i, ilen, item, entry;
    for(i = start, ilen = start + count; i < ilen; ++i){
        entry = data[i];
        item = {};
        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
        parsed.push(parseValue(entry, item, vScale, i));
    }
    return parsed;
}
function isFloatBar(custom) {
    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
}
function barSign(size, vScale, actualBase) {
    if (size !== 0) {
        return sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
    let reverse, start, end, top, bottom;
    if (properties.horizontal) {
        reverse = properties.base > properties.x;
        start = 'left';
        end = 'right';
    } else {
        reverse = properties.base < properties.y;
        start = 'bottom';
        end = 'top';
    }
    if (reverse) {
        top = 'end';
        bottom = 'start';
    } else {
        top = 'start';
        bottom = 'end';
    }
    return {
        start,
        end,
        reverse,
        top,
        bottom
    };
}
function setBorderSkipped(properties, options, stack, index) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
        properties.borderSkipped = res;
        return;
    }
    if (edge === true) {
        properties.borderSkipped = {
            top: true,
            right: true,
            bottom: true,
            left: true
        };
        return;
    }
    const { start , end , reverse , top , bottom  } = borderProps(properties);
    if (edge === 'middle' && stack) {
        properties.enableBorderRadius = true;
        if ((stack._top || 0) === index) {
            edge = top;
        } else if ((stack._bottom || 0) === index) {
            edge = bottom;
        } else {
            res[parseEdge(bottom, start, end, reverse)] = true;
            edge = top;
        }
    }
    res[parseEdge(edge, start, end, reverse)] = true;
    properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
    if (reverse) {
        edge = swap(edge, a, b);
        edge = startEnd(edge, b, a);
    } else {
        edge = startEnd(edge, a, b);
    }
    return edge;
}
function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
    return v === 'start' ? start : v === 'end' ? end : v;
}
function setInflateAmount(properties, { inflateAmount  }, ratio) {
    properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
class BarController extends DatasetController {
    static id = 'bar';
 static defaults = {
        datasetElementType: false,
        dataElementType: 'bar',
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        grouped: true,
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'base',
                    'width',
                    'height'
                ]
            }
        }
    };
 static overrides = {
        scales: {
            _index_: {
                type: 'category',
                offset: true,
                grid: {
                    offset: true
                }
            },
            _value_: {
                type: 'linear',
                beginAtZero: true
            }
        }
    };
 parsePrimitiveData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
    }
 parseArrayData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
    }
 parseObjectData(meta, data, start, count) {
        const { iScale , vScale  } = meta;
        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
        const parsed = [];
        let i, ilen, item, obj;
        for(i = start, ilen = start + count; i < ilen; ++i){
            obj = data[i];
            item = {};
            item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
            parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
        }
        return parsed;
    }
 updateRangeFromParsed(range, scale, parsed, stack) {
        super.updateRangeFromParsed(range, scale, parsed, stack);
        const custom = parsed._custom;
        if (custom && scale === this._cachedMeta.vScale) {
            range.min = Math.min(range.min, custom.min);
            range.max = Math.max(range.max, custom.max);
        }
    }
 getMaxOverflow() {
        return 0;
    }
 getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const { iScale , vScale  } = meta;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);
        return {
            label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
            value
        };
    }
    initialize() {
        this.enableOptionSharing = true;
        super.initialize();
        const meta = this._cachedMeta;
        meta.stack = this.getDataset().stack;
    }
    update(mode) {
        const meta = this._cachedMeta;
        this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start, count, mode) {
        const reset = mode === 'reset';
        const { index , _cachedMeta: { vScale  }  } = this;
        const base = vScale.getBasePixel();
        const horizontal = vScale.isHorizontal();
        const ruler = this._getRuler();
        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
        for(let i = start; i < start + count; i++){
            const parsed = this.getParsed(i);
            const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
                base,
                head: base
            } : this._calculateBarValuePixels(i);
            const ipixels = this._calculateBarIndexPixels(i, ruler);
            const stack = (parsed._stacks || {})[vScale.axis];
            const properties = {
                horizontal,
                base: vpixels.base,
                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
                x: horizontal ? vpixels.head : ipixels.center,
                y: horizontal ? ipixels.center : vpixels.head,
                height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                width: horizontal ? Math.abs(vpixels.size) : ipixels.size
            };
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
            }
            const options = properties.options || bars[i].options;
            setBorderSkipped(properties, options, stack, index);
            setInflateAmount(properties, options, ruler.ratio);
            this.updateElement(bars[i], i, properties, mode);
        }
    }
 _getStacks(last, dataIndex) {
        const { iScale  } = this._cachedMeta;
        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);
        const stacked = iScale.options.stacked;
        const stacks = [];
        const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
        const iScaleValue = currentParsed && currentParsed[iScale.axis];
        const skipNull = (meta)=>{
            const parsed = meta._parsed.find((item)=>item[iScale.axis] === iScaleValue);
            const val = parsed && parsed[meta.vScale.axis];
            if (isNullOrUndef(val) || isNaN(val)) {
                return true;
            }
        };
        for (const meta of metasets){
            if (dataIndex !== undefined && skipNull(meta)) {
                continue;
            }
            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {
                stacks.push(meta.stack);
            }
            if (meta.index === last) {
                break;
            }
        }
        if (!stacks.length) {
            stacks.push(undefined);
        }
        return stacks;
    }
 _getStackCount(index) {
        return this._getStacks(undefined, index).length;
    }
 _getStackIndex(datasetIndex, name, dataIndex) {
        const stacks = this._getStacks(datasetIndex, dataIndex);
        const index = name !== undefined ? stacks.indexOf(name) : -1;
        return index === -1 ? stacks.length - 1 : index;
    }
 _getRuler() {
        const opts = this.options;
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const pixels = [];
        let i, ilen;
        for(i = 0, ilen = meta.data.length; i < ilen; ++i){
            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
        }
        const barThickness = opts.barThickness;
        const min = barThickness || computeMinSampleSize(meta);
        return {
            min,
            pixels,
            start: iScale._startPixel,
            end: iScale._endPixel,
            stackCount: this._getStackCount(),
            scale: iScale,
            grouped: opts.grouped,
            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
        };
    }
 _calculateBarValuePixels(index) {
        const { _cachedMeta: { vScale , _stacked , index: datasetIndex  } , options: { base: baseValue , minBarLength  }  } = this;
        const actualBase = baseValue || 0;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const floating = isFloatBar(custom);
        let value = parsed[vScale.axis];
        let start = 0;
        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
        let head, size;
        if (length !== value) {
            start = length - value;
            length = value;
        }
        if (floating) {
            value = custom.barStart;
            length = custom.barEnd - custom.barStart;
            if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
                start = 0;
            }
            start += value;
        }
        const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
        let base = vScale.getPixelForValue(startValue);
        if (this.chart.getDataVisibility(index)) {
            head = vScale.getPixelForValue(start + length);
        } else {
            head = base;
        }
        size = head - base;
        if (Math.abs(size) < minBarLength) {
            size = barSign(size, vScale, actualBase) * minBarLength;
            if (value === actualBase) {
                base -= size / 2;
            }
            const startPixel = vScale.getPixelForDecimal(0);
            const endPixel = vScale.getPixelForDecimal(1);
            const min = Math.min(startPixel, endPixel);
            const max = Math.max(startPixel, endPixel);
            base = Math.max(Math.min(base, max), min);
            head = base + size;
            if (_stacked && !floating) {
                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
            }
        }
        if (base === vScale.getPixelForValue(actualBase)) {
            const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
            base += halfGrid;
            size -= halfGrid;
        }
        return {
            size,
            base,
            head,
            center: head + size / 2
        };
    }
 _calculateBarIndexPixels(index, ruler) {
        const scale = ruler.scale;
        const options = this.options;
        const skipNull = options.skipNull;
        const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
        let center, size;
        if (ruler.grouped) {
            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
            const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);
            center = range.start + range.chunk * stackIndex + range.chunk / 2;
            size = Math.min(maxBarThickness, range.chunk * range.ratio);
        } else {
            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
        }
        return {
            base: center - size / 2,
            head: center + size / 2,
            center,
            size
        };
    }
    draw() {
        const meta = this._cachedMeta;
        const vScale = meta.vScale;
        const rects = meta.data;
        const ilen = rects.length;
        let i = 0;
        for(; i < ilen; ++i){
            if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
                rects[i].draw(this._ctx);
            }
        }
    }
}

class BubbleController extends DatasetController {
    static id = 'bubble';
 static defaults = {
        datasetElementType: false,
        dataElementType: 'point',
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'borderWidth',
                    'radius'
                ]
            }
        }
    };
 static overrides = {
        scales: {
            x: {
                type: 'linear'
            },
            y: {
                type: 'linear'
            }
        }
    };
    initialize() {
        this.enableOptionSharing = true;
        super.initialize();
    }
 parsePrimitiveData(meta, data, start, count) {
        const parsed = super.parsePrimitiveData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++){
            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
        }
        return parsed;
    }
 parseArrayData(meta, data, start, count) {
        const parsed = super.parseArrayData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++){
            const item = data[start + i];
            parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
    }
 parseObjectData(meta, data, start, count) {
        const parsed = super.parseObjectData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++){
            const item = data[start + i];
            parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
    }
 getMaxOverflow() {
        const data = this._cachedMeta.data;
        let max = 0;
        for(let i = data.length - 1; i >= 0; --i){
            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
        }
        return max > 0 && max;
    }
 getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const labels = this.chart.data.labels || [];
        const { xScale , yScale  } = meta;
        const parsed = this.getParsed(index);
        const x = xScale.getLabelForValue(parsed.x);
        const y = yScale.getLabelForValue(parsed.y);
        const r = parsed._custom;
        return {
            label: labels[index] || '',
            value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'
        };
    }
    update(mode) {
        const points = this._cachedMeta.data;
        this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
        const reset = mode === 'reset';
        const { iScale , vScale  } = this._cachedMeta;
        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        for(let i = start; i < start + count; i++){
            const point = points[i];
            const parsed = !reset && this.getParsed(i);
            const properties = {};
            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
            properties.skip = isNaN(iPixel) || isNaN(vPixel);
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
                if (reset) {
                    properties.options.radius = 0;
                }
            }
            this.updateElement(point, i, properties, mode);
        }
    }
 resolveDataElementOptions(index, mode) {
        const parsed = this.getParsed(index);
        let values = super.resolveDataElementOptions(index, mode);
        if (values.$shared) {
            values = Object.assign({}, values, {
                $shared: false
            });
        }
        const radius = values.radius;
        if (mode !== 'active') {
            values.radius = 0;
        }
        values.radius += valueOrDefault(parsed && parsed._custom, radius);
        return values;
    }
}

function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
        const startAngle = rotation;
        const endAngle = startAngle + circumference;
        const startX = Math.cos(startAngle);
        const startY = Math.sin(startAngle);
        const endX = Math.cos(endAngle);
        const endY = Math.sin(endAngle);
        const calcMax = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
        const calcMin = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
        const maxX = calcMax(0, startX, endX);
        const maxY = calcMax(HALF_PI, startY, endY);
        const minX = calcMin(PI, startX, endX);
        const minY = calcMin(PI + HALF_PI, startY, endY);
        ratioX = (maxX - minX) / 2;
        ratioY = (maxY - minY) / 2;
        offsetX = -(maxX + minX) / 2;
        offsetY = -(maxY + minY) / 2;
    }
    return {
        ratioX,
        ratioY,
        offsetX,
        offsetY
    };
}
class DoughnutController extends DatasetController {
    static id = 'doughnut';
 static defaults = {
        datasetElementType: false,
        dataElementType: 'arc',
        animation: {
            animateRotate: true,
            animateScale: false
        },
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'circumference',
                    'endAngle',
                    'innerRadius',
                    'outerRadius',
                    'startAngle',
                    'x',
                    'y',
                    'offset',
                    'borderWidth',
                    'spacing'
                ]
            }
        },
        cutout: '50%',
        rotation: 0,
        circumference: 360,
        radius: '100%',
        spacing: 0,
        indexAxis: 'r'
    };
    static descriptors = {
        _scriptable: (name)=>name !== 'spacing',
        _indexable: (name)=>name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash')
    };
 static overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels (chart) {
                        const data = chart.data;
                        if (data.labels.length && data.datasets.length) {
                            const { labels: { pointStyle , color  }  } = chart.legend.options;
                            return data.labels.map((label, i)=>{
                                const meta = chart.getDatasetMeta(0);
                                const style = meta.controller.getStyle(i);
                                return {
                                    text: label,
                                    fillStyle: style.backgroundColor,
                                    strokeStyle: style.borderColor,
                                    fontColor: color,
                                    lineWidth: style.borderWidth,
                                    pointStyle: pointStyle,
                                    hidden: !chart.getDataVisibility(i),
                                    index: i
                                };
                            });
                        }
                        return [];
                    }
                },
                onClick (e, legendItem, legend) {
                    legend.chart.toggleDataVisibility(legendItem.index);
                    legend.chart.update();
                }
            }
        }
    };
    constructor(chart, datasetIndex){
        super(chart, datasetIndex);
        this.enableOptionSharing = true;
        this.innerRadius = undefined;
        this.outerRadius = undefined;
        this.offsetX = undefined;
        this.offsetY = undefined;
    }
    linkScales() {}
 parse(start, count) {
        const data = this.getDataset().data;
        const meta = this._cachedMeta;
        if (this._parsing === false) {
            meta._parsed = data;
        } else {
            let getter = (i)=>+data[i];
            if (isObject(data[start])) {
                const { key ='value'  } = this._parsing;
                getter = (i)=>+resolveObjectKey(data[i], key);
            }
            let i, ilen;
            for(i = start, ilen = start + count; i < ilen; ++i){
                meta._parsed[i] = getter(i);
            }
        }
    }
 _getRotation() {
        return toRadians(this.options.rotation - 90);
    }
 _getCircumference() {
        return toRadians(this.options.circumference);
    }
 _getRotationExtents() {
        let min = TAU;
        let max = -TAU;
        for(let i = 0; i < this.chart.data.datasets.length; ++i){
            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
                const controller = this.chart.getDatasetMeta(i).controller;
                const rotation = controller._getRotation();
                const circumference = controller._getCircumference();
                min = Math.min(min, rotation);
                max = Math.max(max, rotation + circumference);
            }
        }
        return {
            rotation: min,
            circumference: max - min
        };
    }
 update(mode) {
        const chart = this.chart;
        const { chartArea  } = chart;
        const meta = this._cachedMeta;
        const arcs = meta.data;
        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
        const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
        const chartWeight = this._getRingWeight(this.index);
        const { circumference , rotation  } = this._getRotationExtents();
        const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);
        const maxWidth = (chartArea.width - spacing) / ratioX;
        const maxHeight = (chartArea.height - spacing) / ratioY;
        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
        const outerRadius = toDimension(this.options.radius, maxRadius);
        const innerRadius = Math.max(outerRadius * cutout, 0);
        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
        this.offsetX = offsetX * outerRadius;
        this.offsetY = offsetY * outerRadius;
        meta.total = this.calculateTotal();
        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
        this.updateElements(arcs, 0, arcs.length, mode);
    }
 _circumference(i, reset) {
        const opts = this.options;
        const meta = this._cachedMeta;
        const circumference = this._getCircumference();
        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
            return 0;
        }
        return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
    }
    updateElements(arcs, start, count, mode) {
        const reset = mode === 'reset';
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const animationOpts = opts.animation;
        const centerX = (chartArea.left + chartArea.right) / 2;
        const centerY = (chartArea.top + chartArea.bottom) / 2;
        const animateScale = reset && animationOpts.animateScale;
        const innerRadius = animateScale ? 0 : this.innerRadius;
        const outerRadius = animateScale ? 0 : this.outerRadius;
        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
        let startAngle = this._getRotation();
        let i;
        for(i = 0; i < start; ++i){
            startAngle += this._circumference(i, reset);
        }
        for(i = start; i < start + count; ++i){
            const circumference = this._circumference(i, reset);
            const arc = arcs[i];
            const properties = {
                x: centerX + this.offsetX,
                y: centerY + this.offsetY,
                startAngle,
                endAngle: startAngle + circumference,
                circumference,
                outerRadius,
                innerRadius
            };
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);
            }
            startAngle += circumference;
            this.updateElement(arc, i, properties, mode);
        }
    }
    calculateTotal() {
        const meta = this._cachedMeta;
        const metaData = meta.data;
        let total = 0;
        let i;
        for(i = 0; i < metaData.length; i++){
            const value = meta._parsed[i];
            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
                total += Math.abs(value);
            }
        }
        return total;
    }
    calculateCircumference(value) {
        const total = this._cachedMeta.total;
        if (total > 0 && !isNaN(value)) {
            return TAU * (Math.abs(value) / total);
        }
        return 0;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = formatNumber(meta._parsed[index], chart.options.locale);
        return {
            label: labels[index] || '',
            value
        };
    }
    getMaxBorderWidth(arcs) {
        let max = 0;
        const chart = this.chart;
        let i, ilen, meta, controller, options;
        if (!arcs) {
            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){
                if (chart.isDatasetVisible(i)) {
                    meta = chart.getDatasetMeta(i);
                    arcs = meta.data;
                    controller = meta.controller;
                    break;
                }
            }
        }
        if (!arcs) {
            return 0;
        }
        for(i = 0, ilen = arcs.length; i < ilen; ++i){
            options = controller.resolveDataElementOptions(i);
            if (options.borderAlign !== 'inner') {
                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
            }
        }
        return max;
    }
    getMaxOffset(arcs) {
        let max = 0;
        for(let i = 0, ilen = arcs.length; i < ilen; ++i){
            const options = this.resolveDataElementOptions(i);
            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
        }
        return max;
    }
 _getRingWeightOffset(datasetIndex) {
        let ringWeightOffset = 0;
        for(let i = 0; i < datasetIndex; ++i){
            if (this.chart.isDatasetVisible(i)) {
                ringWeightOffset += this._getRingWeight(i);
            }
        }
        return ringWeightOffset;
    }
 _getRingWeight(datasetIndex) {
        return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
 _getVisibleDatasetWeightTotal() {
        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
}

class LineController extends DatasetController {
    static id = 'line';
 static defaults = {
        datasetElementType: 'line',
        dataElementType: 'point',
        showLine: true,
        spanGaps: false
    };
 static overrides = {
        scales: {
            _index_: {
                type: 'category'
            },
            _value_: {
                type: 'linear'
            }
        }
    };
    initialize() {
        this.enableOptionSharing = true;
        this.supportsDecimation = true;
        super.initialize();
    }
    update(mode) {
        const meta = this._cachedMeta;
        const { dataset: line , data: points = [] , _dataset  } = meta;
        const animationsDisabled = this.chart._animationsDisabled;
        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
        this._drawStart = start;
        this._drawCount = count;
        if (_scaleRangesChanged(meta)) {
            start = 0;
            count = points.length;
        }
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
            options.borderWidth = 0;
        }
        options.segment = this.options.segment;
        this.updateElement(line, undefined, {
            animated: !animationsDisabled,
            options
        }, mode);
        this.updateElements(points, start, count, mode);
    }
    updateElements(points, start, count, mode) {
        const reset = mode === 'reset';
        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;
        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const { spanGaps , segment  } = this.options;
        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
        const end = start + count;
        const pointsCount = points.length;
        let prevParsed = start > 0 && this.getParsed(start - 1);
        for(let i = 0; i < pointsCount; ++i){
            const point = points[i];
            const properties = directUpdate ? point : {};
            if (i < start || i >= end) {
                properties.skip = true;
                continue;
            }
            const parsed = this.getParsed(i);
            const nullData = isNullOrUndef(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
            }
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
            }
            if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
            }
            prevParsed = parsed;
        }
    }
 getMaxOverflow() {
        const meta = this._cachedMeta;
        const dataset = meta.dataset;
        const border = dataset.options && dataset.options.borderWidth || 0;
        const data = meta.data || [];
        if (!data.length) {
            return border;
        }
        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
        return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
        const meta = this._cachedMeta;
        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
        super.draw();
    }
}

class PolarAreaController extends DatasetController {
    static id = 'polarArea';
 static defaults = {
        dataElementType: 'arc',
        animation: {
            animateRotate: true,
            animateScale: true
        },
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'startAngle',
                    'endAngle',
                    'innerRadius',
                    'outerRadius'
                ]
            }
        },
        indexAxis: 'r',
        startAngle: 0
    };
 static overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels (chart) {
                        const data = chart.data;
                        if (data.labels.length && data.datasets.length) {
                            const { labels: { pointStyle , color  }  } = chart.legend.options;
                            return data.labels.map((label, i)=>{
                                const meta = chart.getDatasetMeta(0);
                                const style = meta.controller.getStyle(i);
                                return {
                                    text: label,
                                    fillStyle: style.backgroundColor,
                                    strokeStyle: style.borderColor,
                                    fontColor: color,
                                    lineWidth: style.borderWidth,
                                    pointStyle: pointStyle,
                                    hidden: !chart.getDataVisibility(i),
                                    index: i
                                };
                            });
                        }
                        return [];
                    }
                },
                onClick (e, legendItem, legend) {
                    legend.chart.toggleDataVisibility(legendItem.index);
                    legend.chart.update();
                }
            }
        },
        scales: {
            r: {
                type: 'radialLinear',
                angleLines: {
                    display: false
                },
                beginAtZero: true,
                grid: {
                    circular: true
                },
                pointLabels: {
                    display: false
                },
                startAngle: 0
            }
        }
    };
    constructor(chart, datasetIndex){
        super(chart, datasetIndex);
        this.innerRadius = undefined;
        this.outerRadius = undefined;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = formatNumber(meta._parsed[index].r, chart.options.locale);
        return {
            label: labels[index] || '',
            value
        };
    }
    parseObjectData(meta, data, start, count) {
        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
    }
    update(mode) {
        const arcs = this._cachedMeta.data;
        this._updateRadius();
        this.updateElements(arcs, 0, arcs.length, mode);
    }
 getMinMax() {
        const meta = this._cachedMeta;
        const range = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        };
        meta.data.forEach((element, index)=>{
            const parsed = this.getParsed(index).r;
            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {
                if (parsed < range.min) {
                    range.min = parsed;
                }
                if (parsed > range.max) {
                    range.max = parsed;
                }
            }
        });
        return range;
    }
 _updateRadius() {
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        const outerRadius = Math.max(minSize / 2, 0);
        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
        this.outerRadius = outerRadius - radiusLength * this.index;
        this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start, count, mode) {
        const reset = mode === 'reset';
        const chart = this.chart;
        const opts = chart.options;
        const animationOpts = opts.animation;
        const scale = this._cachedMeta.rScale;
        const centerX = scale.xCenter;
        const centerY = scale.yCenter;
        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
        let angle = datasetStartAngle;
        let i;
        const defaultAngle = 360 / this.countVisibleElements();
        for(i = 0; i < start; ++i){
            angle += this._computeAngle(i, mode, defaultAngle);
        }
        for(i = start; i < start + count; i++){
            const arc = arcs[i];
            let startAngle = angle;
            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
            angle = endAngle;
            if (reset) {
                if (animationOpts.animateScale) {
                    outerRadius = 0;
                }
                if (animationOpts.animateRotate) {
                    startAngle = endAngle = datasetStartAngle;
                }
            }
            const properties = {
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius,
                startAngle,
                endAngle,
                options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)
            };
            this.updateElement(arc, i, properties, mode);
        }
    }
    countVisibleElements() {
        const meta = this._cachedMeta;
        let count = 0;
        meta.data.forEach((element, index)=>{
            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {
                count++;
            }
        });
        return count;
    }
 _computeAngle(index, mode, defaultAngle) {
        return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
    }
}

class PieController extends DoughnutController {
    static id = 'pie';
 static defaults = {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: '100%'
    };
}

class RadarController extends DatasetController {
    static id = 'radar';
 static defaults = {
        datasetElementType: 'line',
        dataElementType: 'point',
        indexAxis: 'r',
        showLine: true,
        elements: {
            line: {
                fill: 'start'
            }
        }
    };
 static overrides = {
        aspectRatio: 1,
        scales: {
            r: {
                type: 'radialLinear'
            }
        }
    };
 getLabelAndValue(index) {
        const vScale = this._cachedMeta.vScale;
        const parsed = this.getParsed(index);
        return {
            label: vScale.getLabels()[index],
            value: '' + vScale.getLabelForValue(parsed[vScale.axis])
        };
    }
    parseObjectData(meta, data, start, count) {
        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
    }
    update(mode) {
        const meta = this._cachedMeta;
        const line = meta.dataset;
        const points = meta.data || [];
        const labels = meta.iScale.getLabels();
        line.points = points;
        if (mode !== 'resize') {
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
                options.borderWidth = 0;
            }
            const properties = {
                _loop: true,
                _fullLoop: labels.length === points.length,
                options
            };
            this.updateElement(line, undefined, properties, mode);
        }
        this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
        const scale = this._cachedMeta.rScale;
        const reset = mode === 'reset';
        for(let i = start; i < start + count; i++){
            const point = points[i];
            const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
            const x = reset ? scale.xCenter : pointPosition.x;
            const y = reset ? scale.yCenter : pointPosition.y;
            const properties = {
                x,
                y,
                angle: pointPosition.angle,
                skip: isNaN(x) || isNaN(y),
                options
            };
            this.updateElement(point, i, properties, mode);
        }
    }
}

class ScatterController extends DatasetController {
    static id = 'scatter';
 static defaults = {
        datasetElementType: false,
        dataElementType: 'point',
        showLine: false,
        fill: false
    };
 static overrides = {
        interaction: {
            mode: 'point'
        },
        scales: {
            x: {
                type: 'linear'
            },
            y: {
                type: 'linear'
            }
        }
    };
 getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const labels = this.chart.data.labels || [];
        const { xScale , yScale  } = meta;
        const parsed = this.getParsed(index);
        const x = xScale.getLabelForValue(parsed.x);
        const y = yScale.getLabelForValue(parsed.y);
        return {
            label: labels[index] || '',
            value: '(' + x + ', ' + y + ')'
        };
    }
    update(mode) {
        const meta = this._cachedMeta;
        const { data: points = []  } = meta;
        const animationsDisabled = this.chart._animationsDisabled;
        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
        this._drawStart = start;
        this._drawCount = count;
        if (_scaleRangesChanged(meta)) {
            start = 0;
            count = points.length;
        }
        if (this.options.showLine) {
            if (!this.datasetElementType) {
                this.addElements();
            }
            const { dataset: line , _dataset  } = meta;
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            options.segment = this.options.segment;
            this.updateElement(line, undefined, {
                animated: !animationsDisabled,
                options
            }, mode);
        } else if (this.datasetElementType) {
            delete meta.dataset;
            this.datasetElementType = false;
        }
        this.updateElements(points, start, count, mode);
    }
    addElements() {
        const { showLine  } = this.options;
        if (!this.datasetElementType && showLine) {
            this.datasetElementType = this.chart.registry.getElement('line');
        }
        super.addElements();
    }
    updateElements(points, start, count, mode) {
        const reset = mode === 'reset';
        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const { spanGaps , segment  } = this.options;
        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
        let prevParsed = start > 0 && this.getParsed(start - 1);
        for(let i = start; i < start + count; ++i){
            const point = points[i];
            const parsed = this.getParsed(i);
            const properties = directUpdate ? point : {};
            const nullData = isNullOrUndef(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
            }
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
            }
            if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
            }
            prevParsed = parsed;
        }
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
 getMaxOverflow() {
        const meta = this._cachedMeta;
        const data = meta.data || [];
        if (!this.options.showLine) {
            let max = 0;
            for(let i = data.length - 1; i >= 0; --i){
                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
            }
            return max > 0 && max;
        }
        const dataset = meta.dataset;
        const border = dataset.options && dataset.options.borderWidth || 0;
        if (!data.length) {
            return border;
        }
        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
        return Math.max(border, firstPoint, lastPoint) / 2;
    }
}

var controllers = /*#__PURE__*/Object.freeze({
__proto__: null,
BarController: BarController,
BubbleController: BubbleController,
DoughnutController: DoughnutController,
LineController: LineController,
PieController: PieController,
PolarAreaController: PolarAreaController,
RadarController: RadarController,
ScatterController: ScatterController
});

/**
 * @namespace Chart._adapters
 * @since 2.8.0
 * @private
 */ function abstract() {
    throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
}
/**
 * Date adapter (current used by the time scale)
 * @namespace Chart._adapters._date
 * @memberof Chart._adapters
 * @private
 */ class DateAdapterBase {
    /**
   * Override default date adapter methods.
   * Accepts type parameter to define options type.
   * @example
   * Chart._adapters._date.override<{myAdapterOption: string}>({
   *   init() {
   *     console.log(this.options.myAdapterOption);
   *   }
   * })
   */ static override(members) {
        Object.assign(DateAdapterBase.prototype, members);
    }
    options;
    constructor(options){
        this.options = options || {};
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {}
    formats() {
        return abstract();
    }
    parse() {
        return abstract();
    }
    format() {
        return abstract();
    }
    add() {
        return abstract();
    }
    diff() {
        return abstract();
    }
    startOf() {
        return abstract();
    }
    endOf() {
        return abstract();
    }
}
var adapters = {
    _date: DateAdapterBase
};

function binarySearch(metaset, axis, value, intersect) {
    const { controller , data , _sorted  } = metaset;
    const iScale = controller._cachedMeta.iScale;
    const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;
    if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {
        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
        if (!intersect) {
            const result = lookupMethod(data, axis, value);
            if (spanGaps) {
                const { vScale  } = controller._cachedMeta;
                const { _parsed  } = metaset;
                const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point)=>!isNullOrUndef(point[vScale.axis]));
                result.lo -= Math.max(0, distanceToDefinedLo);
                const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point)=>!isNullOrUndef(point[vScale.axis]));
                result.hi += Math.max(0, distanceToDefinedHi);
            }
            return result;
        } else if (controller._sharedOptions) {
            const el = data[0];
            const range = typeof el.getRange === 'function' && el.getRange(axis);
            if (range) {
                const start = lookupMethod(data, axis, value - range);
                const end = lookupMethod(data, axis, value + range);
                return {
                    lo: start.lo,
                    hi: end.hi
                };
            }
        }
    }
    return {
        lo: 0,
        hi: data.length - 1
    };
}
 function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for(let i = 0, ilen = metasets.length; i < ilen; ++i){
        const { index , data  } = metasets[i];
        const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);
        for(let j = lo; j <= hi; ++j){
            const element = data[j];
            if (!element.skip) {
                handler(element, index, j);
            }
        }
    }
}
 function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf('x') !== -1;
    const useY = axis.indexOf('y') !== -1;
    return function(pt1, pt2) {
        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
}
 function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
        return items;
    }
    const evaluationFunc = function(element, datasetIndex, index) {
        if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
            return;
        }
        if (element.inRange(position.x, position.y, useFinalPosition)) {
            items.push({
                element,
                datasetIndex,
                index
            });
        }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
}
 function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index) {
        const { startAngle , endAngle  } = element.getProps([
            'startAngle',
            'endAngle'
        ], useFinalPosition);
        const { angle  } = getAngleFromPoint(element, {
            x: position.x,
            y: position.y
        });
        if (_angleBetween(angle, startAngle, endAngle)) {
            items.push({
                element,
                datasetIndex,
                index
            });
        }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
}
 function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index) {
        const inRange = element.inRange(position.x, position.y, useFinalPosition);
        if (intersect && !inRange) {
            return;
        }
        const center = element.getCenterPoint(useFinalPosition);
        const pointInArea = !!includeInvisible || chart.isPointInArea(center);
        if (!pointInArea && !inRange) {
            return;
        }
        const distance = distanceMetric(position, center);
        if (distance < minDistance) {
            items = [
                {
                    element,
                    datasetIndex,
                    index
                }
            ];
            minDistance = distance;
        } else if (distance === minDistance) {
            items.push({
                element,
                datasetIndex,
                index
            });
        }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
}
 function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
        return [];
    }
    return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
 function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{
        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
            items.push({
                element,
                datasetIndex,
                index
            });
            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
        }
    });
    if (intersect && !intersectsItem) {
        return [];
    }
    return items;
}
 var Interaction = {
    modes: {
 index (chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || 'x';
            const includeInvisible = options.includeInvisible || false;
            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            const elements = [];
            if (!items.length) {
                return [];
            }
            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{
                const index = items[0].index;
                const element = meta.data[index];
                if (element && !element.skip) {
                    elements.push({
                        element,
                        datasetIndex: meta.index,
                        index
                    });
                }
            });
            return elements;
        },
 dataset (chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || 'xy';
            const includeInvisible = options.includeInvisible || false;
            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            if (items.length > 0) {
                const datasetIndex = items[0].datasetIndex;
                const data = chart.getDatasetMeta(datasetIndex).data;
                items = [];
                for(let i = 0; i < data.length; ++i){
                    items.push({
                        element: data[i],
                        datasetIndex,
                        index: i
                    });
                }
            }
            return items;
        },
 point (chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || 'xy';
            const includeInvisible = options.includeInvisible || false;
            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
        },
 nearest (chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options.axis || 'xy';
            const includeInvisible = options.includeInvisible || false;
            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
        },
 x (chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);
        },
 y (chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);
        }
    }
};

const STATIC_POSITIONS = [
    'left',
    'top',
    'right',
    'bottom'
];
function filterByPosition(array, position) {
    return array.filter((v)=>v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
    return array.sort((a, b)=>{
        const v0 = reverse ? b : a;
        const v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
}
function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i, ilen, box, pos, stack, stackWeight;
    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){
        box = boxes[i];
        ({ position: pos , options: { stack , stackWeight =1  }  } = box);
        layoutBoxes.push({
            index: i,
            box,
            pos,
            horizontal: box.isHorizontal(),
            weight: box.weight,
            stack: stack && pos + stack,
            stackWeight
        });
    }
    return layoutBoxes;
}
function buildStacks(layouts) {
    const stacks = {};
    for (const wrap of layouts){
        const { stack , pos , stackWeight  } = wrap;
        if (!stack || !STATIC_POSITIONS.includes(pos)) {
            continue;
        }
        const _stack = stacks[stack] || (stacks[stack] = {
            count: 0,
            placed: 0,
            weight: 0,
            size: 0
        });
        _stack.count++;
        _stack.weight += stackWeight;
    }
    return stacks;
}
 function setLayoutDims(layouts, params) {
    const stacks = buildStacks(layouts);
    const { vBoxMaxWidth , hBoxMaxHeight  } = params;
    let i, ilen, layout;
    for(i = 0, ilen = layouts.length; i < ilen; ++i){
        layout = layouts[i];
        const { fullSize  } = layout.box;
        const stack = stacks[layout.stack];
        const factor = stack && layout.stackWeight / stack.weight;
        if (layout.horizontal) {
            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
            layout.height = hBoxMaxHeight;
        } else {
            layout.width = vBoxMaxWidth;
            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
        }
    }
    return stacks;
}
function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);
    const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
    const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
    const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
    return {
        fullSize,
        leftAndTop: left.concat(top),
        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
        chartArea: filterByPosition(layoutBoxes, 'chartArea'),
        vertical: left.concat(right).concat(centerVertical),
        horizontal: top.concat(bottom).concat(centerHorizontal)
    };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
    const { pos , box  } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject(pos)) {
        if (layout.size) {
            chartArea[pos] -= layout.size;
        }
        const stack = stacks[layout.stack] || {
            size: 0,
            count: 1
        };
        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
        layout.size = stack.size / stack.count;
        chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
        updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
        same: widthChanged,
        other: heightChanged
    } : {
        same: heightChanged,
        other: widthChanged
    };
}
function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
        chartArea[pos] += change;
        return change;
    }
    chartArea.y += updatePos('top');
    chartArea.x += updatePos('left');
    updatePos('right');
    updatePos('bottom');
}
function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions) {
        const margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
        positions.forEach((pos)=>{
            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
        });
        return margin;
    }
    return horizontal ? marginForPositions([
        'left',
        'right'
    ]) : marginForPositions([
        'top',
        'bottom'
    ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i, ilen, layout, box, refit, changed;
    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){
        layout = boxes[i];
        box = layout.box;
        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
        const { same , other  } = updateDims(chartArea, params, layout, stacks);
        refit |= same && refitBoxes.length;
        changed = changed || other;
        if (!box.fullSize) {
            refitBoxes.push(layout);
        }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
    box.top = top;
    box.left = left;
    box.right = left + width;
    box.bottom = top + height;
    box.width = width;
    box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x , y  } = chartArea;
    for (const layout of boxes){
        const box = layout.box;
        const stack = stacks[layout.stack] || {
            placed: 0,
            weight: 1
        };
        const weight = layout.stackWeight / stack.weight || 1;
        if (layout.horizontal) {
            const width = chartArea.w * weight;
            const height = stack.size || box.height;
            if (defined(stack.start)) {
                y = stack.start;
            }
            if (box.fullSize) {
                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
            } else {
                setBoxDims(box, chartArea.left + stack.placed, y, width, height);
            }
            stack.start = y;
            stack.placed += width;
            y = box.bottom;
        } else {
            const height = chartArea.h * weight;
            const width = stack.size || box.width;
            if (defined(stack.start)) {
                x = stack.start;
            }
            if (box.fullSize) {
                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
            } else {
                setBoxDims(box, x, chartArea.top + stack.placed, width, height);
            }
            stack.start = x;
            stack.placed += height;
            x = box.right;
        }
    }
    chartArea.x = x;
    chartArea.y = y;
}
var layouts = {
 addBox (chart, item) {
        if (!chart.boxes) {
            chart.boxes = [];
        }
        item.fullSize = item.fullSize || false;
        item.position = item.position || 'top';
        item.weight = item.weight || 0;
        item._layers = item._layers || function() {
            return [
                {
                    z: 0,
                    draw (chartArea) {
                        item.draw(chartArea);
                    }
                }
            ];
        };
        chart.boxes.push(item);
    },
 removeBox (chart, layoutItem) {
        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
        if (index !== -1) {
            chart.boxes.splice(index, 1);
        }
    },
 configure (chart, item, options) {
        item.fullSize = options.fullSize;
        item.position = options.position;
        item.weight = options.weight;
    },
 update (chart, width, height, minPadding) {
        if (!chart) {
            return;
        }
        const padding = toPadding(chart.options.layout.padding);
        const availableWidth = Math.max(width - padding.width, 0);
        const availableHeight = Math.max(height - padding.height, 0);
        const boxes = buildLayoutBoxes(chart.boxes);
        const verticalBoxes = boxes.vertical;
        const horizontalBoxes = boxes.horizontal;
        each(chart.boxes, (box)=>{
            if (typeof box.beforeLayout === 'function') {
                box.beforeLayout();
            }
        });
        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
        const params = Object.freeze({
            outerWidth: width,
            outerHeight: height,
            padding,
            availableWidth,
            availableHeight,
            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
            hBoxMaxHeight: availableHeight / 2
        });
        const maxPadding = Object.assign({}, padding);
        updateMaxPadding(maxPadding, toPadding(minPadding));
        const chartArea = Object.assign({
            maxPadding,
            w: availableWidth,
            h: availableHeight,
            x: padding.left,
            y: padding.top
        }, padding);
        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
        fitBoxes(boxes.fullSize, chartArea, params, stacks);
        fitBoxes(verticalBoxes, chartArea, params, stacks);
        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
            fitBoxes(verticalBoxes, chartArea, params, stacks);
        }
        handleMaxPadding(chartArea);
        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
        chartArea.x += chartArea.w;
        chartArea.y += chartArea.h;
        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
        chart.chartArea = {
            left: chartArea.left,
            top: chartArea.top,
            right: chartArea.left + chartArea.w,
            bottom: chartArea.top + chartArea.h,
            height: chartArea.h,
            width: chartArea.w
        };
        each(boxes.chartArea, (layout)=>{
            const box = layout.box;
            Object.assign(box, chart.chartArea);
            box.update(chartArea.w, chartArea.h, {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            });
        });
    }
};

class BasePlatform {
 acquireContext(canvas, aspectRatio) {}
 releaseContext(context) {
        return false;
    }
 addEventListener(chart, type, listener) {}
 removeEventListener(chart, type, listener) {}
 getDevicePixelRatio() {
        return 1;
    }
 getMaximumSize(element, width, height, aspectRatio) {
        width = Math.max(0, width || element.width);
        height = height || element.height;
        return {
            width,
            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
        };
    }
 isAttached(canvas) {
        return true;
    }
 updateConfig(config) {
    }
}

class BasicPlatform extends BasePlatform {
    acquireContext(item) {
        return item && item.getContext && item.getContext('2d') || null;
    }
    updateConfig(config) {
        config.options.animation = false;
    }
}

const EXPANDO_KEY = '$chartjs';
 const EVENT_TYPES = {
    touchstart: 'mousedown',
    touchmove: 'mousemove',
    touchend: 'mouseup',
    pointerenter: 'mouseenter',
    pointerdown: 'mousedown',
    pointermove: 'mousemove',
    pointerup: 'mouseup',
    pointerleave: 'mouseout',
    pointerout: 'mouseout'
};
const isNullOrEmpty = (value)=>value === null || value === '';
 function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute('height');
    const renderWidth = canvas.getAttribute('width');
    canvas[EXPANDO_KEY] = {
        initial: {
            height: renderHeight,
            width: renderWidth,
            style: {
                display: style.display,
                height: style.height,
                width: style.width
            }
        }
    };
    style.display = style.display || 'block';
    style.boxSizing = style.boxSizing || 'border-box';
    if (isNullOrEmpty(renderWidth)) {
        const displayWidth = readUsedSize(canvas, 'width');
        if (displayWidth !== undefined) {
            canvas.width = displayWidth;
        }
    }
    if (isNullOrEmpty(renderHeight)) {
        if (canvas.style.height === '') {
            canvas.height = canvas.width / (aspectRatio || 2);
        } else {
            const displayHeight = readUsedSize(canvas, 'height');
            if (displayHeight !== undefined) {
                canvas.height = displayHeight;
            }
        }
    }
    return canvas;
}
const eventListenerOptions = supportsEventListenerOptions ? {
    passive: true
} : false;
function addListener(node, type, listener) {
    if (node) {
        node.addEventListener(type, listener, eventListenerOptions);
    }
}
function removeListener(chart, type, listener) {
    if (chart && chart.canvas) {
        chart.canvas.removeEventListener(type, listener, eventListenerOptions);
    }
}
function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x , y  } = getRelativePosition(event, chart);
    return {
        type,
        chart,
        native: event,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null
    };
}
function nodeListContains(nodeList, canvas) {
    for (const node of nodeList){
        if (node === canvas || node.contains(canvas)) {
            return true;
        }
    }
}
function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries)=>{
        let trigger = false;
        for (const entry of entries){
            trigger = trigger || nodeListContains(entry.addedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
        }
        if (trigger) {
            listener();
        }
    });
    observer.observe(document, {
        childList: true,
        subtree: true
    });
    return observer;
}
function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries)=>{
        let trigger = false;
        for (const entry of entries){
            trigger = trigger || nodeListContains(entry.removedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
        }
        if (trigger) {
            listener();
        }
    });
    observer.observe(document, {
        childList: true,
        subtree: true
    });
    return observer;
}
const drpListeningCharts = new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
        return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart)=>{
        if (chart.currentDevicePixelRatio !== dpr) {
            resize();
        }
    });
}
function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
        window.addEventListener('resize', onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
        window.removeEventListener('resize', onWindowResize);
    }
}
function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
        return;
    }
    const resize = throttled((width, height)=>{
        const w = container.clientWidth;
        listener(width, height);
        if (w < container.clientWidth) {
            listener();
        }
    }, window);
    const observer = new ResizeObserver((entries)=>{
        const entry = entries[0];
        const width = entry.contentRect.width;
        const height = entry.contentRect.height;
        if (width === 0 && height === 0) {
            return;
        }
        resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
}
function releaseObserver(chart, type, observer) {
    if (observer) {
        observer.disconnect();
    }
    if (type === 'resize') {
        unlistenDevicePixelRatioChanges(chart);
    }
}
function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event)=>{
        if (chart.ctx !== null) {
            listener(fromNativeEvent(event, chart));
        }
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
}
 class DomPlatform extends BasePlatform {
 acquireContext(canvas, aspectRatio) {
        const context = canvas && canvas.getContext && canvas.getContext('2d');
        if (context && context.canvas === canvas) {
            initCanvas(canvas, aspectRatio);
            return context;
        }
        return null;
    }
 releaseContext(context) {
        const canvas = context.canvas;
        if (!canvas[EXPANDO_KEY]) {
            return false;
        }
        const initial = canvas[EXPANDO_KEY].initial;
        [
            'height',
            'width'
        ].forEach((prop)=>{
            const value = initial[prop];
            if (isNullOrUndef(value)) {
                canvas.removeAttribute(prop);
            } else {
                canvas.setAttribute(prop, value);
            }
        });
        const style = initial.style || {};
        Object.keys(style).forEach((key)=>{
            canvas.style[key] = style[key];
        });
        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
        return true;
    }
 addEventListener(chart, type, listener) {
        this.removeEventListener(chart, type);
        const proxies = chart.$proxies || (chart.$proxies = {});
        const handlers = {
            attach: createAttachObserver,
            detach: createDetachObserver,
            resize: createResizeObserver
        };
        const handler = handlers[type] || createProxyAndListen;
        proxies[type] = handler(chart, type, listener);
    }
 removeEventListener(chart, type) {
        const proxies = chart.$proxies || (chart.$proxies = {});
        const proxy = proxies[type];
        if (!proxy) {
            return;
        }
        const handlers = {
            attach: releaseObserver,
            detach: releaseObserver,
            resize: releaseObserver
        };
        const handler = handlers[type] || removeListener;
        handler(chart, type, proxy);
        proxies[type] = undefined;
    }
    getDevicePixelRatio() {
        return window.devicePixelRatio;
    }
 getMaximumSize(canvas, width, height, aspectRatio) {
        return getMaximumSize(canvas, width, height, aspectRatio);
    }
 isAttached(canvas) {
        const container = canvas && _getParentNode(canvas);
        return !!(container && container.isConnected);
    }
}

function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {
        return BasicPlatform;
    }
    return DomPlatform;
}

let Element$1 = class Element {
    static defaults = {};
    static defaultRoutes = undefined;
    x;
    y;
    active = false;
    options;
    $animations;
    tooltipPosition(useFinalPosition) {
        const { x , y  } = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        return {
            x,
            y
        };
    }
    hasValue() {
        return isNumber(this.x) && isNumber(this.y);
    }
    getProps(props, final) {
        const anims = this.$animations;
        if (!final || !anims) {
            // let's not create an object, if not needed
            return this;
        }
        const ret = {};
        props.forEach((prop)=>{
            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
        });
        return ret;
    }
};

function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
        return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
        let i, ilen;
        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
        skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){
            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
        }
        skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
        return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
}
function determineMaxTicks(scale) {
    const offset = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
}
 function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
        return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){
        const factor = factors[i];
        if (factor > spacing) {
            return factor;
        }
    }
    return Math.max(spacing, 1);
}
 function getMajorIndices(ticks) {
    const result = [];
    let i, ilen;
    for(i = 0, ilen = ticks.length; i < ilen; i++){
        if (ticks[i].major) {
            result.push(i);
        }
    }
    return result;
}
 function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i;
    spacing = Math.ceil(spacing);
    for(i = 0; i < ticks.length; i++){
        if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = majorIndices[count * spacing];
        }
    }
}
 function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start = valueOrDefault(majorStart, 0);
    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
        length = majorEnd - majorStart;
        spacing = length / Math.floor(length / spacing);
    }
    next = start;
    while(next < 0){
        count++;
        next = Math.round(start + count * spacing);
    }
    for(i = Math.max(start, 0); i < end; i++){
        if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = Math.round(start + count * spacing);
        }
    }
}
 function getEvenSpacing(arr) {
    const len = arr.length;
    let i, diff;
    if (len < 2) {
        return false;
    }
    for(diff = arr[0], i = 1; i < len; ++i){
        if (arr[i] - arr[i - 1] !== diff) {
            return false;
        }
    }
    return diff;
}

const reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;
const offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;
const getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);
 function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i = 0;
    for(; i < len; i += increment){
        result.push(arr[Math.floor(i)]);
    }
    return result;
}
 function getPixelForGridLine(scale, index, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex = Math.min(index, length - 1);
    const start = scale._startPixel;
    const end = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex);
    let offset;
    if (offsetGridLines) {
        if (length === 1) {
            offset = Math.max(lineValue - start, end - lineValue);
        } else if (index === 0) {
            offset = (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
        }
        lineValue += validIndex < index ? offset : -offset;
        if (lineValue < start - epsilon || lineValue > end + epsilon) {
            return;
        }
    }
    return lineValue;
}
 function garbageCollect(caches, length) {
    each(caches, (cache)=>{
        const gc = cache.gc;
        const gcLen = gc.length / 2;
        let i;
        if (gcLen > length) {
            for(i = 0; i < gcLen; ++i){
                delete cache.data[gc[i]];
            }
            gc.splice(0, gcLen);
        }
    });
}
 function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
}
 function getTitleHeight(options, fallback) {
    if (!options.display) {
        return 0;
    }
    const font = toFont(options.font, fallback);
    const padding = toPadding(options.padding);
    const lines = isArray(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
    return createContext(parent, {
        scale,
        type: 'scale'
    });
}
function createTickContext(parent, index, tick) {
    return createContext(parent, {
        tick,
        index,
        type: 'tick'
    });
}
function titleAlign(align, position, reverse) {
     let ret = _toLeftRightCenter(align);
    if (reverse && position !== 'right' || !reverse && position === 'right') {
        ret = reverseAlign(ret);
    }
    return ret;
}
function titleArgs(scale, offset, position, align) {
    const { top , left , bottom , right , chart  } = scale;
    const { chartArea , scales  } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom - top;
    const width = right - left;
    if (scale.isHorizontal()) {
        titleX = _alignStartEnd(align, left, right);
        if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
        } else if (position === 'center') {
            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
        } else {
            titleY = offsetFromEdge(scale, position, offset);
        }
        maxWidth = right - left;
    } else {
        if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
        } else if (position === 'center') {
            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
        } else {
            titleX = offsetFromEdge(scale, position, offset);
        }
        titleY = _alignStartEnd(align, bottom, top);
        rotation = position === 'left' ? -HALF_PI : HALF_PI;
    }
    return {
        titleX,
        titleY,
        maxWidth,
        rotation
    };
}
class Scale extends Element$1 {
    constructor(cfg){
        super();
         this.id = cfg.id;
         this.type = cfg.type;
         this.options = undefined;
         this.ctx = cfg.ctx;
         this.chart = cfg.chart;
         this.top = undefined;
         this.bottom = undefined;
         this.left = undefined;
         this.right = undefined;
         this.width = undefined;
         this.height = undefined;
        this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        };
         this.maxWidth = undefined;
         this.maxHeight = undefined;
         this.paddingTop = undefined;
         this.paddingBottom = undefined;
         this.paddingLeft = undefined;
         this.paddingRight = undefined;
         this.axis = undefined;
         this.labelRotation = undefined;
        this.min = undefined;
        this.max = undefined;
        this._range = undefined;
         this.ticks = [];
         this._gridLineItems = null;
         this._labelItems = null;
         this._labelSizes = null;
        this._length = 0;
        this._maxLength = 0;
        this._longestTextCache = {};
         this._startPixel = undefined;
         this._endPixel = undefined;
        this._reversePixels = false;
        this._userMax = undefined;
        this._userMin = undefined;
        this._suggestedMax = undefined;
        this._suggestedMin = undefined;
        this._ticksLength = 0;
        this._borderValue = 0;
        this._cache = {};
        this._dataLimitsCached = false;
        this.$context = undefined;
    }
 init(options) {
        this.options = options.setContext(this.getContext());
        this.axis = options.axis;
        this._userMin = this.parse(options.min);
        this._userMax = this.parse(options.max);
        this._suggestedMin = this.parse(options.suggestedMin);
        this._suggestedMax = this.parse(options.suggestedMax);
    }
 parse(raw, index) {
        return raw;
    }
 getUserBounds() {
        let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;
        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
        return {
            min: finiteOrDefault(_userMin, _suggestedMin),
            max: finiteOrDefault(_userMax, _suggestedMax),
            minDefined: isNumberFinite(_userMin),
            maxDefined: isNumberFinite(_userMax)
        };
    }
 getMinMax(canStack) {
        let { min , max , minDefined , maxDefined  } = this.getUserBounds();
        let range;
        if (minDefined && maxDefined) {
            return {
                min,
                max
            };
        }
        const metas = this.getMatchingVisibleMetas();
        for(let i = 0, ilen = metas.length; i < ilen; ++i){
            range = metas[i].controller.getMinMax(this, canStack);
            if (!minDefined) {
                min = Math.min(min, range.min);
            }
            if (!maxDefined) {
                max = Math.max(max, range.max);
            }
        }
        min = maxDefined && min > max ? max : min;
        max = minDefined && min > max ? min : max;
        return {
            min: finiteOrDefault(min, finiteOrDefault(max, min)),
            max: finiteOrDefault(max, finiteOrDefault(min, max))
        };
    }
 getPadding() {
        return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0
        };
    }
 getTicks() {
        return this.ticks;
    }
 getLabels() {
        const data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
 getLabelItems(chartArea = this.chart.chartArea) {
        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
        return items;
    }
    beforeLayout() {
        this._cache = {};
        this._dataLimitsCached = false;
    }
    beforeUpdate() {
        callback(this.options.beforeUpdate, [
            this
        ]);
    }
 update(maxWidth, maxHeight, margins) {
        const { beginAtZero , grace , ticks: tickOpts  } = this.options;
        const sampleSize = tickOpts.sampleSize;
        this.beforeUpdate();
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        }, margins);
        this.ticks = null;
        this._labelSizes = null;
        this._gridLineItems = null;
        this._labelItems = null;
        this.beforeSetDimensions();
        this.setDimensions();
        this.afterSetDimensions();
        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
        if (!this._dataLimitsCached) {
            this.beforeDataLimits();
            this.determineDataLimits();
            this.afterDataLimits();
            this._range = _addGrace(this, grace, beginAtZero);
            this._dataLimitsCached = true;
        }
        this.beforeBuildTicks();
        this.ticks = this.buildTicks() || [];
        this.afterBuildTicks();
        const samplingEnabled = sampleSize < this.ticks.length;
        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
        this.configure();
        this.beforeCalculateLabelRotation();
        this.calculateLabelRotation();
        this.afterCalculateLabelRotation();
        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
            this.ticks = autoSkip(this, this.ticks);
            this._labelSizes = null;
            this.afterAutoSkip();
        }
        if (samplingEnabled) {
            this._convertTicksToLabels(this.ticks);
        }
        this.beforeFit();
        this.fit();
        this.afterFit();
        this.afterUpdate();
    }
 configure() {
        let reversePixels = this.options.reverse;
        let startPixel, endPixel;
        if (this.isHorizontal()) {
            startPixel = this.left;
            endPixel = this.right;
        } else {
            startPixel = this.top;
            endPixel = this.bottom;
            reversePixels = !reversePixels;
        }
        this._startPixel = startPixel;
        this._endPixel = endPixel;
        this._reversePixels = reversePixels;
        this._length = endPixel - startPixel;
        this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
        callback(this.options.afterUpdate, [
            this
        ]);
    }
    beforeSetDimensions() {
        callback(this.options.beforeSetDimensions, [
            this
        ]);
    }
    setDimensions() {
        if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = 0;
            this.right = this.width;
        } else {
            this.height = this.maxHeight;
            this.top = 0;
            this.bottom = this.height;
        }
        this.paddingLeft = 0;
        this.paddingTop = 0;
        this.paddingRight = 0;
        this.paddingBottom = 0;
    }
    afterSetDimensions() {
        callback(this.options.afterSetDimensions, [
            this
        ]);
    }
    _callHooks(name) {
        this.chart.notifyPlugins(name, this.getContext());
        callback(this.options[name], [
            this
        ]);
    }
    beforeDataLimits() {
        this._callHooks('beforeDataLimits');
    }
    determineDataLimits() {}
    afterDataLimits() {
        this._callHooks('afterDataLimits');
    }
    beforeBuildTicks() {
        this._callHooks('beforeBuildTicks');
    }
 buildTicks() {
        return [];
    }
    afterBuildTicks() {
        this._callHooks('afterBuildTicks');
    }
    beforeTickToLabelConversion() {
        callback(this.options.beforeTickToLabelConversion, [
            this
        ]);
    }
 generateTickLabels(ticks) {
        const tickOpts = this.options.ticks;
        let i, ilen, tick;
        for(i = 0, ilen = ticks.length; i < ilen; i++){
            tick = ticks[i];
            tick.label = callback(tickOpts.callback, [
                tick.value,
                i,
                ticks
            ], this);
        }
    }
    afterTickToLabelConversion() {
        callback(this.options.afterTickToLabelConversion, [
            this
        ]);
    }
    beforeCalculateLabelRotation() {
        callback(this.options.beforeCalculateLabelRotation, [
            this
        ]);
    }
    calculateLabelRotation() {
        const options = this.options;
        const tickOpts = options.ticks;
        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
        const minRotation = tickOpts.minRotation || 0;
        const maxRotation = tickOpts.maxRotation;
        let labelRotation = minRotation;
        let tickWidth, maxHeight, maxLabelDiagonal;
        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
            this.labelRotation = minRotation;
            return;
        }
        const labelSizes = this._getLabelSizes();
        const maxLabelWidth = labelSizes.widest.width;
        const maxLabelHeight = labelSizes.highest.height;
        const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
        if (maxLabelWidth + 6 > tickWidth) {
            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
            labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
        }
        this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
        callback(this.options.afterCalculateLabelRotation, [
            this
        ]);
    }
    afterAutoSkip() {}
    beforeFit() {
        callback(this.options.beforeFit, [
            this
        ]);
    }
    fit() {
        const minSize = {
            width: 0,
            height: 0
        };
        const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;
        const display = this._isVisible();
        const isHorizontal = this.isHorizontal();
        if (display) {
            const titleHeight = getTitleHeight(titleOpts, chart.options.font);
            if (isHorizontal) {
                minSize.width = this.maxWidth;
                minSize.height = getTickMarkLength(gridOpts) + titleHeight;
            } else {
                minSize.height = this.maxHeight;
                minSize.width = getTickMarkLength(gridOpts) + titleHeight;
            }
            if (tickOpts.display && this.ticks.length) {
                const { first , last , widest , highest  } = this._getLabelSizes();
                const tickPadding = tickOpts.padding * 2;
                const angleRadians = toRadians(this.labelRotation);
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                if (isHorizontal) {
                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                } else {
                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                }
                this._calculatePadding(first, last, sin, cos);
            }
        }
        this._handleMargins();
        if (isHorizontal) {
            this.width = this._length = chart.width - this._margins.left - this._margins.right;
            this.height = minSize.height;
        } else {
            this.width = minSize.width;
            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
        }
    }
    _calculatePadding(first, last, sin, cos) {
        const { ticks: { align , padding  } , position  } = this.options;
        const isRotated = this.labelRotation !== 0;
        const labelsBelowTicks = position !== 'top' && this.axis === 'x';
        if (this.isHorizontal()) {
            const offsetLeft = this.getPixelForTick(0) - this.left;
            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
            let paddingLeft = 0;
            let paddingRight = 0;
            if (isRotated) {
                if (labelsBelowTicks) {
                    paddingLeft = cos * first.width;
                    paddingRight = sin * last.height;
                } else {
                    paddingLeft = sin * first.height;
                    paddingRight = cos * last.width;
                }
            } else if (align === 'start') {
                paddingRight = last.width;
            } else if (align === 'end') {
                paddingLeft = first.width;
            } else if (align !== 'inner') {
                paddingLeft = first.width / 2;
                paddingRight = last.width / 2;
            }
            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
        } else {
            let paddingTop = last.height / 2;
            let paddingBottom = first.height / 2;
            if (align === 'start') {
                paddingTop = 0;
                paddingBottom = first.height;
            } else if (align === 'end') {
                paddingTop = last.height;
                paddingBottom = 0;
            }
            this.paddingTop = paddingTop + padding;
            this.paddingBottom = paddingBottom + padding;
        }
    }
 _handleMargins() {
        if (this._margins) {
            this._margins.left = Math.max(this.paddingLeft, this._margins.left);
            this._margins.top = Math.max(this.paddingTop, this._margins.top);
            this._margins.right = Math.max(this.paddingRight, this._margins.right);
            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
        }
    }
    afterFit() {
        callback(this.options.afterFit, [
            this
        ]);
    }
 isHorizontal() {
        const { axis , position  } = this.options;
        return position === 'top' || position === 'bottom' || axis === 'x';
    }
 isFullSize() {
        return this.options.fullSize;
    }
 _convertTicksToLabels(ticks) {
        this.beforeTickToLabelConversion();
        this.generateTickLabels(ticks);
        let i, ilen;
        for(i = 0, ilen = ticks.length; i < ilen; i++){
            if (isNullOrUndef(ticks[i].label)) {
                ticks.splice(i, 1);
                ilen--;
                i--;
            }
        }
        this.afterTickToLabelConversion();
    }
 _getLabelSizes() {
        let labelSizes = this._labelSizes;
        if (!labelSizes) {
            const sampleSize = this.options.ticks.sampleSize;
            let ticks = this.ticks;
            if (sampleSize < ticks.length) {
                ticks = sample(ticks, sampleSize);
            }
            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
        }
        return labelSizes;
    }
 _computeLabelSizes(ticks, length, maxTicksLimit) {
        const { ctx , _longestTextCache: caches  } = this;
        const widths = [];
        const heights = [];
        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
        let widestLabelSize = 0;
        let highestLabelSize = 0;
        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
        for(i = 0; i < length; i += increment){
            label = ticks[i].label;
            tickFont = this._resolveTickFontOptions(i);
            ctx.font = fontString = tickFont.string;
            cache = caches[fontString] = caches[fontString] || {
                data: {},
                gc: []
            };
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!isNullOrUndef(label) && !isArray(label)) {
                width = _measureText(ctx, cache.data, cache.gc, width, label);
                height = lineHeight;
            } else if (isArray(label)) {
                for(j = 0, jlen = label.length; j < jlen; ++j){
                    nestedLabel =  label[j];
                    if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                        width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                        height += lineHeight;
                    }
                }
            }
            widths.push(width);
            heights.push(height);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
        }
        garbageCollect(caches, length);
        const widest = widths.indexOf(widestLabelSize);
        const highest = heights.indexOf(highestLabelSize);
        const valueAt = (idx)=>({
                width: widths[idx] || 0,
                height: heights[idx] || 0
            });
        return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest),
            widths,
            heights
        };
    }
 getLabelForValue(value) {
        return value;
    }
 getPixelForValue(value, index) {
        return NaN;
    }
 getValueForPixel(pixel) {}
 getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) {
            return null;
        }
        return this.getPixelForValue(ticks[index].value);
    }
 getPixelForDecimal(decimal) {
        if (this._reversePixels) {
            decimal = 1 - decimal;
        }
        const pixel = this._startPixel + decimal * this._length;
        return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
 getDecimalForPixel(pixel) {
        const decimal = (pixel - this._startPixel) / this._length;
        return this._reversePixels ? 1 - decimal : decimal;
    }
 getBasePixel() {
        return this.getPixelForValue(this.getBaseValue());
    }
 getBaseValue() {
        const { min , max  } = this;
        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    }
 getContext(index) {
        const ticks = this.ticks || [];
        if (index >= 0 && index < ticks.length) {
            const tick = ticks[index];
            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
        }
        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
 _tickSize() {
        const optionTicks = this.options.ticks;
        const rot = toRadians(this.labelRotation);
        const cos = Math.abs(Math.cos(rot));
        const sin = Math.abs(Math.sin(rot));
        const labelSizes = this._getLabelSizes();
        const padding = optionTicks.autoSkipPadding || 0;
        const w = labelSizes ? labelSizes.widest.width + padding : 0;
        const h = labelSizes ? labelSizes.highest.height + padding : 0;
        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
    }
 _isVisible() {
        const display = this.options.display;
        if (display !== 'auto') {
            return !!display;
        }
        return this.getMatchingVisibleMetas().length > 0;
    }
 _computeGridLineItems(chartArea) {
        const axis = this.axis;
        const chart = this.chart;
        const options = this.options;
        const { grid , position , border  } = options;
        const offset = grid.offset;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const ticksLength = ticks.length + (offset ? 1 : 0);
        const tl = getTickMarkLength(grid);
        const items = [];
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = borderOpts.display ? borderOpts.width : 0;
        const axisHalfWidth = axisWidth / 2;
        const alignBorderValue = function(pixel) {
            return _alignPixel(chart, pixel, axisWidth);
        };
        let borderValue, i, lineValue, alignedLineValue;
        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
        if (position === 'top') {
            borderValue = alignBorderValue(this.bottom);
            ty1 = this.bottom - tl;
            ty2 = borderValue - axisHalfWidth;
            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
            y2 = chartArea.bottom;
        } else if (position === 'bottom') {
            borderValue = alignBorderValue(this.top);
            y1 = chartArea.top;
            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
            ty1 = borderValue + axisHalfWidth;
            ty2 = this.top + tl;
        } else if (position === 'left') {
            borderValue = alignBorderValue(this.right);
            tx1 = this.right - tl;
            tx2 = borderValue - axisHalfWidth;
            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
            x2 = chartArea.right;
        } else if (position === 'right') {
            borderValue = alignBorderValue(this.left);
            x1 = chartArea.left;
            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
            tx1 = borderValue + axisHalfWidth;
            tx2 = this.left + tl;
        } else if (axis === 'x') {
            if (position === 'center') {
                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
            } else if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            y1 = chartArea.top;
            y2 = chartArea.bottom;
            ty1 = borderValue + axisHalfWidth;
            ty2 = ty1 + tl;
        } else if (axis === 'y') {
            if (position === 'center') {
                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
            } else if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            tx1 = borderValue - axisHalfWidth;
            tx2 = tx1 - tl;
            x1 = chartArea.left;
            x2 = chartArea.right;
        }
        const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
        const step = Math.max(1, Math.ceil(ticksLength / limit));
        for(i = 0; i < ticksLength; i += step){
            const context = this.getContext(i);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            const lineWidth = optsAtIndex.lineWidth;
            const lineColor = optsAtIndex.color;
            const borderDash = optsAtIndexBorder.dash || [];
            const borderDashOffset = optsAtIndexBorder.dashOffset;
            const tickWidth = optsAtIndex.tickWidth;
            const tickColor = optsAtIndex.tickColor;
            const tickBorderDash = optsAtIndex.tickBorderDash || [];
            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
            lineValue = getPixelForGridLine(this, i, offset);
            if (lineValue === undefined) {
                continue;
            }
            alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
            if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
            } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
            }
            items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset,
                tickWidth,
                tickColor,
                tickBorderDash,
                tickBorderDashOffset
            });
        }
        this._ticksLength = ticksLength;
        this._borderValue = borderValue;
        return items;
    }
 _computeLabelItems(chartArea) {
        const axis = this.axis;
        const options = this.options;
        const { position , ticks: optionTicks  } = options;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const { align , crossAlign , padding , mirror  } = optionTicks;
        const tl = getTickMarkLength(options.grid);
        const tickAndPadding = tl + padding;
        const hTickAndPadding = mirror ? -padding : tickAndPadding;
        const rotation = -toRadians(this.labelRotation);
        const items = [];
        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
        let textBaseline = 'middle';
        if (position === 'top') {
            y = this.bottom - hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
        } else if (position === 'bottom') {
            y = this.top + hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
        } else if (position === 'left') {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
        } else if (position === 'right') {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
        } else if (axis === 'x') {
            if (position === 'center') {
                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
            } else if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
            }
            textAlign = this._getXAxisLabelAlignment();
        } else if (axis === 'y') {
            if (position === 'center') {
                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
            } else if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                x = this.chart.scales[positionAxisID].getPixelForValue(value);
            }
            textAlign = this._getYAxisLabelAlignment(tl).textAlign;
        }
        if (axis === 'y') {
            if (align === 'start') {
                textBaseline = 'top';
            } else if (align === 'end') {
                textBaseline = 'bottom';
            }
        }
        const labelSizes = this._getLabelSizes();
        for(i = 0, ilen = ticks.length; i < ilen; ++i){
            tick = ticks[i];
            label = tick.label;
            const optsAtIndex = optionTicks.setContext(this.getContext(i));
            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
            font = this._resolveTickFontOptions(i);
            lineHeight = font.lineHeight;
            lineCount = isArray(label) ? label.length : 1;
            const halfCount = lineCount / 2;
            const color = optsAtIndex.color;
            const strokeColor = optsAtIndex.textStrokeColor;
            const strokeWidth = optsAtIndex.textStrokeWidth;
            let tickTextAlign = textAlign;
            if (isHorizontal) {
                x = pixel;
                if (textAlign === 'inner') {
                    if (i === ilen - 1) {
                        tickTextAlign = !this.options.reverse ? 'right' : 'left';
                    } else if (i === 0) {
                        tickTextAlign = !this.options.reverse ? 'left' : 'right';
                    } else {
                        tickTextAlign = 'center';
                    }
                }
                if (position === 'top') {
                    if (crossAlign === 'near' || rotation !== 0) {
                        textOffset = -lineCount * lineHeight + lineHeight / 2;
                    } else if (crossAlign === 'center') {
                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                    } else {
                        textOffset = -labelSizes.highest.height + lineHeight / 2;
                    }
                } else {
                    if (crossAlign === 'near' || rotation !== 0) {
                        textOffset = lineHeight / 2;
                    } else if (crossAlign === 'center') {
                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                    } else {
                        textOffset = labelSizes.highest.height - lineCount * lineHeight;
                    }
                }
                if (mirror) {
                    textOffset *= -1;
                }
                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
                    x += lineHeight / 2 * Math.sin(rotation);
                }
            } else {
                y = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
            }
            let backdrop;
            if (optsAtIndex.showLabelBackdrop) {
                const labelPadding = toPadding(optsAtIndex.backdropPadding);
                const height = labelSizes.heights[i];
                const width = labelSizes.widths[i];
                let top = textOffset - labelPadding.top;
                let left = 0 - labelPadding.left;
                switch(textBaseline){
                    case 'middle':
                        top -= height / 2;
                        break;
                    case 'bottom':
                        top -= height;
                        break;
                }
                switch(textAlign){
                    case 'center':
                        left -= width / 2;
                        break;
                    case 'right':
                        left -= width;
                        break;
                    case 'inner':
                        if (i === ilen - 1) {
                            left -= width;
                        } else if (i > 0) {
                            left -= width / 2;
                        }
                        break;
                }
                backdrop = {
                    left,
                    top,
                    width: width + labelPadding.width,
                    height: height + labelPadding.height,
                    color: optsAtIndex.backdropColor
                };
            }
            items.push({
                label,
                font,
                textOffset,
                options: {
                    rotation,
                    color,
                    strokeColor,
                    strokeWidth,
                    textAlign: tickTextAlign,
                    textBaseline,
                    translation: [
                        x,
                        y
                    ],
                    backdrop
                }
            });
        }
        return items;
    }
    _getXAxisLabelAlignment() {
        const { position , ticks  } = this.options;
        const rotation = -toRadians(this.labelRotation);
        if (rotation) {
            return position === 'top' ? 'left' : 'right';
        }
        let align = 'center';
        if (ticks.align === 'start') {
            align = 'left';
        } else if (ticks.align === 'end') {
            align = 'right';
        } else if (ticks.align === 'inner') {
            align = 'inner';
        }
        return align;
    }
    _getYAxisLabelAlignment(tl) {
        const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;
        const labelSizes = this._getLabelSizes();
        const tickAndPadding = tl + padding;
        const widest = labelSizes.widest.width;
        let textAlign;
        let x;
        if (position === 'left') {
            if (mirror) {
                x = this.right + padding;
                if (crossAlign === 'near') {
                    textAlign = 'left';
                } else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x += widest / 2;
                } else {
                    textAlign = 'right';
                    x += widest;
                }
            } else {
                x = this.right - tickAndPadding;
                if (crossAlign === 'near') {
                    textAlign = 'right';
                } else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x -= widest / 2;
                } else {
                    textAlign = 'left';
                    x = this.left;
                }
            }
        } else if (position === 'right') {
            if (mirror) {
                x = this.left + padding;
                if (crossAlign === 'near') {
                    textAlign = 'right';
                } else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x -= widest / 2;
                } else {
                    textAlign = 'left';
                    x -= widest;
                }
            } else {
                x = this.left + tickAndPadding;
                if (crossAlign === 'near') {
                    textAlign = 'left';
                } else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x += widest / 2;
                } else {
                    textAlign = 'right';
                    x = this.right;
                }
            }
        } else {
            textAlign = 'right';
        }
        return {
            textAlign,
            x
        };
    }
 _computeLabelArea() {
        if (this.options.ticks.mirror) {
            return;
        }
        const chart = this.chart;
        const position = this.options.position;
        if (position === 'left' || position === 'right') {
            return {
                top: 0,
                left: this.left,
                bottom: chart.height,
                right: this.right
            };
        }
        if (position === 'top' || position === 'bottom') {
            return {
                top: this.top,
                left: 0,
                bottom: this.bottom,
                right: chart.width
            };
        }
    }
 drawBackground() {
        const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;
        if (backgroundColor) {
            ctx.save();
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(left, top, width, height);
            ctx.restore();
        }
    }
    getLineWidthForValue(value) {
        const grid = this.options.grid;
        if (!this._isVisible() || !grid.display) {
            return 0;
        }
        const ticks = this.ticks;
        const index = ticks.findIndex((t)=>t.value === value);
        if (index >= 0) {
            const opts = grid.setContext(this.getContext(index));
            return opts.lineWidth;
        }
        return 0;
    }
 drawGrid(chartArea) {
        const grid = this.options.grid;
        const ctx = this.ctx;
        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
        let i, ilen;
        const drawLine = (p1, p2, style)=>{
            if (!style.width || !style.color) {
                return;
            }
            ctx.save();
            ctx.lineWidth = style.width;
            ctx.strokeStyle = style.color;
            ctx.setLineDash(style.borderDash || []);
            ctx.lineDashOffset = style.borderDashOffset;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.restore();
        };
        if (grid.display) {
            for(i = 0, ilen = items.length; i < ilen; ++i){
                const item = items[i];
                if (grid.drawOnChartArea) {
                    drawLine({
                        x: item.x1,
                        y: item.y1
                    }, {
                        x: item.x2,
                        y: item.y2
                    }, item);
                }
                if (grid.drawTicks) {
                    drawLine({
                        x: item.tx1,
                        y: item.ty1
                    }, {
                        x: item.tx2,
                        y: item.ty2
                    }, {
                        color: item.tickColor,
                        width: item.tickWidth,
                        borderDash: item.tickBorderDash,
                        borderDashOffset: item.tickBorderDashOffset
                    });
                }
            }
        }
    }
 drawBorder() {
        const { chart , ctx , options: { border , grid  }  } = this;
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = border.display ? borderOpts.width : 0;
        if (!axisWidth) {
            return;
        }
        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
        const borderValue = this._borderValue;
        let x1, x2, y1, y2;
        if (this.isHorizontal()) {
            x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
            x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
        } else {
            y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
            y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
        }
        ctx.save();
        ctx.lineWidth = borderOpts.width;
        ctx.strokeStyle = borderOpts.color;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
    }
 drawLabels(chartArea) {
        const optionTicks = this.options.ticks;
        if (!optionTicks.display) {
            return;
        }
        const ctx = this.ctx;
        const area = this._computeLabelArea();
        if (area) {
            clipArea(ctx, area);
        }
        const items = this.getLabelItems(chartArea);
        for (const item of items){
            const renderTextOptions = item.options;
            const tickFont = item.font;
            const label = item.label;
            const y = item.textOffset;
            renderText(ctx, label, 0, y, tickFont, renderTextOptions);
        }
        if (area) {
            unclipArea(ctx);
        }
    }
 drawTitle() {
        const { ctx , options: { position , title , reverse  }  } = this;
        if (!title.display) {
            return;
        }
        const font = toFont(title.font);
        const padding = toPadding(title.padding);
        const align = title.align;
        let offset = font.lineHeight / 2;
        if (position === 'bottom' || position === 'center' || isObject(position)) {
            offset += padding.bottom;
            if (isArray(title.text)) {
                offset += font.lineHeight * (title.text.length - 1);
            }
        } else {
            offset += padding.top;
        }
        const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);
        renderText(ctx, title.text, 0, 0, font, {
            color: title.color,
            maxWidth,
            rotation,
            textAlign: titleAlign(align, position, reverse),
            textBaseline: 'middle',
            translation: [
                titleX,
                titleY
            ]
        });
    }
    draw(chartArea) {
        if (!this._isVisible()) {
            return;
        }
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawBorder();
        this.drawTitle();
        this.drawLabels(chartArea);
    }
 _layers() {
        const opts = this.options;
        const tz = opts.ticks && opts.ticks.z || 0;
        const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
        const bz = valueOrDefault(opts.border && opts.border.z, 0);
        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
            return [
                {
                    z: tz,
                    draw: (chartArea)=>{
                        this.draw(chartArea);
                    }
                }
            ];
        }
        return [
            {
                z: gz,
                draw: (chartArea)=>{
                    this.drawBackground();
                    this.drawGrid(chartArea);
                    this.drawTitle();
                }
            },
            {
                z: bz,
                draw: ()=>{
                    this.drawBorder();
                }
            },
            {
                z: tz,
                draw: (chartArea)=>{
                    this.drawLabels(chartArea);
                }
            }
        ];
    }
 getMatchingVisibleMetas(type) {
        const metas = this.chart.getSortedVisibleDatasetMetas();
        const axisID = this.axis + 'AxisID';
        const result = [];
        let i, ilen;
        for(i = 0, ilen = metas.length; i < ilen; ++i){
            const meta = metas[i];
            if (meta[axisID] === this.id && (!type || meta.type === type)) {
                result.push(meta);
            }
        }
        return result;
    }
 _resolveTickFontOptions(index) {
        const opts = this.options.ticks.setContext(this.getContext(index));
        return toFont(opts.font);
    }
 _maxDigits() {
        const fontSize = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
}

class TypedRegistry {
    constructor(type, scope, override){
        this.type = type;
        this.scope = scope;
        this.override = override;
        this.items = Object.create(null);
    }
    isForType(type) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
 register(item) {
        const proto = Object.getPrototypeOf(item);
        let parentScope;
        if (isIChartComponent(proto)) {
            parentScope = this.register(proto);
        }
        const items = this.items;
        const id = item.id;
        const scope = this.scope + '.' + id;
        if (!id) {
            throw new Error('class does not have id: ' + item);
        }
        if (id in items) {
            return scope;
        }
        items[id] = item;
        registerDefaults(item, scope, parentScope);
        if (this.override) {
            defaults.override(item.id, item.overrides);
        }
        return scope;
    }
 get(id) {
        return this.items[id];
    }
 unregister(item) {
        const items = this.items;
        const id = item.id;
        const scope = this.scope;
        if (id in items) {
            delete items[id];
        }
        if (scope && id in defaults[scope]) {
            delete defaults[scope][id];
            if (this.override) {
                delete overrides[id];
            }
        }
    }
}
function registerDefaults(item, scope, parentScope) {
    const itemDefaults = merge(Object.create(null), [
        parentScope ? defaults.get(parentScope) : {},
        defaults.get(scope),
        item.defaults
    ]);
    defaults.set(scope, itemDefaults);
    if (item.defaultRoutes) {
        routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
        defaults.describe(scope, item.descriptors);
    }
}
function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property)=>{
        const propertyParts = property.split('.');
        const sourceName = propertyParts.pop();
        const sourceScope = [
            scope
        ].concat(propertyParts).join('.');
        const parts = routes[property].split('.');
        const targetName = parts.pop();
        const targetScope = parts.join('.');
        defaults.route(sourceScope, sourceName, targetScope, targetName);
    });
}
function isIChartComponent(proto) {
    return 'id' in proto && 'defaults' in proto;
}

class Registry {
    constructor(){
        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);
        this.elements = new TypedRegistry(Element$1, 'elements');
        this.plugins = new TypedRegistry(Object, 'plugins');
        this.scales = new TypedRegistry(Scale, 'scales');
        this._typedRegistries = [
            this.controllers,
            this.scales,
            this.elements
        ];
    }
 add(...args) {
        this._each('register', args);
    }
    remove(...args) {
        this._each('unregister', args);
    }
 addControllers(...args) {
        this._each('register', args, this.controllers);
    }
 addElements(...args) {
        this._each('register', args, this.elements);
    }
 addPlugins(...args) {
        this._each('register', args, this.plugins);
    }
 addScales(...args) {
        this._each('register', args, this.scales);
    }
 getController(id) {
        return this._get(id, this.controllers, 'controller');
    }
 getElement(id) {
        return this._get(id, this.elements, 'element');
    }
 getPlugin(id) {
        return this._get(id, this.plugins, 'plugin');
    }
 getScale(id) {
        return this._get(id, this.scales, 'scale');
    }
 removeControllers(...args) {
        this._each('unregister', args, this.controllers);
    }
 removeElements(...args) {
        this._each('unregister', args, this.elements);
    }
 removePlugins(...args) {
        this._each('unregister', args, this.plugins);
    }
 removeScales(...args) {
        this._each('unregister', args, this.scales);
    }
 _each(method, args, typedRegistry) {
        [
            ...args
        ].forEach((arg)=>{
            const reg = typedRegistry || this._getRegistryForType(arg);
            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
                this._exec(method, reg, arg);
            } else {
                each(arg, (item)=>{
                    const itemReg = typedRegistry || this._getRegistryForType(item);
                    this._exec(method, itemReg, item);
                });
            }
        });
    }
 _exec(method, registry, component) {
        const camelMethod = _capitalize(method);
        callback(component['before' + camelMethod], [], component);
        registry[method](component);
        callback(component['after' + camelMethod], [], component);
    }
 _getRegistryForType(type) {
        for(let i = 0; i < this._typedRegistries.length; i++){
            const reg = this._typedRegistries[i];
            if (reg.isForType(type)) {
                return reg;
            }
        }
        return this.plugins;
    }
 _get(id, typedRegistry, type) {
        const item = typedRegistry.get(id);
        if (item === undefined) {
            throw new Error('"' + id + '" is not a registered ' + type + '.');
        }
        return item;
    }
}
var registry = /* #__PURE__ */ new Registry();

class PluginService {
    constructor(){
        this._init = [];
    }
 notify(chart, hook, args, filter) {
        if (hook === 'beforeInit') {
            this._init = this._createDescriptors(chart, true);
            this._notify(this._init, chart, 'install');
        }
        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
        const result = this._notify(descriptors, chart, hook, args);
        if (hook === 'afterDestroy') {
            this._notify(descriptors, chart, 'stop');
            this._notify(this._init, chart, 'uninstall');
        }
        return result;
    }
 _notify(descriptors, chart, hook, args) {
        args = args || {};
        for (const descriptor of descriptors){
            const plugin = descriptor.plugin;
            const method = plugin[hook];
            const params = [
                chart,
                args,
                descriptor.options
            ];
            if (callback(method, params, plugin) === false && args.cancelable) {
                return false;
            }
        }
        return true;
    }
    invalidate() {
        if (!isNullOrUndef(this._cache)) {
            this._oldCache = this._cache;
            this._cache = undefined;
        }
    }
 _descriptors(chart) {
        if (this._cache) {
            return this._cache;
        }
        const descriptors = this._cache = this._createDescriptors(chart);
        this._notifyStateChanges(chart);
        return descriptors;
    }
    _createDescriptors(chart, all) {
        const config = chart && chart.config;
        const options = valueOrDefault(config.options && config.options.plugins, {});
        const plugins = allPlugins(config);
        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
    }
 _notifyStateChanges(chart) {
        const previousDescriptors = this._oldCache || [];
        const descriptors = this._cache;
        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));
        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
        this._notify(diff(descriptors, previousDescriptors), chart, 'start');
    }
}
 function allPlugins(config) {
    const localIds = {};
    const plugins = [];
    const keys = Object.keys(registry.plugins.items);
    for(let i = 0; i < keys.length; i++){
        plugins.push(registry.getPlugin(keys[i]));
    }
    const local = config.plugins || [];
    for(let i = 0; i < local.length; i++){
        const plugin = local[i];
        if (plugins.indexOf(plugin) === -1) {
            plugins.push(plugin);
            localIds[plugin.id] = true;
        }
    }
    return {
        plugins,
        localIds
    };
}
function getOpts(options, all) {
    if (!all && options === false) {
        return null;
    }
    if (options === true) {
        return {};
    }
    return options;
}
function createDescriptors(chart, { plugins , localIds  }, options, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin of plugins){
        const id = plugin.id;
        const opts = getOpts(options[id], all);
        if (opts === null) {
            continue;
        }
        result.push({
            plugin,
            options: pluginOpts(chart.config, {
                plugin,
                local: localIds[id]
            }, opts, context)
        });
    }
    return result;
}
function pluginOpts(config, { plugin , local  }, opts, context) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) {
        scopes.push(plugin.defaults);
    }
    return config.createResolver(scopes, context, [
        ''
    ], {
        scriptable: false,
        indexable: false,
        allKeys: true
    });
}

function getIndexAxis(type, options) {
    const datasetDefaults = defaults.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
}
function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === '_index_') {
        axis = indexAxis;
    } else if (id === '_value_') {
        axis = indexAxis === 'x' ? 'y' : 'x';
    }
    return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? '_index_' : '_value_';
}
function idMatchesAxis(id) {
    if (id === 'x' || id === 'y' || id === 'r') {
        return id;
    }
}
function axisFromPosition(position) {
    if (position === 'top' || position === 'bottom') {
        return 'x';
    }
    if (position === 'left' || position === 'right') {
        return 'y';
    }
}
function determineAxis(id, ...scaleOptions) {
    if (idMatchesAxis(id)) {
        return id;
    }
    for (const opts of scaleOptions){
        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
        if (axis) {
            return axis;
        }
    }
    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
    if (dataset[axis + 'AxisID'] === id) {
        return {
            axis
        };
    }
}
function retrieveAxisFromDatasets(id, config) {
    if (config.data && config.data.datasets) {
        const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);
        if (boundDs.length) {
            return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);
        }
    }
    return {};
}
function mergeScaleConfig(config, options) {
    const chartDefaults = overrides[config.type] || {
        scales: {}
    };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const scales = Object.create(null);
    Object.keys(configScales).forEach((id)=>{
        const scaleConf = configScales[id];
        if (!isObject(scaleConf)) {
            return console.error(`Invalid scale configuration for scale: ${id}`);
        }
        if (scaleConf._proxy) {
            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
        }
        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
        const defaultScaleOptions = chartDefaults.scales || {};
        scales[id] = mergeIf(Object.create(null), [
            {
                axis
            },
            scaleConf,
            defaultScaleOptions[axis],
            defaultScaleOptions[defaultId]
        ]);
    });
    config.data.datasets.forEach((dataset)=>{
        const type = dataset.type || config.type;
        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
        const datasetDefaults = overrides[type] || {};
        const defaultScaleOptions = datasetDefaults.scales || {};
        Object.keys(defaultScaleOptions).forEach((defaultID)=>{
            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
            const id = dataset[axis + 'AxisID'] || axis;
            scales[id] = scales[id] || Object.create(null);
            mergeIf(scales[id], [
                {
                    axis
                },
                configScales[id],
                defaultScaleOptions[defaultID]
            ]);
        });
    });
    Object.keys(scales).forEach((key)=>{
        const scale = scales[key];
        mergeIf(scale, [
            defaults.scales[scale.type],
            defaults.scale
        ]);
    });
    return scales;
}
function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
}
function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
}
const keyCache = new Map();
const keysCached = new Set();
function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
        keys = generate();
        keyCache.set(cacheKey, keys);
        keysCached.add(keys);
    }
    return keys;
}
const addIfFound = (set, obj, key)=>{
    const opts = resolveObjectKey(obj, key);
    if (opts !== undefined) {
        set.add(opts);
    }
};
class Config {
    constructor(config){
        this._config = initConfig(config);
        this._scopeCache = new Map();
        this._resolverCache = new Map();
    }
    get platform() {
        return this._config.platform;
    }
    get type() {
        return this._config.type;
    }
    set type(type) {
        this._config.type = type;
    }
    get data() {
        return this._config.data;
    }
    set data(data) {
        this._config.data = initData(data);
    }
    get options() {
        return this._config.options;
    }
    set options(options) {
        this._config.options = options;
    }
    get plugins() {
        return this._config.plugins;
    }
    update() {
        const config = this._config;
        this.clearCache();
        initOptions(config);
    }
    clearCache() {
        this._scopeCache.clear();
        this._resolverCache.clear();
    }
 datasetScopeKeys(datasetType) {
        return cachedKeys(datasetType, ()=>[
                [
                    `datasets.${datasetType}`,
                    ''
                ]
            ]);
    }
 datasetAnimationScopeKeys(datasetType, transition) {
        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[
                [
                    `datasets.${datasetType}.transitions.${transition}`,
                    `transitions.${transition}`
                ],
                [
                    `datasets.${datasetType}`,
                    ''
                ]
            ]);
    }
 datasetElementScopeKeys(datasetType, elementType) {
        return cachedKeys(`${datasetType}-${elementType}`, ()=>[
                [
                    `datasets.${datasetType}.elements.${elementType}`,
                    `datasets.${datasetType}`,
                    `elements.${elementType}`,
                    ''
                ]
            ]);
    }
 pluginScopeKeys(plugin) {
        const id = plugin.id;
        const type = this.type;
        return cachedKeys(`${type}-plugin-${id}`, ()=>[
                [
                    `plugins.${id}`,
                    ...plugin.additionalOptionScopes || []
                ]
            ]);
    }
 _cachedScopes(mainScope, resetCache) {
        const _scopeCache = this._scopeCache;
        let cache = _scopeCache.get(mainScope);
        if (!cache || resetCache) {
            cache = new Map();
            _scopeCache.set(mainScope, cache);
        }
        return cache;
    }
 getOptionScopes(mainScope, keyLists, resetCache) {
        const { options , type  } = this;
        const cache = this._cachedScopes(mainScope, resetCache);
        const cached = cache.get(keyLists);
        if (cached) {
            return cached;
        }
        const scopes = new Set();
        keyLists.forEach((keys)=>{
            if (mainScope) {
                scopes.add(mainScope);
                keys.forEach((key)=>addIfFound(scopes, mainScope, key));
            }
            keys.forEach((key)=>addIfFound(scopes, options, key));
            keys.forEach((key)=>addIfFound(scopes, overrides[type] || {}, key));
            keys.forEach((key)=>addIfFound(scopes, defaults, key));
            keys.forEach((key)=>addIfFound(scopes, descriptors, key));
        });
        const array = Array.from(scopes);
        if (array.length === 0) {
            array.push(Object.create(null));
        }
        if (keysCached.has(keyLists)) {
            cache.set(keyLists, array);
        }
        return array;
    }
 chartOptionScopes() {
        const { options , type  } = this;
        return [
            options,
            overrides[type] || {},
            defaults.datasets[type] || {},
            {
                type
            },
            defaults,
            descriptors
        ];
    }
 resolveNamedOptions(scopes, names, context, prefixes = [
        ''
    ]) {
        const result = {
            $shared: true
        };
        const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);
        let options = resolver;
        if (needContext(resolver, names)) {
            result.$shared = false;
            context = isFunction(context) ? context() : context;
            const subResolver = this.createResolver(scopes, context, subPrefixes);
            options = _attachContext(resolver, context, subResolver);
        }
        for (const prop of names){
            result[prop] = options[prop];
        }
        return result;
    }
 createResolver(scopes, context, prefixes = [
        ''
    ], descriptorDefaults) {
        const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);
        return isObject(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;
    }
}
function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
        cache = new Map();
        resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
        const resolver = _createResolver(scopes, prefixes);
        cached = {
            resolver,
            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))
        };
        cache.set(cacheKey, cached);
    }
    return cached;
}
const hasFunction = (value)=>isObject(value) && Object.getOwnPropertyNames(value).some((key)=>isFunction(value[key]));
function needContext(proxy, names) {
    const { isScriptable , isIndexable  } = _descriptors(proxy);
    for (const prop of names){
        const scriptable = isScriptable(prop);
        const indexable = isIndexable(prop);
        const value = (indexable || scriptable) && proxy[prop];
        if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
            return true;
        }
    }
    return false;
}

var version = "4.4.9";

const KNOWN_POSITIONS = [
    'top',
    'bottom',
    'left',
    'right',
    'chartArea'
];
function positionIsHorizontal(position, axis) {
    return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';
}
function compare2Level(l1, l2) {
    return function(a, b) {
        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
}
function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins('afterRender');
    callback(animationOptions && animationOptions.onComplete, [
        context
    ], chart);
}
function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    callback(animationOptions && animationOptions.onProgress, [
        context
    ], chart);
}
 function getCanvas(item) {
    if (_isDomSupported() && typeof item === 'string') {
        item = document.getElementById(item);
    } else if (item && item.length) {
        item = item[0];
    }
    if (item && item.canvas) {
        item = item.canvas;
    }
    return item;
}
const instances = {};
const getChart = (key)=>{
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
    const keys = Object.keys(obj);
    for (const key of keys){
        const intKey = +key;
        if (intKey >= start) {
            const value = obj[key];
            delete obj[key];
            if (move > 0 || intKey > start) {
                obj[intKey + move] = value;
            }
        }
    }
}
 function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === 'mouseout') {
        return null;
    }
    if (isClick) {
        return lastEvent;
    }
    return e;
}
class Chart {
    static defaults = defaults;
    static instances = instances;
    static overrides = overrides;
    static registry = registry;
    static version = version;
    static getChart = getChart;
    static register(...items) {
        registry.add(...items);
        invalidatePlugins();
    }
    static unregister(...items) {
        registry.remove(...items);
        invalidatePlugins();
    }
    constructor(item, userConfig){
        const config = this.config = new Config(userConfig);
        const initialCanvas = getCanvas(item);
        const existingChart = getChart(initialCanvas);
        if (existingChart) {
            throw new Error('Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' + ' must be destroyed before the canvas with ID \'' + existingChart.canvas.id + '\' can be reused.');
        }
        const options = config.createResolver(config.chartOptionScopes(), this.getContext());
        this.platform = new (config.platform || _detectPlatform(initialCanvas))();
        this.platform.updateConfig(config);
        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
        const canvas = context && context.canvas;
        const height = canvas && canvas.height;
        const width = canvas && canvas.width;
        this.id = uid();
        this.ctx = context;
        this.canvas = canvas;
        this.width = width;
        this.height = height;
        this._options = options;
        this._aspectRatio = this.aspectRatio;
        this._layers = [];
        this._metasets = [];
        this._stacks = undefined;
        this.boxes = [];
        this.currentDevicePixelRatio = undefined;
        this.chartArea = undefined;
        this._active = [];
        this._lastEvent = undefined;
        this._listeners = {};
         this._responsiveListeners = undefined;
        this._sortedMetasets = [];
        this.scales = {};
        this._plugins = new PluginService();
        this.$proxies = {};
        this._hiddenIndices = {};
        this.attached = false;
        this._animationsDisabled = undefined;
        this.$context = undefined;
        this._doResize = debounce((mode)=>this.update(mode), options.resizeDelay || 0);
        this._dataChanges = [];
        instances[this.id] = this;
        if (!context || !canvas) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
        }
        animator.listen(this, 'complete', onAnimationsComplete);
        animator.listen(this, 'progress', onAnimationProgress);
        this._initialize();
        if (this.attached) {
            this.update();
        }
    }
    get aspectRatio() {
        const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;
        if (!isNullOrUndef(aspectRatio)) {
            return aspectRatio;
        }
        if (maintainAspectRatio && _aspectRatio) {
            return _aspectRatio;
        }
        return height ? width / height : null;
    }
    get data() {
        return this.config.data;
    }
    set data(data) {
        this.config.data = data;
    }
    get options() {
        return this._options;
    }
    set options(options) {
        this.config.options = options;
    }
    get registry() {
        return registry;
    }
 _initialize() {
        this.notifyPlugins('beforeInit');
        if (this.options.responsive) {
            this.resize();
        } else {
            retinaScale(this, this.options.devicePixelRatio);
        }
        this.bindEvents();
        this.notifyPlugins('afterInit');
        return this;
    }
    clear() {
        clearCanvas(this.canvas, this.ctx);
        return this;
    }
    stop() {
        animator.stop(this);
        return this;
    }
 resize(width, height) {
        if (!animator.running(this)) {
            this._resize(width, height);
        } else {
            this._resizeBeforeDraw = {
                width,
                height
            };
        }
    }
    _resize(width, height) {
        const options = this.options;
        const canvas = this.canvas;
        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
        const mode = this.width ? 'resize' : 'attach';
        this.width = newSize.width;
        this.height = newSize.height;
        this._aspectRatio = this.aspectRatio;
        if (!retinaScale(this, newRatio, true)) {
            return;
        }
        this.notifyPlugins('resize', {
            size: newSize
        });
        callback(options.onResize, [
            this,
            newSize
        ], this);
        if (this.attached) {
            if (this._doResize(mode)) {
                this.render();
            }
        }
    }
    ensureScalesHaveIDs() {
        const options = this.options;
        const scalesOptions = options.scales || {};
        each(scalesOptions, (axisOptions, axisID)=>{
            axisOptions.id = axisID;
        });
    }
 buildOrUpdateScales() {
        const options = this.options;
        const scaleOpts = options.scales;
        const scales = this.scales;
        const updated = Object.keys(scales).reduce((obj, id)=>{
            obj[id] = false;
            return obj;
        }, {});
        let items = [];
        if (scaleOpts) {
            items = items.concat(Object.keys(scaleOpts).map((id)=>{
                const scaleOptions = scaleOpts[id];
                const axis = determineAxis(id, scaleOptions);
                const isRadial = axis === 'r';
                const isHorizontal = axis === 'x';
                return {
                    options: scaleOptions,
                    dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
                    dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
                };
            }));
        }
        each(items, (item)=>{
            const scaleOptions = item.options;
            const id = scaleOptions.id;
            const axis = determineAxis(id, scaleOptions);
            const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
                scaleOptions.position = item.dposition;
            }
            updated[id] = true;
            let scale = null;
            if (id in scales && scales[id].type === scaleType) {
                scale = scales[id];
            } else {
                const scaleClass = registry.getScale(scaleType);
                scale = new scaleClass({
                    id,
                    type: scaleType,
                    ctx: this.ctx,
                    chart: this
                });
                scales[scale.id] = scale;
            }
            scale.init(scaleOptions, options);
        });
        each(updated, (hasUpdated, id)=>{
            if (!hasUpdated) {
                delete scales[id];
            }
        });
        each(scales, (scale)=>{
            layouts.configure(this, scale, scale.options);
            layouts.addBox(this, scale);
        });
    }
 _updateMetasets() {
        const metasets = this._metasets;
        const numData = this.data.datasets.length;
        const numMeta = metasets.length;
        metasets.sort((a, b)=>a.index - b.index);
        if (numMeta > numData) {
            for(let i = numData; i < numMeta; ++i){
                this._destroyDatasetMeta(i);
            }
            metasets.splice(numData, numMeta - numData);
        }
        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
    }
 _removeUnreferencedMetasets() {
        const { _metasets: metasets , data: { datasets  }  } = this;
        if (metasets.length > datasets.length) {
            delete this._stacks;
        }
        metasets.forEach((meta, index)=>{
            if (datasets.filter((x)=>x === meta._dataset).length === 0) {
                this._destroyDatasetMeta(index);
            }
        });
    }
    buildOrUpdateControllers() {
        const newControllers = [];
        const datasets = this.data.datasets;
        let i, ilen;
        this._removeUnreferencedMetasets();
        for(i = 0, ilen = datasets.length; i < ilen; i++){
            const dataset = datasets[i];
            let meta = this.getDatasetMeta(i);
            const type = dataset.type || this.config.type;
            if (meta.type && meta.type !== type) {
                this._destroyDatasetMeta(i);
                meta = this.getDatasetMeta(i);
            }
            meta.type = type;
            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
            meta.order = dataset.order || 0;
            meta.index = i;
            meta.label = '' + dataset.label;
            meta.visible = this.isDatasetVisible(i);
            if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
            } else {
                const ControllerClass = registry.getController(type);
                const { datasetElementType , dataElementType  } = defaults.datasets[type];
                Object.assign(ControllerClass, {
                    dataElementType: registry.getElement(dataElementType),
                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                });
                meta.controller = new ControllerClass(this, i);
                newControllers.push(meta.controller);
            }
        }
        this._updateMetasets();
        return newControllers;
    }
 _resetElements() {
        each(this.data.datasets, (dataset, datasetIndex)=>{
            this.getDatasetMeta(datasetIndex).controller.reset();
        }, this);
    }
 reset() {
        this._resetElements();
        this.notifyPlugins('reset');
    }
    update(mode) {
        const config = this.config;
        config.update();
        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
        const animsDisabled = this._animationsDisabled = !options.animation;
        this._updateScales();
        this._checkEventBindings();
        this._updateHiddenIndices();
        this._plugins.invalidate();
        if (this.notifyPlugins('beforeUpdate', {
            mode,
            cancelable: true
        }) === false) {
            return;
        }
        const newControllers = this.buildOrUpdateControllers();
        this.notifyPlugins('beforeElementsUpdate');
        let minPadding = 0;
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){
            const { controller  } = this.getDatasetMeta(i);
            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
            controller.buildOrUpdateElements(reset);
            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
        }
        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
        this._updateLayout(minPadding);
        if (!animsDisabled) {
            each(newControllers, (controller)=>{
                controller.reset();
            });
        }
        this._updateDatasets(mode);
        this.notifyPlugins('afterUpdate', {
            mode
        });
        this._layers.sort(compare2Level('z', '_idx'));
        const { _active , _lastEvent  } = this;
        if (_lastEvent) {
            this._eventHandler(_lastEvent, true);
        } else if (_active.length) {
            this._updateHoverStyles(_active, _active, true);
        }
        this.render();
    }
 _updateScales() {
        each(this.scales, (scale)=>{
            layouts.removeBox(this, scale);
        });
        this.ensureScalesHaveIDs();
        this.buildOrUpdateScales();
    }
 _checkEventBindings() {
        const options = this.options;
        const existingEvents = new Set(Object.keys(this._listeners));
        const newEvents = new Set(options.events);
        if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
            this.unbindEvents();
            this.bindEvents();
        }
    }
 _updateHiddenIndices() {
        const { _hiddenIndices  } = this;
        const changes = this._getUniformDataChanges() || [];
        for (const { method , start , count  } of changes){
            const move = method === '_removeElements' ? -count : count;
            moveNumericKeys(_hiddenIndices, start, move);
        }
    }
 _getUniformDataChanges() {
        const _dataChanges = this._dataChanges;
        if (!_dataChanges || !_dataChanges.length) {
            return;
        }
        this._dataChanges = [];
        const datasetCount = this.data.datasets.length;
        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));
        const changeSet = makeSet(0);
        for(let i = 1; i < datasetCount; i++){
            if (!setsEqual(changeSet, makeSet(i))) {
                return;
            }
        }
        return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({
                method: a[1],
                start: +a[2],
                count: +a[3]
            }));
    }
 _updateLayout(minPadding) {
        if (this.notifyPlugins('beforeLayout', {
            cancelable: true
        }) === false) {
            return;
        }
        layouts.update(this, this.width, this.height, minPadding);
        const area = this.chartArea;
        const noArea = area.width <= 0 || area.height <= 0;
        this._layers = [];
        each(this.boxes, (box)=>{
            if (noArea && box.position === 'chartArea') {
                return;
            }
            if (box.configure) {
                box.configure();
            }
            this._layers.push(...box._layers());
        }, this);
        this._layers.forEach((item, index)=>{
            item._idx = index;
        });
        this.notifyPlugins('afterLayout');
    }
 _updateDatasets(mode) {
        if (this.notifyPlugins('beforeDatasetsUpdate', {
            mode,
            cancelable: true
        }) === false) {
            return;
        }
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
            this.getDatasetMeta(i).controller.configure();
        }
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
            this._updateDataset(i, isFunction(mode) ? mode({
                datasetIndex: i
            }) : mode);
        }
        this.notifyPlugins('afterDatasetsUpdate', {
            mode
        });
    }
 _updateDataset(index, mode) {
        const meta = this.getDatasetMeta(index);
        const args = {
            meta,
            index,
            mode,
            cancelable: true
        };
        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
            return;
        }
        meta.controller._update(mode);
        args.cancelable = false;
        this.notifyPlugins('afterDatasetUpdate', args);
    }
    render() {
        if (this.notifyPlugins('beforeRender', {
            cancelable: true
        }) === false) {
            return;
        }
        if (animator.has(this)) {
            if (this.attached && !animator.running(this)) {
                animator.start(this);
            }
        } else {
            this.draw();
            onAnimationsComplete({
                chart: this
            });
        }
    }
    draw() {
        let i;
        if (this._resizeBeforeDraw) {
            const { width , height  } = this._resizeBeforeDraw;
            this._resizeBeforeDraw = null;
            this._resize(width, height);
        }
        this.clear();
        if (this.width <= 0 || this.height <= 0) {
            return;
        }
        if (this.notifyPlugins('beforeDraw', {
            cancelable: true
        }) === false) {
            return;
        }
        const layers = this._layers;
        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){
            layers[i].draw(this.chartArea);
        }
        this._drawDatasets();
        for(; i < layers.length; ++i){
            layers[i].draw(this.chartArea);
        }
        this.notifyPlugins('afterDraw');
    }
 _getSortedDatasetMetas(filterVisible) {
        const metasets = this._sortedMetasets;
        const result = [];
        let i, ilen;
        for(i = 0, ilen = metasets.length; i < ilen; ++i){
            const meta = metasets[i];
            if (!filterVisible || meta.visible) {
                result.push(meta);
            }
        }
        return result;
    }
 getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(true);
    }
 _drawDatasets() {
        if (this.notifyPlugins('beforeDatasetsDraw', {
            cancelable: true
        }) === false) {
            return;
        }
        const metasets = this.getSortedVisibleDatasetMetas();
        for(let i = metasets.length - 1; i >= 0; --i){
            this._drawDataset(metasets[i]);
        }
        this.notifyPlugins('afterDatasetsDraw');
    }
 _drawDataset(meta) {
        const ctx = this.ctx;
        const args = {
            meta,
            index: meta.index,
            cancelable: true
        };
        const clip = getDatasetClipArea(this, meta);
        if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
            return;
        }
        if (clip) {
            clipArea(ctx, clip);
        }
        meta.controller.draw();
        if (clip) {
            unclipArea(ctx);
        }
        args.cancelable = false;
        this.notifyPlugins('afterDatasetDraw', args);
    }
 isPointInArea(point) {
        return _isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e, mode, options, useFinalPosition) {
        const method = Interaction.modes[mode];
        if (typeof method === 'function') {
            return method(this, e, options, useFinalPosition);
        }
        return [];
    }
    getDatasetMeta(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        const metasets = this._metasets;
        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();
        if (!meta) {
            meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset && dataset.order || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: false
            };
            metasets.push(meta);
        }
        return meta;
    }
    getContext() {
        return this.$context || (this.$context = createContext(null, {
            chart: this,
            type: 'chart'
        }));
    }
    getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        if (!dataset) {
            return false;
        }
        const meta = this.getDatasetMeta(datasetIndex);
        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
        const meta = this.getDatasetMeta(datasetIndex);
        meta.hidden = !visible;
    }
    toggleDataVisibility(index) {
        this._hiddenIndices[index] = !this._hiddenIndices[index];
    }
    getDataVisibility(index) {
        return !this._hiddenIndices[index];
    }
 _updateVisibility(datasetIndex, dataIndex, visible) {
        const mode = visible ? 'show' : 'hide';
        const meta = this.getDatasetMeta(datasetIndex);
        const anims = meta.controller._resolveAnimations(undefined, mode);
        if (defined(dataIndex)) {
            meta.data[dataIndex].hidden = !visible;
            this.update();
        } else {
            this.setDatasetVisibility(datasetIndex, visible);
            anims.update(meta, {
                visible
            });
            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);
        }
    }
    hide(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, true);
    }
 _destroyDatasetMeta(datasetIndex) {
        const meta = this._metasets[datasetIndex];
        if (meta && meta.controller) {
            meta.controller._destroy();
        }
        delete this._metasets[datasetIndex];
    }
    _stop() {
        let i, ilen;
        this.stop();
        animator.remove(this);
        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
            this._destroyDatasetMeta(i);
        }
    }
    destroy() {
        this.notifyPlugins('beforeDestroy');
        const { canvas , ctx  } = this;
        this._stop();
        this.config.clearCache();
        if (canvas) {
            this.unbindEvents();
            clearCanvas(canvas, ctx);
            this.platform.releaseContext(ctx);
            this.canvas = null;
            this.ctx = null;
        }
        delete instances[this.id];
        this.notifyPlugins('afterDestroy');
    }
    toBase64Image(...args) {
        return this.canvas.toDataURL(...args);
    }
 bindEvents() {
        this.bindUserEvents();
        if (this.options.responsive) {
            this.bindResponsiveEvents();
        } else {
            this.attached = true;
        }
    }
 bindUserEvents() {
        const listeners = this._listeners;
        const platform = this.platform;
        const _add = (type, listener)=>{
            platform.addEventListener(this, type, listener);
            listeners[type] = listener;
        };
        const listener = (e, x, y)=>{
            e.offsetX = x;
            e.offsetY = y;
            this._eventHandler(e);
        };
        each(this.options.events, (type)=>_add(type, listener));
    }
 bindResponsiveEvents() {
        if (!this._responsiveListeners) {
            this._responsiveListeners = {};
        }
        const listeners = this._responsiveListeners;
        const platform = this.platform;
        const _add = (type, listener)=>{
            platform.addEventListener(this, type, listener);
            listeners[type] = listener;
        };
        const _remove = (type, listener)=>{
            if (listeners[type]) {
                platform.removeEventListener(this, type, listener);
                delete listeners[type];
            }
        };
        const listener = (width, height)=>{
            if (this.canvas) {
                this.resize(width, height);
            }
        };
        let detached;
        const attached = ()=>{
            _remove('attach', attached);
            this.attached = true;
            this.resize();
            _add('resize', listener);
            _add('detach', detached);
        };
        detached = ()=>{
            this.attached = false;
            _remove('resize', listener);
            this._stop();
            this._resize(0, 0);
            _add('attach', attached);
        };
        if (platform.isAttached(this.canvas)) {
            attached();
        } else {
            detached();
        }
    }
 unbindEvents() {
        each(this._listeners, (listener, type)=>{
            this.platform.removeEventListener(this, type, listener);
        });
        this._listeners = {};
        each(this._responsiveListeners, (listener, type)=>{
            this.platform.removeEventListener(this, type, listener);
        });
        this._responsiveListeners = undefined;
    }
    updateHoverStyle(items, mode, enabled) {
        const prefix = enabled ? 'set' : 'remove';
        let meta, item, i, ilen;
        if (mode === 'dataset') {
            meta = this.getDatasetMeta(items[0].datasetIndex);
            meta.controller['_' + prefix + 'DatasetHoverStyle']();
        }
        for(i = 0, ilen = items.length; i < ilen; ++i){
            item = items[i];
            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
            if (controller) {
                controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
            }
        }
    }
 getActiveElements() {
        return this._active || [];
    }
 setActiveElements(activeElements) {
        const lastActive = this._active || [];
        const active = activeElements.map(({ datasetIndex , index  })=>{
            const meta = this.getDatasetMeta(datasetIndex);
            if (!meta) {
                throw new Error('No dataset found at index ' + datasetIndex);
            }
            return {
                datasetIndex,
                element: meta.data[index],
                index
            };
        });
        const changed = !_elementsEqual(active, lastActive);
        if (changed) {
            this._active = active;
            this._lastEvent = null;
            this._updateHoverStyles(active, lastActive);
        }
    }
 notifyPlugins(hook, args, filter) {
        return this._plugins.notify(this, hook, args, filter);
    }
 isPluginEnabled(pluginId) {
        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;
    }
 _updateHoverStyles(active, lastActive, replay) {
        const hoverOptions = this.options.hover;
        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));
        const deactivated = diff(lastActive, active);
        const activated = replay ? active : diff(active, lastActive);
        if (deactivated.length) {
            this.updateHoverStyle(deactivated, hoverOptions.mode, false);
        }
        if (activated.length && hoverOptions.mode) {
            this.updateHoverStyle(activated, hoverOptions.mode, true);
        }
    }
 _eventHandler(e, replay) {
        const args = {
            event: e,
            replay,
            cancelable: true,
            inChartArea: this.isPointInArea(e)
        };
        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);
        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {
            return;
        }
        const changed = this._handleEvent(e, replay, args.inChartArea);
        args.cancelable = false;
        this.notifyPlugins('afterEvent', args, eventFilter);
        if (changed || args.changed) {
            this.render();
        }
        return this;
    }
 _handleEvent(e, replay, inChartArea) {
        const { _active: lastActive = [] , options  } = this;
        const useFinalPosition = replay;
        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
        const isClick = _isClickEvent(e);
        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
        if (inChartArea) {
            this._lastEvent = null;
            callback(options.onHover, [
                e,
                active,
                this
            ], this);
            if (isClick) {
                callback(options.onClick, [
                    e,
                    active,
                    this
                ], this);
            }
        }
        const changed = !_elementsEqual(active, lastActive);
        if (changed || replay) {
            this._active = active;
            this._updateHoverStyles(active, lastActive, replay);
        }
        this._lastEvent = lastEvent;
        return changed;
    }
 _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
        if (e.type === 'mouseout') {
            return [];
        }
        if (!inChartArea) {
            return lastActive;
        }
        const hoverOptions = this.options.hover;
        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
}
function invalidatePlugins() {
    return each(Chart.instances, (chart)=>chart._plugins.invalidate());
}

function clipArc(ctx, element, endAngle) {
    const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;
    let angleMargin = pixelMargin / outerRadius;
    // Draw an inner border by clipping the arc and drawing a double-width border
    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
        angleMargin = pixelMargin / innerRadius;
        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
        ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
}
function toRadiusCorners(value) {
    return _readValueToProps(value, [
        'outerStart',
        'outerEnd',
        'innerStart',
        'innerEnd'
    ]);
}
/**
 * Parse border radius from the provided options
 */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    // Outer limits are complicated. We want to compute the available angular distance at
    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.
    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.
    //
    // If the borderRadius is large, that value can become negative.
    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius
    // we know that the thickness term will dominate and compute the limits at that point
    const computeOuterLimit = (val)=>{
        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
        return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
        outerStart: computeOuterLimit(o.outerStart),
        outerEnd: computeOuterLimit(o.outerEnd),
        innerStart: _limitValue(o.innerStart, 0, innerLimit),
        innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
    };
}
/**
 * Convert (r, 𝜃) to (x, y)
 */ function rThetaToXY(r, theta, x, y) {
    return {
        x: x + r * Math.cos(theta),
        y: y + r * Math.sin(theta)
    };
}
/**
 * Path the arc, respecting border radius by separating into left and right halves.
 *
 *   Start      End
 *
 *    1--->a--->2    Outer
 *   /           \
 *   8           3
 *   |           |
 *   |           |
 *   7           4
 *   \           /
 *    6<---b<---5    Inner
 */ function pathArc(ctx, element, offset, spacing, end, circular) {
    const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha = end - start;
    if (spacing) {
        // When spacing is present, it is the same for all items
        // So we adjust the start and end angle of the arc such that
        // the distance is the same as it would be without the spacing
        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
        spacingOffset = (alpha - adjustedAngle) / 2;
    }
    const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;
    const angleOffset = (alpha - beta) / 2;
    const startAngle = start + angleOffset + spacingOffset;
    const endAngle = end - angleOffset - spacingOffset;
    const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
        // The first arc segments from point 1 to point a to point 2
        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
        // The corner segment from point 2 to point 3
        if (outerEnd > 0) {
            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
        }
        // The line from point 3 to point 4
        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
        ctx.lineTo(p4.x, p4.y);
        // The corner segment from point 4 to point 5
        if (innerEnd > 0) {
            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
        }
        // The inner arc from point 5 to point b to point 6
        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
        // The corner segment from point 6 to point 7
        if (innerStart > 0) {
            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
        }
        // The line from point 7 to point 8
        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
        ctx.lineTo(p8.x, p8.y);
        // The corner segment from point 8 to point 1
        if (outerStart > 0) {
            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
        }
    } else {
        ctx.moveTo(x, y);
        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
        ctx.lineTo(outerStartX, outerStartY);
        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
        ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
    const { fullCircles , startAngle , circumference  } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        for(let i = 0; i < fullCircles; ++i){
            ctx.fill();
        }
        if (!isNaN(circumference)) {
            endAngle = startAngle + (circumference % TAU || TAU);
        }
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
    const { fullCircles , startAngle , circumference , options  } = element;
    const { borderWidth , borderJoinStyle , borderDash , borderDashOffset  } = options;
    const inner = options.borderAlign === 'inner';
    if (!borderWidth) {
        return;
    }
    ctx.setLineDash(borderDash || []);
    ctx.lineDashOffset = borderDashOffset;
    if (inner) {
        ctx.lineWidth = borderWidth * 2;
        ctx.lineJoin = borderJoinStyle || 'round';
    } else {
        ctx.lineWidth = borderWidth;
        ctx.lineJoin = borderJoinStyle || 'bevel';
    }
    let endAngle = element.endAngle;
    if (fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        for(let i = 0; i < fullCircles; ++i){
            ctx.stroke();
        }
        if (!isNaN(circumference)) {
            endAngle = startAngle + (circumference % TAU || TAU);
        }
    }
    if (inner) {
        clipArc(ctx, element, endAngle);
    }
    if (!fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        ctx.stroke();
    }
}
class ArcElement extends Element$1 {
    static id = 'arc';
    static defaults = {
        borderAlign: 'center',
        borderColor: '#fff',
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: undefined,
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: undefined,
        circular: true
    };
    static defaultRoutes = {
        backgroundColor: 'backgroundColor'
    };
    static descriptors = {
        _scriptable: true,
        _indexable: (name)=>name !== 'borderDash'
    };
    circumference;
    endAngle;
    fullCircles;
    innerRadius;
    outerRadius;
    pixelMargin;
    startAngle;
    constructor(cfg){
        super();
        this.options = undefined;
        this.circumference = undefined;
        this.startAngle = undefined;
        this.endAngle = undefined;
        this.innerRadius = undefined;
        this.outerRadius = undefined;
        this.pixelMargin = 0;
        this.fullCircles = 0;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    inRange(chartX, chartY, useFinalPosition) {
        const point = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        const { angle , distance  } = getAngleFromPoint(point, {
            x: chartX,
            y: chartY
        });
        const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([
            'startAngle',
            'endAngle',
            'innerRadius',
            'outerRadius',
            'circumference'
        ], useFinalPosition);
        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
        const _circumference = valueOrDefault(circumference, endAngle - startAngle);
        const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
        const betweenAngles = _circumference >= TAU || nonZeroBetween;
        const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
        return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
        const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([
            'x',
            'y',
            'startAngle',
            'endAngle',
            'innerRadius',
            'outerRadius'
        ], useFinalPosition);
        const { offset , spacing  } = this.options;
        const halfAngle = (startAngle + endAngle) / 2;
        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
        return {
            x: x + Math.cos(halfAngle) * halfRadius,
            y: y + Math.sin(halfAngle) * halfRadius
        };
    }
    tooltipPosition(useFinalPosition) {
        return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
        const { options , circumference  } = this;
        const offset = (options.offset || 0) / 4;
        const spacing = (options.spacing || 0) / 2;
        const circular = options.circular;
        this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;
        this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
            return;
        }
        ctx.save();
        const halfAngle = (this.startAngle + this.endAngle) / 2;
        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
        const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
        const radiusOffset = offset * fix;
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        drawArc(ctx, this, radiusOffset, spacing, circular);
        drawBorder(ctx, this, radiusOffset, spacing, circular);
        ctx.restore();
    }
}

function setStyle(ctx, options, style = options) {
    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
}
 function getLineMethod(options) {
    if (options.stepped) {
        return _steppedLineTo;
    }
    if (options.tension || options.cubicInterpolationMode === 'monotone') {
        return _bezierCurveTo;
    }
    return lineTo;
}
function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;
    const { start: segmentStart , end: segmentEnd  } = segment;
    const start = Math.max(paramsStart, segmentStart);
    const end = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
        count,
        start,
        loop: segment.loop,
        ilen: end < start && !outside ? count + end - start : end - start
    };
}
 function pathSegment(ctx, line, segment, params) {
    const { points , options  } = line;
    const { count , start , loop , ilen  } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move =true , reverse  } = params || {};
    let i, point, prev;
    for(i = 0; i <= ilen; ++i){
        point = points[(start + (reverse ? ilen - i : i)) % count];
        if (point.skip) {
            continue;
        } else if (move) {
            ctx.moveTo(point.x, point.y);
            move = false;
        } else {
            lineMethod(ctx, prev, point, reverse, options.stepped);
        }
        prev = point;
    }
    if (loop) {
        point = points[(start + (reverse ? ilen : 0)) % count];
        lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
}
 function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count , start , ilen  } = pathVars(points, segment, params);
    const { move =true , reverse  } = params || {};
    let avgX = 0;
    let countX = 0;
    let i, point, prevX, minY, maxY, lastY;
    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;
    const drawX = ()=>{
        if (minY !== maxY) {
            ctx.lineTo(avgX, maxY);
            ctx.lineTo(avgX, minY);
            ctx.lineTo(avgX, lastY);
        }
    };
    if (move) {
        point = points[pointIndex(0)];
        ctx.moveTo(point.x, point.y);
    }
    for(i = 0; i <= ilen; ++i){
        point = points[pointIndex(i)];
        if (point.skip) {
            continue;
        }
        const x = point.x;
        const y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
            if (y < minY) {
                minY = y;
            } else if (y > maxY) {
                maxY = y;
            }
            avgX = (countX * avgX + x) / ++countX;
        } else {
            drawX();
            ctx.lineTo(x, y);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
        }
        lastY = y;
    }
    drawX();
}
 function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
}
 function _getInterpolationMethod(options) {
    if (options.stepped) {
        return _steppedInterpolation;
    }
    if (options.tension || options.cubicInterpolationMode === 'monotone') {
        return _bezierInterpolation;
    }
    return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
    let path = line._path;
    if (!path) {
        path = line._path = new Path2D();
        if (line.path(path, start, count)) {
            path.closePath();
        }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
    const { segments , options  } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments){
        setStyle(ctx, options, segment.style);
        ctx.beginPath();
        if (segmentMethod(ctx, line, segment, {
            start,
            end: start + count - 1
        })) {
            ctx.closePath();
        }
        ctx.stroke();
    }
}
const usePath2D = typeof Path2D === 'function';
function draw(ctx, line, start, count) {
    if (usePath2D && !line.options.segment) {
        strokePathWithCache(ctx, line, start, count);
    } else {
        strokePathDirect(ctx, line, start, count);
    }
}
class LineElement extends Element$1 {
    static id = 'line';
 static defaults = {
        borderCapStyle: 'butt',
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: 'miter',
        borderWidth: 3,
        capBezierPoints: true,
        cubicInterpolationMode: 'default',
        fill: false,
        spanGaps: false,
        stepped: false,
        tension: 0
    };
 static defaultRoutes = {
        backgroundColor: 'backgroundColor',
        borderColor: 'borderColor'
    };
    static descriptors = {
        _scriptable: true,
        _indexable: (name)=>name !== 'borderDash' && name !== 'fill'
    };
    constructor(cfg){
        super();
        this.animated = true;
        this.options = undefined;
        this._chart = undefined;
        this._loop = undefined;
        this._fullLoop = undefined;
        this._path = undefined;
        this._points = undefined;
        this._segments = undefined;
        this._decimated = false;
        this._pointsUpdated = false;
        this._datasetIndex = undefined;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    updateControlPoints(chartArea, indexAxis) {
        const options = this.options;
        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {
            const loop = options.spanGaps ? this._loop : this._fullLoop;
            _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
            this._pointsUpdated = true;
        }
    }
    set points(points) {
        this._points = points;
        delete this._segments;
        delete this._path;
        this._pointsUpdated = false;
    }
    get points() {
        return this._points;
    }
    get segments() {
        return this._segments || (this._segments = _computeSegments(this, this.options.segment));
    }
 first() {
        const segments = this.segments;
        const points = this.points;
        return segments.length && points[segments[0].start];
    }
 last() {
        const segments = this.segments;
        const points = this.points;
        const count = segments.length;
        return count && points[segments[count - 1].end];
    }
 interpolate(point, property) {
        const options = this.options;
        const value = point[property];
        const points = this.points;
        const segments = _boundSegments(this, {
            property,
            start: value,
            end: value
        });
        if (!segments.length) {
            return;
        }
        const result = [];
        const _interpolate = _getInterpolationMethod(options);
        let i, ilen;
        for(i = 0, ilen = segments.length; i < ilen; ++i){
            const { start , end  } = segments[i];
            const p1 = points[start];
            const p2 = points[end];
            if (p1 === p2) {
                result.push(p1);
                continue;
            }
            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
            const interpolated = _interpolate(p1, p2, t, options.stepped);
            interpolated[property] = point[property];
            result.push(interpolated);
        }
        return result.length === 1 ? result[0] : result;
    }
 pathSegment(ctx, segment, params) {
        const segmentMethod = _getSegmentMethod(this);
        return segmentMethod(ctx, this, segment, params);
    }
 path(ctx, start, count) {
        const segments = this.segments;
        const segmentMethod = _getSegmentMethod(this);
        let loop = this._loop;
        start = start || 0;
        count = count || this.points.length - start;
        for (const segment of segments){
            loop &= segmentMethod(ctx, this, segment, {
                start,
                end: start + count - 1
            });
        }
        return !!loop;
    }
 draw(ctx, chartArea, start, count) {
        const options = this.options || {};
        const points = this.points || [];
        if (points.length && options.borderWidth) {
            ctx.save();
            draw(ctx, this, start, count);
            ctx.restore();
        }
        if (this.animated) {
            this._pointsUpdated = false;
            this._path = undefined;
        }
    }
}

function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value  } = el.getProps([
        axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
}
class PointElement extends Element$1 {
    static id = 'point';
    parsed;
    skip;
    stop;
    /**
   * @type {any}
   */ static defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: 'circle',
        radius: 3,
        rotation: 0
    };
    /**
   * @type {any}
   */ static defaultRoutes = {
        backgroundColor: 'backgroundColor',
        borderColor: 'borderColor'
    };
    constructor(cfg){
        super();
        this.options = undefined;
        this.parsed = undefined;
        this.skip = undefined;
        this.stop = undefined;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
        const options = this.options;
        const { x , y  } = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
        return inRange$1(this, mouseX, 'x', useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
        return inRange$1(this, mouseY, 'y', useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
        const { x , y  } = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        return {
            x,
            y
        };
    }
    size(options) {
        options = options || this.options || {};
        let radius = options.radius || 0;
        radius = Math.max(radius, radius && options.hoverRadius || 0);
        const borderWidth = radius && options.borderWidth || 0;
        return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
        const options = this.options;
        if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
            return;
        }
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.fillStyle = options.backgroundColor;
        drawPoint(ctx, options, this.x, this.y);
    }
    getRange() {
        const options = this.options || {};
        // @ts-expect-error Fallbacks should never be hit in practice
        return options.radius + options.hitRadius;
    }
}

function getBarBounds(bar, useFinalPosition) {
    const { x , y , base , width , height  } =  bar.getProps([
        'x',
        'y',
        'base',
        'width',
        'height'
    ], useFinalPosition);
    let left, right, top, bottom, half;
    if (bar.horizontal) {
        half = height / 2;
        left = Math.min(x, base);
        right = Math.max(x, base);
        top = y - half;
        bottom = y + half;
    } else {
        half = width / 2;
        left = x - half;
        right = x + half;
        top = Math.min(y, base);
        bottom = Math.max(y, base);
    }
    return {
        left,
        top,
        right,
        bottom
    };
}
function skipOrLimit(skip, value, min, max) {
    return skip ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip = bar.borderSkipped;
    const o = toTRBL(value);
    return {
        t: skipOrLimit(skip.top, o.top, 0, maxH),
        r: skipOrLimit(skip.right, o.right, 0, maxW),
        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
        l: skipOrLimit(skip.left, o.left, 0, maxW)
    };
}
function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius  } = bar.getProps([
        'enableBorderRadius'
    ]);
    const value = bar.options.borderRadius;
    const o = toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject(value);
    return {
        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
    };
}
function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
        outer: {
            x: bounds.left,
            y: bounds.top,
            w: width,
            h: height,
            radius
        },
        inner: {
            x: bounds.left + border.l,
            y: bounds.top + border.t,
            w: width - border.l - border.r,
            h: height - border.t - border.b,
            radius: {
                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
            }
        }
    };
}
function inRange(bar, x, y, useFinalPosition) {
    const skipX = x === null;
    const skipY = y === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
 function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
    const x = rect.x !== refRect.x ? -amount : 0;
    const y = rect.y !== refRect.y ? -amount : 0;
    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
    return {
        x: rect.x + x,
        y: rect.y + y,
        w: rect.w + w,
        h: rect.h + h,
        radius: rect.radius
    };
}
class BarElement extends Element$1 {
    static id = 'bar';
 static defaults = {
        borderSkipped: 'start',
        borderWidth: 0,
        borderRadius: 0,
        inflateAmount: 'auto',
        pointStyle: undefined
    };
 static defaultRoutes = {
        backgroundColor: 'backgroundColor',
        borderColor: 'borderColor'
    };
    constructor(cfg){
        super();
        this.options = undefined;
        this.horizontal = undefined;
        this.base = undefined;
        this.width = undefined;
        this.height = undefined;
        this.inflateAmount = undefined;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    draw(ctx) {
        const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;
        const { inner , outer  } = boundingRects(this);
        const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
        ctx.save();
        if (outer.w !== inner.w || outer.h !== inner.h) {
            ctx.beginPath();
            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
            ctx.clip();
            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
            ctx.fillStyle = borderColor;
            ctx.fill('evenodd');
        }
        ctx.beginPath();
        addRectPath(ctx, inflateRect(inner, inflateAmount));
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
        return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
        return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
        return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
        const { x , y , base , horizontal  } =  this.getProps([
            'x',
            'y',
            'base',
            'horizontal'
        ], useFinalPosition);
        return {
            x: horizontal ? (x + base) / 2 : x,
            y: horizontal ? y : (y + base) / 2
        };
    }
    getRange(axis) {
        return axis === 'x' ? this.width / 2 : this.height / 2;
    }
}

var elements = /*#__PURE__*/Object.freeze({
__proto__: null,
ArcElement: ArcElement,
BarElement: BarElement,
LineElement: LineElement,
PointElement: PointElement
});

const BORDER_COLORS = [
    'rgb(54, 162, 235)',
    'rgb(255, 99, 132)',
    'rgb(255, 159, 64)',
    'rgb(255, 205, 86)',
    'rgb(75, 192, 192)',
    'rgb(153, 102, 255)',
    'rgb(201, 203, 207)' // grey
];
// Border colors with 50% transparency
const BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));
function getBorderColor(i) {
    return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i) {
    dataset.borderColor = getBorderColor(i);
    dataset.backgroundColor = getBackgroundColor(i);
    return ++i;
}
function colorizeDoughnutDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));
    return i;
}
function colorizePolarAreaDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));
    return i;
}
function getColorizer(chart) {
    let i = 0;
    return (dataset, datasetIndex)=>{
        const controller = chart.getDatasetMeta(datasetIndex).controller;
        if (controller instanceof DoughnutController) {
            i = colorizeDoughnutDataset(dataset, i);
        } else if (controller instanceof PolarAreaController) {
            i = colorizePolarAreaDataset(dataset, i);
        } else if (controller) {
            i = colorizeDefaultDataset(dataset, i);
        }
    };
}
function containsColorsDefinitions(descriptors) {
    let k;
    for(k in descriptors){
        if (descriptors[k].borderColor || descriptors[k].backgroundColor) {
            return true;
        }
    }
    return false;
}
function containsColorsDefinition(descriptor) {
    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
function containsDefaultColorsDefenitions() {
    return defaults.borderColor !== 'rgba(0,0,0,0.1)' || defaults.backgroundColor !== 'rgba(0,0,0,0.1)';
}
var plugin_colors = {
    id: 'colors',
    defaults: {
        enabled: true,
        forceOverride: false
    },
    beforeLayout (chart, _args, options) {
        if (!options.enabled) {
            return;
        }
        const { data: { datasets  } , options: chartOptions  } = chart.config;
        const { elements  } = chartOptions;
        const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements) || containsDefaultColorsDefenitions();
        if (!options.forceOverride && containsColorDefenition) {
            return;
        }
        const colorizer = getColorizer(chart);
        datasets.forEach(colorizer);
    }
};

function lttbDecimation(data, start, count, availableWidth, options) {
 const samples = options.samples || availableWidth;
    if (samples >= count) {
        return data.slice(start, start + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start + count - 1;
    let a = start;
    let i, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a];
    for(i = 0; i < samples - 2; i++){
        let avgX = 0;
        let avgY = 0;
        let j;
        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
        const avgRangeLength = avgRangeEnd - avgRangeStart;
        for(j = avgRangeStart; j < avgRangeEnd; j++){
            avgX += data[j].x;
            avgY += data[j].y;
        }
        avgX /= avgRangeLength;
        avgY /= avgRangeLength;
        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
        const { x: pointAx , y: pointAy  } = data[a];
        maxArea = area = -1;
        for(j = rangeOffs; j < rangeTo; j++){
            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
            if (area > maxArea) {
                maxArea = area;
                maxAreaPoint = data[j];
                nextA = j;
            }
        }
        decimated[sampledIndex++] = maxAreaPoint;
        a = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start + count - 1;
    const xMin = data[start].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for(i = start; i < start + count; ++i){
        point = data[i];
        x = (point.x - xMin) / dx * availableWidth;
        y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
            if (y < minY) {
                minY = y;
                minIndex = i;
            } else if (y > maxY) {
                maxY = y;
                maxIndex = i;
            }
            avgX = (countX * avgX + point.x) / ++countX;
        } else {
            const lastIndex = i - 1;
            if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
                const intermediateIndex1 = Math.min(minIndex, maxIndex);
                const intermediateIndex2 = Math.max(minIndex, maxIndex);
                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                    decimated.push({
                        ...data[intermediateIndex1],
                        x: avgX
                    });
                }
                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                    decimated.push({
                        ...data[intermediateIndex2],
                        x: avgX
                    });
                }
            }
            if (i > 0 && lastIndex !== startIndex) {
                decimated.push(data[lastIndex]);
            }
            decimated.push(point);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
            minIndex = maxIndex = startIndex = i;
        }
    }
    return decimated;
}
function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
        const data = dataset._data;
        delete dataset._decimated;
        delete dataset._data;
        Object.defineProperty(dataset, 'data', {
            configurable: true,
            enumerable: true,
            writable: true,
            value: data
        });
    }
}
function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset)=>{
        cleanDecimatedDataset(dataset);
    });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start = 0;
    let count;
    const { iScale  } = meta;
    const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();
    if (minDefined) {
        start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
        count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
    } else {
        count = pointCount - start;
    }
    return {
        start,
        count
    };
}
var plugin_decimation = {
    id: 'decimation',
    defaults: {
        algorithm: 'min-max',
        enabled: false
    },
    beforeElementsUpdate: (chart, args, options)=>{
        if (!options.enabled) {
            cleanDecimatedData(chart);
            return;
        }
        const availableWidth = chart.width;
        chart.data.datasets.forEach((dataset, datasetIndex)=>{
            const { _data , indexAxis  } = dataset;
            const meta = chart.getDatasetMeta(datasetIndex);
            const data = _data || dataset.data;
            if (resolve([
                indexAxis,
                chart.options.indexAxis
            ]) === 'y') {
                return;
            }
            if (!meta.controller.supportsDecimation) {
                return;
            }
            const xAxis = chart.scales[meta.xAxisID];
            if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
                return;
            }
            if (chart.options.parsing) {
                return;
            }
            let { start , count  } = getStartAndCountOfVisiblePointsSimplified(meta, data);
            const threshold = options.threshold || 4 * availableWidth;
            if (count <= threshold) {
                cleanDecimatedDataset(dataset);
                return;
            }
            if (isNullOrUndef(_data)) {
                dataset._data = data;
                delete dataset.data;
                Object.defineProperty(dataset, 'data', {
                    configurable: true,
                    enumerable: true,
                    get: function() {
                        return this._decimated;
                    },
                    set: function(d) {
                        this._data = d;
                    }
                });
            }
            let decimated;
            switch(options.algorithm){
                case 'lttb':
                    decimated = lttbDecimation(data, start, count, availableWidth, options);
                    break;
                case 'min-max':
                    decimated = minMaxDecimation(data, start, count, availableWidth);
                    break;
                default:
                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
            }
            dataset._decimated = decimated;
        });
    },
    destroy (chart) {
        cleanDecimatedData(chart);
    }
};

function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments){
        let { start , end  } = segment;
        end = _findSegmentEnd(start, end, points);
        const bounds = _getBounds(property, points[start], points[end], segment.loop);
        if (!target.segments) {
            parts.push({
                source: segment,
                target: bounds,
                start: points[start],
                end: points[end]
            });
            continue;
        }
        const targetSegments = _boundSegments(target, bounds);
        for (const tgt of targetSegments){
            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
            const fillSources = _boundSegment(segment, points, subBounds);
            for (const fillSource of fillSources){
                parts.push({
                    source: fillSource,
                    target: tgt,
                    start: {
                        [property]: _getEdge(bounds, subBounds, 'start', Math.max)
                    },
                    end: {
                        [property]: _getEdge(bounds, subBounds, 'end', Math.min)
                    }
                });
            }
        }
    }
    return parts;
}
function _getBounds(property, first, last, loop) {
    if (loop) {
        return;
    }
    let start = first[property];
    let end = last[property];
    if (property === 'angle') {
        start = _normalizeAngle(start);
        end = _normalizeAngle(end);
    }
    return {
        property,
        start,
        end
    };
}
function _pointsFromSegments(boundary, line) {
    const { x =null , y =null  } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start , end  })=>{
        end = _findSegmentEnd(start, end, linePoints);
        const first = linePoints[start];
        const last = linePoints[end];
        if (y !== null) {
            points.push({
                x: first.x,
                y
            });
            points.push({
                x: last.x,
                y
            });
        } else if (x !== null) {
            points.push({
                x,
                y: first.y
            });
            points.push({
                x,
                y: last.y
            });
        }
    });
    return points;
}
function _findSegmentEnd(start, end, points) {
    for(; end > start; end--){
        const point = points[end];
        if (!isNaN(point.x) && !isNaN(point.y)) {
            break;
        }
    }
    return end;
}
function _getEdge(a, b, prop, fn) {
    if (a && b) {
        return fn(a[prop], b[prop]);
    }
    return a ? a[prop] : b ? b[prop] : 0;
}

function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (isArray(boundary)) {
        _loop = true;
        points = boundary;
    } else {
        points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
        points,
        options: {
            tension: 0
        },
        _loop,
        _fullLoop: _loop
    }) : null;
}
function _shouldApplyFill(source) {
    return source && source.fill !== false;
}

function _resolveTarget(sources, index, propagate) {
    const source = sources[index];
    let fill = source.fill;
    const visited = [
        index
    ];
    let target;
    if (!propagate) {
        return fill;
    }
    while(fill !== false && visited.indexOf(fill) === -1){
        if (!isNumberFinite(fill)) {
            return fill;
        }
        target = sources[fill];
        if (!target) {
            return false;
        }
        if (target.visible) {
            return fill;
        }
        visited.push(fill);
        fill = target.fill;
    }
    return false;
}
 function _decodeFill(line, index, count) {
     const fill = parseFillOption(line);
    if (isObject(fill)) {
        return isNaN(fill.value) ? false : fill;
    }
    let target = parseFloat(fill);
    if (isNumberFinite(target) && Math.floor(target) === target) {
        return decodeTargetIndex(fill[0], index, target, count);
    }
    return [
        'origin',
        'start',
        'end',
        'stack',
        'shape'
    ].indexOf(fill) >= 0 && fill;
}
function decodeTargetIndex(firstCh, index, target, count) {
    if (firstCh === '-' || firstCh === '+') {
        target = index + target;
    }
    if (target === index || target < 0 || target >= count) {
        return false;
    }
    return target;
}
 function _getTargetPixel(fill, scale) {
    let pixel = null;
    if (fill === 'start') {
        pixel = scale.bottom;
    } else if (fill === 'end') {
        pixel = scale.top;
    } else if (isObject(fill)) {
        pixel = scale.getPixelForValue(fill.value);
    } else if (scale.getBasePixel) {
        pixel = scale.getBasePixel();
    }
    return pixel;
}
 function _getTargetValue(fill, scale, startValue) {
    let value;
    if (fill === 'start') {
        value = startValue;
    } else if (fill === 'end') {
        value = scale.options.reverse ? scale.min : scale.max;
    } else if (isObject(fill)) {
        value = fill.value;
    } else {
        value = scale.getBaseValue();
    }
    return value;
}
 function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
    if (fill === undefined) {
        fill = !!options.backgroundColor;
    }
    if (fill === false || fill === null) {
        return false;
    }
    if (fill === true) {
        return 'origin';
    }
    return fill;
}

function _buildStackLine(source) {
    const { scale , index , line  } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index);
    linesBelow.push(_createBoundaryLine({
        x: null,
        y: scale.bottom
    }, line));
    for(let i = 0; i < segments.length; i++){
        const segment = segments[i];
        for(let j = segment.start; j <= segment.end; j++){
            addPointsBelow(points, sourcePoints[j], linesBelow);
        }
    }
    return new LineElement({
        points,
        options: {}
    });
}
 function getLinesBelow(scale, index) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas('line');
    for(let i = 0; i < metas.length; i++){
        const meta = metas[i];
        if (meta.index === index) {
            break;
        }
        if (!meta.hidden) {
            below.unshift(meta.dataset);
        }
    }
    return below;
}
 function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for(let j = 0; j < linesBelow.length; j++){
        const line = linesBelow[j];
        const { first , last , point  } = findPoint(line, sourcePoint, 'x');
        if (!point || first && last) {
            continue;
        }
        if (first) {
            postponed.unshift(point);
        } else {
            points.push(point);
            if (!last) {
                break;
            }
        }
    }
    points.push(...postponed);
}
 function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) {
        return {};
    }
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last = false;
    for(let i = 0; i < segments.length; i++){
        const segment = segments[i];
        const firstValue = linePoints[segment.start][property];
        const lastValue = linePoints[segment.end][property];
        if (_isBetween(pointValue, firstValue, lastValue)) {
            first = pointValue === firstValue;
            last = pointValue === lastValue;
            break;
        }
    }
    return {
        first,
        last,
        point
    };
}

class simpleArc {
    constructor(opts){
        this.x = opts.x;
        this.y = opts.y;
        this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
        const { x , y , radius  } = this;
        bounds = bounds || {
            start: 0,
            end: TAU
        };
        ctx.arc(x, y, radius, bounds.end, bounds.start, true);
        return !opts.bounds;
    }
    interpolate(point) {
        const { x , y , radius  } = this;
        const angle = point.angle;
        return {
            x: x + Math.cos(angle) * radius,
            y: y + Math.sin(angle) * radius,
            angle
        };
    }
}

function _getTarget(source) {
    const { chart , fill , line  } = source;
    if (isNumberFinite(fill)) {
        return getLineByIndex(chart, fill);
    }
    if (fill === 'stack') {
        return _buildStackLine(source);
    }
    if (fill === 'shape') {
        return true;
    }
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) {
        return boundary;
    }
    return _createBoundaryLine(boundary, line);
}
 function getLineByIndex(chart, index) {
    const meta = chart.getDatasetMeta(index);
    const visible = meta && chart.isDatasetVisible(index);
    return visible ? meta.dataset : null;
}
function computeBoundary(source) {
    const scale = source.scale || {};
    if (scale.getPointPositionForValue) {
        return computeCircularBoundary(source);
    }
    return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
    const { scale ={} , fill  } = source;
    const pixel = _getTargetPixel(fill, scale);
    if (isNumberFinite(pixel)) {
        const horizontal = scale.isHorizontal();
        return {
            x: horizontal ? pixel : null,
            y: horizontal ? null : pixel
        };
    }
    return null;
}
function computeCircularBoundary(source) {
    const { scale , fill  } = source;
    const options = scale.options;
    const length = scale.getLabels().length;
    const start = options.reverse ? scale.max : scale.min;
    const value = _getTargetValue(fill, scale, start);
    const target = [];
    if (options.grid.circular) {
        const center = scale.getPointPositionForValue(0, start);
        return new simpleArc({
            x: center.x,
            y: center.y,
            radius: scale.getDistanceFromCenterForValue(value)
        });
    }
    for(let i = 0; i < length; ++i){
        target.push(scale.getPointPositionForValue(i, value));
    }
    return target;
}

function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { chart , index , line , scale , axis  } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color = lineOpts.backgroundColor;
    const { above =color , below =color  } = fillOption || {};
    const meta = chart.getDatasetMeta(index);
    const clip = getDatasetClipArea(chart, meta);
    if (target && line.points.length) {
        clipArea(ctx, area);
        doFill(ctx, {
            line,
            target,
            above,
            below,
            area,
            scale,
            axis,
            clip
        });
        unclipArea(ctx);
    }
}
function doFill(ctx, cfg) {
    const { line , target , above , below , area , scale , clip  } = cfg;
    const property = line._loop ? 'angle' : cfg.axis;
    ctx.save();
    if (property === 'x' && below !== above) {
        clipVertical(ctx, target, area.top);
        fill(ctx, {
            line,
            target,
            color: above,
            scale,
            property,
            clip
        });
        ctx.restore();
        ctx.save();
        clipVertical(ctx, target, area.bottom);
    }
    fill(ctx, {
        line,
        target,
        color: below,
        scale,
        property,
        clip
    });
    ctx.restore();
}
function clipVertical(ctx, target, clipY) {
    const { segments , points  } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments){
        const { start , end  } = segment;
        const firstPoint = points[start];
        const lastPoint = points[_findSegmentEnd(start, end, points)];
        if (first) {
            ctx.moveTo(firstPoint.x, firstPoint.y);
            first = false;
        } else {
            ctx.lineTo(firstPoint.x, clipY);
            ctx.lineTo(firstPoint.x, firstPoint.y);
        }
        lineLoop = !!target.pathSegment(ctx, segment, {
            move: lineLoop
        });
        if (lineLoop) {
            ctx.closePath();
        } else {
            ctx.lineTo(lastPoint.x, clipY);
        }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
}
function fill(ctx, cfg) {
    const { line , target , property , color , scale , clip  } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src , target: tgt , start , end  } of segments){
        const { style: { backgroundColor =color  } = {}  } = src;
        const notShape = target !== true;
        ctx.save();
        ctx.fillStyle = backgroundColor;
        clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));
        ctx.beginPath();
        const lineLoop = !!line.pathSegment(ctx, src);
        let loop;
        if (notShape) {
            if (lineLoop) {
                ctx.closePath();
            } else {
                interpolatedLineTo(ctx, target, end, property);
            }
            const targetLoop = !!target.pathSegment(ctx, tgt, {
                move: lineLoop,
                reverse: true
            });
            loop = lineLoop && targetLoop;
            if (!loop) {
                interpolatedLineTo(ctx, target, start, property);
            }
        }
        ctx.closePath();
        ctx.fill(loop ? 'evenodd' : 'nonzero');
        ctx.restore();
    }
}
function clipBounds(ctx, scale, clip, bounds) {
    const chartArea = scale.chart.chartArea;
    const { property , start , end  } = bounds || {};
    if (property === 'x' || property === 'y') {
        let left, top, right, bottom;
        if (property === 'x') {
            left = start;
            top = chartArea.top;
            right = end;
            bottom = chartArea.bottom;
        } else {
            left = chartArea.left;
            top = start;
            right = chartArea.right;
            bottom = end;
        }
        ctx.beginPath();
        if (clip) {
            left = Math.max(left, clip.left);
            right = Math.min(right, clip.right);
            top = Math.max(top, clip.top);
            bottom = Math.min(bottom, clip.bottom);
        }
        ctx.rect(left, top, right - left, bottom - top);
        ctx.clip();
    }
}
function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) {
        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
}

var index = {
    id: 'filler',
    afterDatasetsUpdate (chart, _args, options) {
        const count = (chart.data.datasets || []).length;
        const sources = [];
        let meta, i, line, source;
        for(i = 0; i < count; ++i){
            meta = chart.getDatasetMeta(i);
            line = meta.dataset;
            source = null;
            if (line && line.options && line instanceof LineElement) {
                source = {
                    visible: chart.isDatasetVisible(i),
                    index: i,
                    fill: _decodeFill(line, i, count),
                    chart,
                    axis: meta.controller.options.indexAxis,
                    scale: meta.vScale,
                    line
                };
            }
            meta.$filler = source;
            sources.push(source);
        }
        for(i = 0; i < count; ++i){
            source = sources[i];
            if (!source || source.fill === false) {
                continue;
            }
            source.fill = _resolveTarget(sources, i, options.propagate);
        }
    },
    beforeDraw (chart, _args, options) {
        const draw = options.drawTime === 'beforeDraw';
        const metasets = chart.getSortedVisibleDatasetMetas();
        const area = chart.chartArea;
        for(let i = metasets.length - 1; i >= 0; --i){
            const source = metasets[i].$filler;
            if (!source) {
                continue;
            }
            source.line.updateControlPoints(area, source.axis);
            if (draw && source.fill) {
                _drawfill(chart.ctx, source, area);
            }
        }
    },
    beforeDatasetsDraw (chart, _args, options) {
        if (options.drawTime !== 'beforeDatasetsDraw') {
            return;
        }
        const metasets = chart.getSortedVisibleDatasetMetas();
        for(let i = metasets.length - 1; i >= 0; --i){
            const source = metasets[i].$filler;
            if (_shouldApplyFill(source)) {
                _drawfill(chart.ctx, source, chart.chartArea);
            }
        }
    },
    beforeDatasetDraw (chart, args, options) {
        const source = args.meta.$filler;
        if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {
            return;
        }
        _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
        propagate: true,
        drawTime: 'beforeDatasetDraw'
    }
};

const getBoxSize = (labelOpts, fontSize)=>{
    let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;
    if (labelOpts.usePointStyle) {
        boxHeight = Math.min(boxHeight, fontSize);
        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
        boxWidth,
        boxHeight,
        itemHeight: Math.max(fontSize, boxHeight)
    };
};
const itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class Legend extends Element$1 {
 constructor(config){
        super();
        this._added = false;
        this.legendHitBoxes = [];
 this._hoveredItem = null;
        this.doughnutMode = false;
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this.legendItems = undefined;
        this.columnSizes = undefined;
        this.lineWidths = undefined;
        this.maxHeight = undefined;
        this.maxWidth = undefined;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.height = undefined;
        this.width = undefined;
        this._margins = undefined;
        this.position = undefined;
        this.weight = undefined;
        this.fullSize = undefined;
    }
    update(maxWidth, maxHeight, margins) {
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins;
        this.setDimensions();
        this.buildLabels();
        this.fit();
    }
    setDimensions() {
        if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = this._margins.left;
            this.right = this.width;
        } else {
            this.height = this.maxHeight;
            this.top = this._margins.top;
            this.bottom = this.height;
        }
    }
    buildLabels() {
        const labelOpts = this.options.labels || {};
        let legendItems = callback(labelOpts.generateLabels, [
            this.chart
        ], this) || [];
        if (labelOpts.filter) {
            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));
        }
        if (labelOpts.sort) {
            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));
        }
        if (this.options.reverse) {
            legendItems.reverse();
        }
        this.legendItems = legendItems;
    }
    fit() {
        const { options , ctx  } = this;
        if (!options.display) {
            this.width = this.height = 0;
            return;
        }
        const labelOpts = options.labels;
        const labelFont = toFont(labelOpts.font);
        const fontSize = labelFont.size;
        const titleHeight = this._computeTitleHeight();
        const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);
        let width, height;
        ctx.font = labelFont.string;
        if (this.isHorizontal()) {
            width = this.maxWidth;
            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
        } else {
            height = this.maxHeight;
            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
        }
        this.width = Math.min(width, options.maxWidth || this.maxWidth);
        this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
 _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
        const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;
        const hitboxes = this.legendHitBoxes = [];
        const lineWidths = this.lineWidths = [
            0
        ];
        const lineHeight = itemHeight + padding;
        let totalHeight = titleHeight;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        let row = -1;
        let top = -lineHeight;
        this.legendItems.forEach((legendItem, i)=>{
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                totalHeight += lineHeight;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                top += lineHeight;
                row++;
            }
            hitboxes[i] = {
                left: 0,
                top,
                row,
                width: itemWidth,
                height: itemHeight
            };
            lineWidths[lineWidths.length - 1] += itemWidth + padding;
        });
        return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
        const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;
        const hitboxes = this.legendHitBoxes = [];
        const columnSizes = this.columnSizes = [];
        const heightLimit = maxHeight - titleHeight;
        let totalWidth = padding;
        let currentColWidth = 0;
        let currentColHeight = 0;
        let left = 0;
        let col = 0;
        this.legendItems.forEach((legendItem, i)=>{
            const { itemWidth , itemHeight  } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                totalWidth += currentColWidth + padding;
                columnSizes.push({
                    width: currentColWidth,
                    height: currentColHeight
                });
                left += currentColWidth + padding;
                col++;
                currentColWidth = currentColHeight = 0;
            }
            hitboxes[i] = {
                left,
                top: currentColHeight,
                col,
                width: itemWidth,
                height: itemHeight
            };
            currentColWidth = Math.max(currentColWidth, itemWidth);
            currentColHeight += itemHeight + padding;
        });
        totalWidth += currentColWidth;
        columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
        });
        return totalWidth;
    }
    adjustHitBoxes() {
        if (!this.options.display) {
            return;
        }
        const titleHeight = this._computeTitleHeight();
        const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;
        const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
        if (this.isHorizontal()) {
            let row = 0;
            let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
            for (const hitbox of hitboxes){
                if (row !== hitbox.row) {
                    row = hitbox.row;
                    left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                }
                hitbox.top += this.top + titleHeight + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                left += hitbox.width + padding;
            }
        } else {
            let col = 0;
            let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
            for (const hitbox of hitboxes){
                if (hitbox.col !== col) {
                    col = hitbox.col;
                    top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                }
                hitbox.top = top;
                hitbox.left += this.left + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                top += hitbox.height + padding;
            }
        }
    }
    isHorizontal() {
        return this.options.position === 'top' || this.options.position === 'bottom';
    }
    draw() {
        if (this.options.display) {
            const ctx = this.ctx;
            clipArea(ctx, this);
            this._draw();
            unclipArea(ctx);
        }
    }
 _draw() {
        const { options: opts , columnSizes , lineWidths , ctx  } = this;
        const { align , labels: labelOpts  } = opts;
        const defaultColor = defaults.color;
        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
        const labelFont = toFont(labelOpts.font);
        const { padding  } = labelOpts;
        const fontSize = labelFont.size;
        const halfFontSize = fontSize / 2;
        let cursor;
        this.drawTitle();
        ctx.textAlign = rtlHelper.textAlign('left');
        ctx.textBaseline = 'middle';
        ctx.lineWidth = 0.5;
        ctx.font = labelFont.string;
        const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);
        const drawLegendBox = function(x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
                return;
            }
            ctx.save();
            const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
            ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');
            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
            ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
            if (labelOpts.usePointStyle) {
                const drawOptions = {
                    radius: boxHeight * Math.SQRT2 / 2,
                    pointStyle: legendItem.pointStyle,
                    rotation: legendItem.rotation,
                    borderWidth: lineWidth
                };
                const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                const centerY = y + halfFontSize;
                drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
            } else {
                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                const borderRadius = toTRBLCorners(legendItem.borderRadius);
                ctx.beginPath();
                if (Object.values(borderRadius).some((v)=>v !== 0)) {
                    addRoundedRectPath(ctx, {
                        x: xBoxLeft,
                        y: yBoxTop,
                        w: boxWidth,
                        h: boxHeight,
                        radius: borderRadius
                    });
                } else {
                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                }
                ctx.fill();
                if (lineWidth !== 0) {
                    ctx.stroke();
                }
            }
            ctx.restore();
        };
        const fillText = function(x, y, legendItem) {
            renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                strikethrough: legendItem.hidden,
                textAlign: rtlHelper.textAlign(legendItem.textAlign)
            });
        };
        const isHorizontal = this.isHorizontal();
        const titleHeight = this._computeTitleHeight();
        if (isHorizontal) {
            cursor = {
                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
                y: this.top + padding + titleHeight,
                line: 0
            };
        } else {
            cursor = {
                x: this.left + padding,
                y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
                line: 0
            };
        }
        overrideTextDirection(this.ctx, opts.textDirection);
        const lineHeight = itemHeight + padding;
        this.legendItems.forEach((legendItem, i)=>{
            ctx.strokeStyle = legendItem.fontColor;
            ctx.fillStyle = legendItem.fontColor;
            const textWidth = ctx.measureText(legendItem.text).width;
            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
            const width = boxWidth + halfFontSize + textWidth;
            let x = cursor.x;
            let y = cursor.y;
            rtlHelper.setWidth(this.width);
            if (isHorizontal) {
                if (i > 0 && x + width + padding > this.right) {
                    y = cursor.y += lineHeight;
                    cursor.line++;
                    x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
                }
            } else if (i > 0 && y + lineHeight > this.bottom) {
                x = cursor.x = x + columnSizes[cursor.line].width + padding;
                cursor.line++;
                y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
            }
            const realX = rtlHelper.x(x);
            drawLegendBox(realX, y, legendItem);
            x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
            fillText(rtlHelper.x(x), y, legendItem);
            if (isHorizontal) {
                cursor.x += width + padding;
            } else if (typeof legendItem.text !== 'string') {
                const fontLineHeight = labelFont.lineHeight;
                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
            } else {
                cursor.y += lineHeight;
            }
        });
        restoreTextDirection(this.ctx, opts.textDirection);
    }
 drawTitle() {
        const opts = this.options;
        const titleOpts = opts.title;
        const titleFont = toFont(titleOpts.font);
        const titlePadding = toPadding(titleOpts.padding);
        if (!titleOpts.display) {
            return;
        }
        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
        const ctx = this.ctx;
        const position = titleOpts.position;
        const halfFontSize = titleFont.size / 2;
        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
        let y;
        let left = this.left;
        let maxWidth = this.width;
        if (this.isHorizontal()) {
            maxWidth = Math.max(...this.lineWidths);
            y = this.top + topPaddingPlusHalfFontSize;
            left = _alignStartEnd(opts.align, left, this.right - maxWidth);
        } else {
            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);
            y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
        }
        const x = _alignStartEnd(position, left, left + maxWidth);
        ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = titleOpts.color;
        ctx.fillStyle = titleOpts.color;
        ctx.font = titleFont.string;
        renderText(ctx, titleOpts.text, x, y, titleFont);
    }
 _computeTitleHeight() {
        const titleOpts = this.options.title;
        const titleFont = toFont(titleOpts.font);
        const titlePadding = toPadding(titleOpts.padding);
        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
 _getLegendItemAt(x, y) {
        let i, hitBox, lh;
        if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
            lh = this.legendHitBoxes;
            for(i = 0; i < lh.length; ++i){
                hitBox = lh[i];
                if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
                    return this.legendItems[i];
                }
            }
        }
        return null;
    }
 handleEvent(e) {
        const opts = this.options;
        if (!isListened(e.type, opts)) {
            return;
        }
        const hoveredItem = this._getLegendItemAt(e.x, e.y);
        if (e.type === 'mousemove' || e.type === 'mouseout') {
            const previous = this._hoveredItem;
            const sameItem = itemsEqual(previous, hoveredItem);
            if (previous && !sameItem) {
                callback(opts.onLeave, [
                    e,
                    previous,
                    this
                ], this);
            }
            this._hoveredItem = hoveredItem;
            if (hoveredItem && !sameItem) {
                callback(opts.onHover, [
                    e,
                    hoveredItem,
                    this
                ], this);
            }
        } else if (hoveredItem) {
            callback(opts.onClick, [
                e,
                hoveredItem,
                this
            ], this);
        }
    }
}
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
        itemWidth,
        itemHeight
    };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== 'string') {
        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);
    }
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== 'string') {
        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    }
    return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length : 0;
    return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
    if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {
        return true;
    }
    if (opts.onClick && (type === 'click' || type === 'mouseup')) {
        return true;
    }
    return false;
}
var plugin_legend = {
    id: 'legend',
 _element: Legend,
    start (chart, _args, options) {
        const legend = chart.legend = new Legend({
            ctx: chart.ctx,
            options,
            chart
        });
        layouts.configure(chart, legend, options);
        layouts.addBox(chart, legend);
    },
    stop (chart) {
        layouts.removeBox(chart, chart.legend);
        delete chart.legend;
    },
    beforeUpdate (chart, _args, options) {
        const legend = chart.legend;
        layouts.configure(chart, legend, options);
        legend.options = options;
    },
    afterUpdate (chart) {
        const legend = chart.legend;
        legend.buildLabels();
        legend.adjustHitBoxes();
    },
    afterEvent (chart, args) {
        if (!args.replay) {
            chart.legend.handleEvent(args.event);
        }
    },
    defaults: {
        display: true,
        position: 'top',
        align: 'center',
        fullSize: true,
        reverse: false,
        weight: 1000,
        onClick (e, legendItem, legend) {
            const index = legendItem.datasetIndex;
            const ci = legend.chart;
            if (ci.isDatasetVisible(index)) {
                ci.hide(index);
                legendItem.hidden = true;
            } else {
                ci.show(index);
                legendItem.hidden = false;
            }
        },
        onHover: null,
        onLeave: null,
        labels: {
            color: (ctx)=>ctx.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels (chart) {
                const datasets = chart.data.datasets;
                const { labels: { usePointStyle , pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;
                return chart._getSortedDatasetMetas().map((meta)=>{
                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
                    const borderWidth = toPadding(style.borderWidth);
                    return {
                        text: datasets[meta.index].label,
                        fillStyle: style.backgroundColor,
                        fontColor: color,
                        hidden: !meta.visible,
                        lineCap: style.borderCapStyle,
                        lineDash: style.borderDash,
                        lineDashOffset: style.borderDashOffset,
                        lineJoin: style.borderJoinStyle,
                        lineWidth: (borderWidth.width + borderWidth.height) / 4,
                        strokeStyle: style.borderColor,
                        pointStyle: pointStyle || style.pointStyle,
                        rotation: style.rotation,
                        textAlign: textAlign || style.textAlign,
                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                        datasetIndex: meta.index
                    };
                }, this);
            }
        },
        title: {
            color: (ctx)=>ctx.chart.options.color,
            display: false,
            position: 'center',
            text: ''
        }
    },
    descriptors: {
        _scriptable: (name)=>!name.startsWith('on'),
        labels: {
            _scriptable: (name)=>![
                    'generateLabels',
                    'filter',
                    'sort'
                ].includes(name)
        }
    }
};

class Title extends Element$1 {
 constructor(config){
        super();
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this._padding = undefined;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.width = undefined;
        this.height = undefined;
        this.position = undefined;
        this.weight = undefined;
        this.fullSize = undefined;
    }
    update(maxWidth, maxHeight) {
        const opts = this.options;
        this.left = 0;
        this.top = 0;
        if (!opts.display) {
            this.width = this.height = this.right = this.bottom = 0;
            return;
        }
        this.width = this.right = maxWidth;
        this.height = this.bottom = maxHeight;
        const lineCount = isArray(opts.text) ? opts.text.length : 1;
        this._padding = toPadding(opts.padding);
        const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
        if (this.isHorizontal()) {
            this.height = textSize;
        } else {
            this.width = textSize;
        }
    }
    isHorizontal() {
        const pos = this.options.position;
        return pos === 'top' || pos === 'bottom';
    }
    _drawArgs(offset) {
        const { top , left , bottom , right , options  } = this;
        const align = options.align;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        if (this.isHorizontal()) {
            titleX = _alignStartEnd(align, left, right);
            titleY = top + offset;
            maxWidth = right - left;
        } else {
            if (options.position === 'left') {
                titleX = left + offset;
                titleY = _alignStartEnd(align, bottom, top);
                rotation = PI * -0.5;
            } else {
                titleX = right - offset;
                titleY = _alignStartEnd(align, top, bottom);
                rotation = PI * 0.5;
            }
            maxWidth = bottom - top;
        }
        return {
            titleX,
            titleY,
            maxWidth,
            rotation
        };
    }
    draw() {
        const ctx = this.ctx;
        const opts = this.options;
        if (!opts.display) {
            return;
        }
        const fontOpts = toFont(opts.font);
        const lineHeight = fontOpts.lineHeight;
        const offset = lineHeight / 2 + this._padding.top;
        const { titleX , titleY , maxWidth , rotation  } = this._drawArgs(offset);
        renderText(ctx, opts.text, 0, 0, fontOpts, {
            color: opts.color,
            maxWidth,
            rotation,
            textAlign: _toLeftRightCenter(opts.align),
            textBaseline: 'middle',
            translation: [
                titleX,
                titleY
            ]
        });
    }
}
function createTitle(chart, titleOpts) {
    const title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
}
var plugin_title = {
    id: 'title',
 _element: Title,
    start (chart, _args, options) {
        createTitle(chart, options);
    },
    stop (chart) {
        const titleBlock = chart.titleBlock;
        layouts.removeBox(chart, titleBlock);
        delete chart.titleBlock;
    },
    beforeUpdate (chart, _args, options) {
        const title = chart.titleBlock;
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: 'center',
        display: false,
        font: {
            weight: 'bold'
        },
        fullSize: true,
        padding: 10,
        position: 'top',
        text: '',
        weight: 2000
    },
    defaultRoutes: {
        color: 'color'
    },
    descriptors: {
        _scriptable: true,
        _indexable: false
    }
};

const map = new WeakMap();
var plugin_subtitle = {
    id: 'subtitle',
    start (chart, _args, options) {
        const title = new Title({
            ctx: chart.ctx,
            options,
            chart
        });
        layouts.configure(chart, title, options);
        layouts.addBox(chart, title);
        map.set(chart, title);
    },
    stop (chart) {
        layouts.removeBox(chart, map.get(chart));
        map.delete(chart);
    },
    beforeUpdate (chart, _args, options) {
        const title = map.get(chart);
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: 'center',
        display: false,
        font: {
            weight: 'normal'
        },
        fullSize: true,
        padding: 0,
        position: 'top',
        text: '',
        weight: 1500
    },
    defaultRoutes: {
        color: 'color'
    },
    descriptors: {
        _scriptable: true,
        _indexable: false
    }
};

const positioners = {
 average (items) {
        if (!items.length) {
            return false;
        }
        let i, len;
        let xSet = new Set();
        let y = 0;
        let count = 0;
        for(i = 0, len = items.length; i < len; ++i){
            const el = items[i].element;
            if (el && el.hasValue()) {
                const pos = el.tooltipPosition();
                xSet.add(pos.x);
                y += pos.y;
                ++count;
            }
        }
        if (count === 0 || xSet.size === 0) {
            return false;
        }
        const xAverage = [
            ...xSet
        ].reduce((a, b)=>a + b) / xSet.size;
        return {
            x: xAverage,
            y: y / count
        };
    },
 nearest (items, eventPosition) {
        if (!items.length) {
            return false;
        }
        let x = eventPosition.x;
        let y = eventPosition.y;
        let minDistance = Number.POSITIVE_INFINITY;
        let i, len, nearestElement;
        for(i = 0, len = items.length; i < len; ++i){
            const el = items[i].element;
            if (el && el.hasValue()) {
                const center = el.getCenterPoint();
                const d = distanceBetweenPoints(eventPosition, center);
                if (d < minDistance) {
                    minDistance = d;
                    nearestElement = el;
                }
            }
        }
        if (nearestElement) {
            const tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y;
        }
        return {
            x,
            y
        };
    }
};
function pushOrConcat(base, toPush) {
    if (toPush) {
        if (isArray(toPush)) {
            Array.prototype.push.apply(base, toPush);
        } else {
            base.push(toPush);
        }
    }
    return base;
}
 function splitNewlines(str) {
    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
        return str.split('\n');
    }
    return str;
}
 function createTooltipItem(chart, item) {
    const { element , datasetIndex , index  } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label , value  } = controller.getLabelAndValue(index);
    return {
        chart,
        label,
        parsed: controller.getParsed(index),
        raw: chart.data.datasets[datasetIndex].data[index],
        formattedValue: value,
        dataset: controller.getDataset(),
        dataIndex: index,
        datasetIndex,
        element
    };
}
 function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body , footer , title  } = tooltip;
    const { boxWidth , boxHeight  } = options;
    const bodyFont = toFont(options.bodyFont);
    const titleFont = toFont(options.titleFont);
    const footerFont = toFont(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    each(body, (bodyItem)=>{
        each(bodyItem.before, maxLineWidth);
        each(bodyItem.lines, maxLineWidth);
        each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
        width,
        height
    };
}
function determineYAlign(chart, size) {
    const { y , height  } = size;
    if (y < height / 2) {
        return 'top';
    } else if (y > chart.height - height / 2) {
        return 'bottom';
    }
    return 'center';
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x , width  } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === 'left' && x + width + caret > chart.width) {
        return true;
    }
    if (xAlign === 'right' && x - width - caret < 0) {
        return true;
    }
}
function determineXAlign(chart, options, size, yAlign) {
    const { x , width  } = size;
    const { width: chartWidth , chartArea: { left , right  }  } = chart;
    let xAlign = 'center';
    if (yAlign === 'center') {
        xAlign = x <= (left + right) / 2 ? 'left' : 'right';
    } else if (x <= width / 2) {
        xAlign = 'left';
    } else if (x >= chartWidth - width / 2) {
        xAlign = 'right';
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
        xAlign = 'center';
    }
    return xAlign;
}
 function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
        yAlign
    };
}
function alignX(size, xAlign) {
    let { x , width  } = size;
    if (xAlign === 'right') {
        x -= width;
    } else if (xAlign === 'center') {
        x -= width / 2;
    }
    return x;
}
function alignY(size, yAlign, paddingAndSize) {
    let { y , height  } = size;
    if (yAlign === 'top') {
        y += paddingAndSize;
    } else if (yAlign === 'bottom') {
        y -= height + paddingAndSize;
    } else {
        y -= height / 2;
    }
    return y;
}
 function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize , caretPadding , cornerRadius  } = options;
    const { xAlign , yAlign  } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);
    let x = alignX(size, xAlign);
    const y = alignY(size, yAlign, paddingAndSize);
    if (yAlign === 'center') {
        if (xAlign === 'left') {
            x += paddingAndSize;
        } else if (xAlign === 'right') {
            x -= paddingAndSize;
        }
    } else if (xAlign === 'left') {
        x -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === 'right') {
        x += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
        x: _limitValue(x, 0, chart.width - size.width),
        y: _limitValue(y, 0, chart.height - size.height)
    };
}
function getAlignedX(tooltip, align, options) {
    const padding = toPadding(options.padding);
    return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
 function getBeforeAfterBodyLines(callback) {
    return pushOrConcat([], splitNewlines(callback));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext(parent, {
        tooltip,
        tooltipItems,
        type: 'tooltip'
    });
}
function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
}
const defaultCallbacks = {
    beforeTitle: noop,
    title (tooltipItems) {
        if (tooltipItems.length > 0) {
            const item = tooltipItems[0];
            const labels = item.chart.data.labels;
            const labelCount = labels ? labels.length : 0;
            if (this && this.options && this.options.mode === 'dataset') {
                return item.dataset.label || '';
            } else if (item.label) {
                return item.label;
            } else if (labelCount > 0 && item.dataIndex < labelCount) {
                return labels[item.dataIndex];
            }
        }
        return '';
    },
    afterTitle: noop,
    beforeBody: noop,
    beforeLabel: noop,
    label (tooltipItem) {
        if (this && this.options && this.options.mode === 'dataset') {
            return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || '';
        if (label) {
            label += ': ';
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
            label += value;
        }
        return label;
    },
    labelColor (tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
            borderColor: options.borderColor,
            backgroundColor: options.backgroundColor,
            borderWidth: options.borderWidth,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderRadius: 0
        };
    },
    labelTextColor () {
        return this.options.bodyColor;
    },
    labelPointStyle (tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
            pointStyle: options.pointStyle,
            rotation: options.rotation
        };
    },
    afterLabel: noop,
    afterBody: noop,
    beforeFooter: noop,
    footer: noop,
    afterFooter: noop
};
 function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    const result = callbacks[name].call(ctx, arg);
    if (typeof result === 'undefined') {
        return defaultCallbacks[name].call(ctx, arg);
    }
    return result;
}
class Tooltip extends Element$1 {
 static positioners = positioners;
    constructor(config){
        super();
        this.opacity = 0;
        this._active = [];
        this._eventPosition = undefined;
        this._size = undefined;
        this._cachedAnimations = undefined;
        this._tooltipItems = [];
        this.$animations = undefined;
        this.$context = undefined;
        this.chart = config.chart;
        this.options = config.options;
        this.dataPoints = undefined;
        this.title = undefined;
        this.beforeBody = undefined;
        this.body = undefined;
        this.afterBody = undefined;
        this.footer = undefined;
        this.xAlign = undefined;
        this.yAlign = undefined;
        this.x = undefined;
        this.y = undefined;
        this.height = undefined;
        this.width = undefined;
        this.caretX = undefined;
        this.caretY = undefined;
        this.labelColors = undefined;
        this.labelPointStyles = undefined;
        this.labelTextColors = undefined;
    }
    initialize(options) {
        this.options = options;
        this._cachedAnimations = undefined;
        this.$context = undefined;
    }
 _resolveAnimations() {
        const cached = this._cachedAnimations;
        if (cached) {
            return cached;
        }
        const chart = this.chart;
        const options = this.options.setContext(this.getContext());
        const opts = options.enabled && chart.options.animation && options.animations;
        const animations = new Animations(this.chart, opts);
        if (opts._cacheable) {
            this._cachedAnimations = Object.freeze(animations);
        }
        return animations;
    }
 getContext() {
        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options) {
        const { callbacks  } = options;
        const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);
        const title = invokeCallbackWithFallback(callbacks, 'title', this, context);
        const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
    }
    getBeforeBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));
    }
    getBody(tooltipItems, options) {
        const { callbacks  } = options;
        const bodyItems = [];
        each(tooltipItems, (context)=>{
            const bodyItem = {
                before: [],
                lines: [],
                after: []
            };
            const scoped = overrideCallbacks(callbacks, context);
            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));
            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));
            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));
            bodyItems.push(bodyItem);
        });
        return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));
    }
    getFooter(tooltipItems, options) {
        const { callbacks  } = options;
        const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);
        const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);
        const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
    }
 _createItems(options) {
        const active = this._active;
        const data = this.chart.data;
        const labelColors = [];
        const labelPointStyles = [];
        const labelTextColors = [];
        let tooltipItems = [];
        let i, len;
        for(i = 0, len = active.length; i < len; ++i){
            tooltipItems.push(createTooltipItem(this.chart, active[i]));
        }
        if (options.filter) {
            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));
        }
        if (options.itemSort) {
            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));
        }
        each(tooltipItems, (context)=>{
            const scoped = overrideCallbacks(options.callbacks, context);
            labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));
            labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));
            labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));
        });
        this.labelColors = labelColors;
        this.labelPointStyles = labelPointStyles;
        this.labelTextColors = labelTextColors;
        this.dataPoints = tooltipItems;
        return tooltipItems;
    }
    update(changed, replay) {
        const options = this.options.setContext(this.getContext());
        const active = this._active;
        let properties;
        let tooltipItems = [];
        if (!active.length) {
            if (this.opacity !== 0) {
                properties = {
                    opacity: 0
                };
            }
        } else {
            const position = positioners[options.position].call(this, active, this._eventPosition);
            tooltipItems = this._createItems(options);
            this.title = this.getTitle(tooltipItems, options);
            this.beforeBody = this.getBeforeBody(tooltipItems, options);
            this.body = this.getBody(tooltipItems, options);
            this.afterBody = this.getAfterBody(tooltipItems, options);
            this.footer = this.getFooter(tooltipItems, options);
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, size);
            const alignment = determineAlignment(this.chart, options, positionAndSize);
            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
            this.xAlign = alignment.xAlign;
            this.yAlign = alignment.yAlign;
            properties = {
                opacity: 1,
                x: backgroundPoint.x,
                y: backgroundPoint.y,
                width: size.width,
                height: size.height,
                caretX: position.x,
                caretY: position.y
            };
        }
        this._tooltipItems = tooltipItems;
        this.$context = undefined;
        if (properties) {
            this._resolveAnimations().update(this, properties);
        }
        if (changed && options.external) {
            options.external.call(this, {
                chart: this.chart,
                tooltip: this,
                replay
            });
        }
    }
    drawCaret(tooltipPoint, ctx, size, options) {
        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
        const { xAlign , yAlign  } = this;
        const { caretSize , cornerRadius  } = options;
        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);
        const { x: ptX , y: ptY  } = tooltipPoint;
        const { width , height  } = size;
        let x1, x2, x3, y1, y2, y3;
        if (yAlign === 'center') {
            y2 = ptY + height / 2;
            if (xAlign === 'left') {
                x1 = ptX;
                x2 = x1 - caretSize;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
            } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
            }
            x3 = x1;
        } else {
            if (xAlign === 'left') {
                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
            } else if (xAlign === 'right') {
                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
            } else {
                x2 = this.caretX;
            }
            if (yAlign === 'top') {
                y1 = ptY;
                y2 = y1 - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
            } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                x1 = x2 + caretSize;
                x3 = x2 - caretSize;
            }
            y3 = y1;
        }
        return {
            x1,
            x2,
            x3,
            y1,
            y2,
            y3
        };
    }
    drawTitle(pt, ctx, options) {
        const title = this.title;
        const length = title.length;
        let titleFont, titleSpacing, i;
        if (length) {
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.titleAlign, options);
            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
            ctx.textBaseline = 'middle';
            titleFont = toFont(options.titleFont);
            titleSpacing = options.titleSpacing;
            ctx.fillStyle = options.titleColor;
            ctx.font = titleFont.string;
            for(i = 0; i < length; ++i){
                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                pt.y += titleFont.lineHeight + titleSpacing;
                if (i + 1 === length) {
                    pt.y += options.titleMarginBottom - titleSpacing;
                }
            }
        }
    }
 _drawColorBox(ctx, pt, i, rtlHelper, options) {
        const labelColor = this.labelColors[i];
        const labelPointStyle = this.labelPointStyles[i];
        const { boxHeight , boxWidth  } = options;
        const bodyFont = toFont(options.bodyFont);
        const colorX = getAlignedX(this, 'left', options);
        const rtlColorX = rtlHelper.x(colorX);
        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
        const colorY = pt.y + yOffSet;
        if (options.usePointStyle) {
            const drawOptions = {
                radius: Math.min(boxWidth, boxHeight) / 2,
                pointStyle: labelPointStyle.pointStyle,
                rotation: labelPointStyle.rotation,
                borderWidth: 1
            };
            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
            const centerY = colorY + boxHeight / 2;
            ctx.strokeStyle = options.multiKeyBackground;
            ctx.fillStyle = options.multiKeyBackground;
            drawPoint(ctx, drawOptions, centerX, centerY);
            ctx.strokeStyle = labelColor.borderColor;
            ctx.fillStyle = labelColor.backgroundColor;
            drawPoint(ctx, drawOptions, centerX, centerY);
        } else {
            ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
            ctx.strokeStyle = labelColor.borderColor;
            ctx.setLineDash(labelColor.borderDash || []);
            ctx.lineDashOffset = labelColor.borderDashOffset || 0;
            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
            const borderRadius = toTRBLCorners(labelColor.borderRadius);
            if (Object.values(borderRadius).some((v)=>v !== 0)) {
                ctx.beginPath();
                ctx.fillStyle = options.multiKeyBackground;
                addRoundedRectPath(ctx, {
                    x: outerX,
                    y: colorY,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius
                });
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = labelColor.backgroundColor;
                ctx.beginPath();
                addRoundedRectPath(ctx, {
                    x: innerX,
                    y: colorY + 1,
                    w: boxWidth - 2,
                    h: boxHeight - 2,
                    radius: borderRadius
                });
                ctx.fill();
            } else {
                ctx.fillStyle = options.multiKeyBackground;
                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                ctx.fillStyle = labelColor.backgroundColor;
                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
            }
        }
        ctx.fillStyle = this.labelTextColors[i];
    }
    drawBody(pt, ctx, options) {
        const { body  } = this;
        const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;
        const bodyFont = toFont(options.bodyFont);
        let bodyLineHeight = bodyFont.lineHeight;
        let xLinePadding = 0;
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        const fillLineOfText = function(line) {
            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
            pt.y += bodyLineHeight + bodySpacing;
        };
        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
        let bodyItem, textColor, lines, i, j, ilen, jlen;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = 'middle';
        ctx.font = bodyFont.string;
        pt.x = getAlignedX(this, bodyAlignForCalculation, options);
        ctx.fillStyle = options.bodyColor;
        each(this.beforeBody, fillLineOfText);
        xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
        for(i = 0, ilen = body.length; i < ilen; ++i){
            bodyItem = body[i];
            textColor = this.labelTextColors[i];
            ctx.fillStyle = textColor;
            each(bodyItem.before, fillLineOfText);
            lines = bodyItem.lines;
            if (displayColors && lines.length) {
                this._drawColorBox(ctx, pt, i, rtlHelper, options);
                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
            }
            for(j = 0, jlen = lines.length; j < jlen; ++j){
                fillLineOfText(lines[j]);
                bodyLineHeight = bodyFont.lineHeight;
            }
            each(bodyItem.after, fillLineOfText);
        }
        xLinePadding = 0;
        bodyLineHeight = bodyFont.lineHeight;
        each(this.afterBody, fillLineOfText);
        pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options) {
        const footer = this.footer;
        const length = footer.length;
        let footerFont, i;
        if (length) {
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.footerAlign, options);
            pt.y += options.footerMarginTop;
            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
            ctx.textBaseline = 'middle';
            footerFont = toFont(options.footerFont);
            ctx.fillStyle = options.footerColor;
            ctx.font = footerFont.string;
            for(i = 0; i < length; ++i){
                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                pt.y += footerFont.lineHeight + options.footerSpacing;
            }
        }
    }
    drawBackground(pt, ctx, tooltipSize, options) {
        const { xAlign , yAlign  } = this;
        const { x , y  } = pt;
        const { width , height  } = tooltipSize;
        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(options.cornerRadius);
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.beginPath();
        ctx.moveTo(x + topLeft, y);
        if (yAlign === 'top') {
            this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width - topRight, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
        if (yAlign === 'center' && xAlign === 'right') {
            this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width, y + height - bottomRight);
        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
        if (yAlign === 'bottom') {
            this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + bottomLeft, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
        if (yAlign === 'center' && xAlign === 'left') {
            this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x, y + topLeft);
        ctx.quadraticCurveTo(x, y, x + topLeft, y);
        ctx.closePath();
        ctx.fill();
        if (options.borderWidth > 0) {
            ctx.stroke();
        }
    }
 _updateAnimationTarget(options) {
        const chart = this.chart;
        const anims = this.$animations;
        const animX = anims && anims.x;
        const animY = anims && anims.y;
        if (animX || animY) {
            const position = positioners[options.position].call(this, this._active, this._eventPosition);
            if (!position) {
                return;
            }
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, this._size);
            const alignment = determineAlignment(chart, options, positionAndSize);
            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
            if (animX._to !== point.x || animY._to !== point.y) {
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                this.width = size.width;
                this.height = size.height;
                this.caretX = position.x;
                this.caretY = position.y;
                this._resolveAnimations().update(this, point);
            }
        }
    }
 _willRender() {
        return !!this.opacity;
    }
    draw(ctx) {
        const options = this.options.setContext(this.getContext());
        let opacity = this.opacity;
        if (!opacity) {
            return;
        }
        this._updateAnimationTarget(options);
        const tooltipSize = {
            width: this.width,
            height: this.height
        };
        const pt = {
            x: this.x,
            y: this.y
        };
        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
        const padding = toPadding(options.padding);
        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
        if (options.enabled && hasTooltipContent) {
            ctx.save();
            ctx.globalAlpha = opacity;
            this.drawBackground(pt, ctx, tooltipSize, options);
            overrideTextDirection(ctx, options.textDirection);
            pt.y += padding.top;
            this.drawTitle(pt, ctx, options);
            this.drawBody(pt, ctx, options);
            this.drawFooter(pt, ctx, options);
            restoreTextDirection(ctx, options.textDirection);
            ctx.restore();
        }
    }
 getActiveElements() {
        return this._active || [];
    }
 setActiveElements(activeElements, eventPosition) {
        const lastActive = this._active;
        const active = activeElements.map(({ datasetIndex , index  })=>{
            const meta = this.chart.getDatasetMeta(datasetIndex);
            if (!meta) {
                throw new Error('Cannot find a dataset at index ' + datasetIndex);
            }
            return {
                datasetIndex,
                element: meta.data[index],
                index
            };
        });
        const changed = !_elementsEqual(lastActive, active);
        const positionChanged = this._positionChanged(active, eventPosition);
        if (changed || positionChanged) {
            this._active = active;
            this._eventPosition = eventPosition;
            this._ignoreReplayEvents = true;
            this.update(true);
        }
    }
 handleEvent(e, replay, inChartArea = true) {
        if (replay && this._ignoreReplayEvents) {
            return false;
        }
        this._ignoreReplayEvents = false;
        const options = this.options;
        const lastActive = this._active || [];
        const active = this._getActiveElements(e, lastActive, replay, inChartArea);
        const positionChanged = this._positionChanged(active, e);
        const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
        if (changed) {
            this._active = active;
            if (options.enabled || options.external) {
                this._eventPosition = {
                    x: e.x,
                    y: e.y
                };
                this.update(true, replay);
            }
        }
        return changed;
    }
 _getActiveElements(e, lastActive, replay, inChartArea) {
        const options = this.options;
        if (e.type === 'mouseout') {
            return [];
        }
        if (!inChartArea) {
            return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);
        }
        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
        if (options.reverse) {
            active.reverse();
        }
        return active;
    }
 _positionChanged(active, e) {
        const { caretX , caretY , options  } = this;
        const position = positioners[options.position].call(this, active, e);
        return position !== false && (caretX !== position.x || caretY !== position.y);
    }
}
var plugin_tooltip = {
    id: 'tooltip',
    _element: Tooltip,
    positioners,
    afterInit (chart, _args, options) {
        if (options) {
            chart.tooltip = new Tooltip({
                chart,
                options
            });
        }
    },
    beforeUpdate (chart, _args, options) {
        if (chart.tooltip) {
            chart.tooltip.initialize(options);
        }
    },
    reset (chart, _args, options) {
        if (chart.tooltip) {
            chart.tooltip.initialize(options);
        }
    },
    afterDraw (chart) {
        const tooltip = chart.tooltip;
        if (tooltip && tooltip._willRender()) {
            const args = {
                tooltip
            };
            if (chart.notifyPlugins('beforeTooltipDraw', {
                ...args,
                cancelable: true
            }) === false) {
                return;
            }
            tooltip.draw(chart.ctx);
            chart.notifyPlugins('afterTooltipDraw', args);
        }
    },
    afterEvent (chart, args) {
        if (chart.tooltip) {
            const useFinalPosition = args.replay;
            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
                args.changed = true;
            }
        }
    },
    defaults: {
        enabled: true,
        external: null,
        position: 'average',
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleColor: '#fff',
        titleFont: {
            weight: 'bold'
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: 'left',
        bodyColor: '#fff',
        bodySpacing: 2,
        bodyFont: {},
        bodyAlign: 'left',
        footerColor: '#fff',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
            weight: 'bold'
        },
        footerAlign: 'left',
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: (ctx, opts)=>opts.bodyFont.size,
        boxWidth: (ctx, opts)=>opts.bodyFont.size,
        multiKeyBackground: '#fff',
        displayColors: true,
        boxPadding: 0,
        borderColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        animation: {
            duration: 400,
            easing: 'easeOutQuart'
        },
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'width',
                    'height',
                    'caretX',
                    'caretY'
                ]
            },
            opacity: {
                easing: 'linear',
                duration: 200
            }
        },
        callbacks: defaultCallbacks
    },
    defaultRoutes: {
        bodyFont: 'font',
        footerFont: 'font',
        titleFont: 'font'
    },
    descriptors: {
        _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',
        _indexable: false,
        callbacks: {
            _scriptable: false,
            _indexable: false
        },
        animation: {
            _fallback: false
        },
        animations: {
            _fallback: 'animation'
        }
    },
    additionalOptionScopes: [
        'interaction'
    ]
};

var plugins = /*#__PURE__*/Object.freeze({
__proto__: null,
Colors: plugin_colors,
Decimation: plugin_decimation,
Filler: index,
Legend: plugin_legend,
SubTitle: plugin_subtitle,
Title: plugin_title,
Tooltip: plugin_tooltip
});

const addIfString = (labels, raw, index, addedLabels)=>{
    if (typeof raw === 'string') {
        index = labels.push(raw) - 1;
        addedLabels.unshift({
            index,
            label: raw
        });
    } else if (isNaN(raw)) {
        index = null;
    }
    return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
        return addIfString(labels, raw, index, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first !== last ? index : first;
}
const validIndex = (index, max)=>index === null ? null : _limitValue(Math.round(index), 0, max);
function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
        return labels[value];
    }
    return value;
}
class CategoryScale extends Scale {
    static id = 'category';
 static defaults = {
        ticks: {
            callback: _getLabelForValue
        }
    };
    constructor(cfg){
        super(cfg);
         this._startValue = undefined;
        this._valueRange = 0;
        this._addedLabels = [];
    }
    init(scaleOptions) {
        const added = this._addedLabels;
        if (added.length) {
            const labels = this.getLabels();
            for (const { index , label  } of added){
                if (labels[index] === label) {
                    labels.splice(index, 1);
                }
            }
            this._addedLabels = [];
        }
        super.init(scaleOptions);
    }
    parse(raw, index) {
        if (isNullOrUndef(raw)) {
            return null;
        }
        const labels = this.getLabels();
        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
        return validIndex(index, labels.length - 1);
    }
    determineDataLimits() {
        const { minDefined , maxDefined  } = this.getUserBounds();
        let { min , max  } = this.getMinMax(true);
        if (this.options.bounds === 'ticks') {
            if (!minDefined) {
                min = 0;
            }
            if (!maxDefined) {
                max = this.getLabels().length - 1;
            }
        }
        this.min = min;
        this.max = max;
    }
    buildTicks() {
        const min = this.min;
        const max = this.max;
        const offset = this.options.offset;
        const ticks = [];
        let labels = this.getLabels();
        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
        this._startValue = this.min - (offset ? 0.5 : 0);
        for(let value = min; value <= max; value++){
            ticks.push({
                value
            });
        }
        return ticks;
    }
    getLabelForValue(value) {
        return _getLabelForValue.call(this, value);
    }
 configure() {
        super.configure();
        if (!this.isHorizontal()) {
            this._reversePixels = !this._reversePixels;
        }
    }
    getPixelForValue(value) {
        if (typeof value !== 'number') {
            value = this.parse(value);
        }
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) {
            return null;
        }
        return this.getPixelForValue(ticks[index].value);
    }
    getValueForPixel(pixel) {
        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
        return this.bottom;
    }
}

function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin , max: rmax  } = dataRange;
    const minDefined = !isNullOrUndef(min);
    const maxDefined = !isNullOrUndef(max);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
        return [
            {
                value: rmin
            },
            {
                value: rmax
            }
        ];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
        spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === 'ticks') {
        niceMin = Math.floor(rmin / spacing) * spacing;
        niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
        niceMin = rmin;
        niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {
        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
        spacing = (max - min) / numSpaces;
        niceMin = min;
        niceMax = max;
    } else if (countDefined) {
        niceMin = minDefined ? min : niceMin;
        niceMax = maxDefined ? max : niceMax;
        numSpaces = count - 1;
        spacing = (niceMax - niceMin) / numSpaces;
    } else {
        numSpaces = (niceMax - niceMin) / spacing;
        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
            numSpaces = Math.round(numSpaces);
        } else {
            numSpaces = Math.ceil(numSpaces);
        }
    }
    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
        if (includeBounds && niceMin !== min) {
            ticks.push({
                value: min
            });
            if (niceMin < min) {
                j++;
            }
            if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
                j++;
            }
        } else if (niceMin < min) {
            j++;
        }
    }
    for(; j < numSpaces; ++j){
        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
        if (maxDefined && tickValue > max) {
            break;
        }
        ticks.push({
            value: tickValue
        });
    }
    if (maxDefined && includeBounds && niceMax !== max) {
        if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
            ticks[ticks.length - 1].value = max;
        } else {
            ticks.push({
                value: max
            });
        }
    } else if (!maxDefined || niceMax === max) {
        ticks.push({
            value: niceMax
        });
    }
    return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
    const length = 0.75 * minSpacing * ('' + value).length;
    return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
    constructor(cfg){
        super(cfg);
         this.start = undefined;
         this.end = undefined;
         this._startValue = undefined;
         this._endValue = undefined;
        this._valueRange = 0;
    }
    parse(raw, index) {
        if (isNullOrUndef(raw)) {
            return null;
        }
        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {
            return null;
        }
        return +raw;
    }
    handleTickRangeOptions() {
        const { beginAtZero  } = this.options;
        const { minDefined , maxDefined  } = this.getUserBounds();
        let { min , max  } = this;
        const setMin = (v)=>min = minDefined ? min : v;
        const setMax = (v)=>max = maxDefined ? max : v;
        if (beginAtZero) {
            const minSign = sign(min);
            const maxSign = sign(max);
            if (minSign < 0 && maxSign < 0) {
                setMax(0);
            } else if (minSign > 0 && maxSign > 0) {
                setMin(0);
            }
        }
        if (min === max) {
            let offset = max === 0 ? 1 : Math.abs(max * 0.05);
            setMax(max + offset);
            if (!beginAtZero) {
                setMin(min - offset);
            }
        }
        this.min = min;
        this.max = max;
    }
    getTickLimit() {
        const tickOpts = this.options.ticks;
        let { maxTicksLimit , stepSize  } = tickOpts;
        let maxTicks;
        if (stepSize) {
            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
            if (maxTicks > 1000) {
                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                maxTicks = 1000;
            }
        } else {
            maxTicks = this.computeTickLimit();
            maxTicksLimit = maxTicksLimit || 11;
        }
        if (maxTicksLimit) {
            maxTicks = Math.min(maxTicksLimit, maxTicks);
        }
        return maxTicks;
    }
 computeTickLimit() {
        return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
        const opts = this.options;
        const tickOpts = opts.ticks;
        let maxTicks = this.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        const numericGeneratorOptions = {
            maxTicks,
            bounds: opts.bounds,
            min: opts.min,
            max: opts.max,
            precision: tickOpts.precision,
            step: tickOpts.stepSize,
            count: tickOpts.count,
            maxDigits: this._maxDigits(),
            horizontal: this.isHorizontal(),
            minRotation: tickOpts.minRotation || 0,
            includeBounds: tickOpts.includeBounds !== false
        };
        const dataRange = this._range || this;
        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
        if (opts.bounds === 'ticks') {
            _setMinAndMaxByKey(ticks, this, 'value');
        }
        if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
        } else {
            this.start = this.min;
            this.end = this.max;
        }
        return ticks;
    }
 configure() {
        const ticks = this.ticks;
        let start = this.min;
        let end = this.max;
        super.configure();
        if (this.options.offset && ticks.length) {
            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
            start -= offset;
            end += offset;
        }
        this._startValue = start;
        this._endValue = end;
        this._valueRange = end - start;
    }
    getLabelForValue(value) {
        return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
}

class LinearScale extends LinearScaleBase {
    static id = 'linear';
 static defaults = {
        ticks: {
            callback: Ticks.formatters.numeric
        }
    };
    determineDataLimits() {
        const { min , max  } = this.getMinMax(true);
        this.min = isNumberFinite(min) ? min : 0;
        this.max = isNumberFinite(max) ? max : 1;
        this.handleTickRangeOptions();
    }
 computeTickLimit() {
        const horizontal = this.isHorizontal();
        const length = horizontal ? this.width : this.height;
        const minRotation = toRadians(this.options.ticks.minRotation);
        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
        const tickFont = this._resolveTickFontOptions(0);
        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
}

const log10Floor = (v)=>Math.floor(log10(v));
const changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
}
function steps(min, max, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start = Math.floor(min / rangeStep);
    const end = Math.ceil(max / rangeStep);
    return end - start;
}
function startExp(min, max) {
    const range = max - min;
    let rangeExp = log10Floor(range);
    while(steps(min, max, rangeExp) > 10){
        rangeExp++;
    }
    while(steps(min, max, rangeExp) < 10){
        rangeExp--;
    }
    return Math.min(rangeExp, log10Floor(min));
}
 function generateTicks(generationOptions, { min , max  }) {
    min = finiteOrDefault(generationOptions.min, min);
    const ticks = [];
    const minExp = log10Floor(min);
    let exp = startExp(min, max);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base = minExp > exp ? Math.pow(10, minExp) : 0;
    const start = Math.round((min - base) * precision) / precision;
    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start - offset) / Math.pow(10, exp));
    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
    while(value < max){
        ticks.push({
            value,
            major: isMajor(value),
            significand
        });
        if (significand >= 10) {
            significand = significand < 15 ? 15 : 20;
        } else {
            significand++;
        }
        if (significand >= 20) {
            exp++;
            significand = 2;
            precision = exp >= 0 ? 1 : precision;
        }
        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = finiteOrDefault(generationOptions.max, value);
    ticks.push({
        value: lastTick,
        major: isMajor(lastTick),
        significand
    });
    return ticks;
}
class LogarithmicScale extends Scale {
    static id = 'logarithmic';
 static defaults = {
        ticks: {
            callback: Ticks.formatters.logarithmic,
            major: {
                enabled: true
            }
        }
    };
    constructor(cfg){
        super(cfg);
         this.start = undefined;
         this.end = undefined;
         this._startValue = undefined;
        this._valueRange = 0;
    }
    parse(raw, index) {
        const value = LinearScaleBase.prototype.parse.apply(this, [
            raw,
            index
        ]);
        if (value === 0) {
            this._zero = true;
            return undefined;
        }
        return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
        const { min , max  } = this.getMinMax(true);
        this.min = isNumberFinite(min) ? Math.max(0, min) : null;
        this.max = isNumberFinite(max) ? Math.max(0, max) : null;
        if (this.options.beginAtZero) {
            this._zero = true;
        }
        if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
        }
        this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
        const { minDefined , maxDefined  } = this.getUserBounds();
        let min = this.min;
        let max = this.max;
        const setMin = (v)=>min = minDefined ? min : v;
        const setMax = (v)=>max = maxDefined ? max : v;
        if (min === max) {
            if (min <= 0) {
                setMin(1);
                setMax(10);
            } else {
                setMin(changeExponent(min, -1));
                setMax(changeExponent(max, 1));
            }
        }
        if (min <= 0) {
            setMin(changeExponent(max, -1));
        }
        if (max <= 0) {
            setMax(changeExponent(min, 1));
        }
        this.min = min;
        this.max = max;
    }
    buildTicks() {
        const opts = this.options;
        const generationOptions = {
            min: this._userMin,
            max: this._userMax
        };
        const ticks = generateTicks(generationOptions, this);
        if (opts.bounds === 'ticks') {
            _setMinAndMaxByKey(ticks, this, 'value');
        }
        if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
        } else {
            this.start = this.min;
            this.end = this.max;
        }
        return ticks;
    }
 getLabelForValue(value) {
        return value === undefined ? '0' : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
 configure() {
        const start = this.min;
        super.configure();
        this._startValue = log10(start);
        this._valueRange = log10(this.max) - log10(start);
    }
    getPixelForValue(value) {
        if (value === undefined || value === 0) {
            value = this.min;
        }
        if (value === null || isNaN(value)) {
            return NaN;
        }
        return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
        const decimal = this.getDecimalForPixel(pixel);
        return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
}

function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
        const padding = toPadding(tickOpts.backdropPadding);
        return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
    }
    return 0;
}
function measureLabelSize(ctx, font, label) {
    label = isArray(label) ? label : [
        label
    ];
    return {
        w: _longestText(ctx, font.string, label),
        h: label.length * font.lineHeight
    };
}
function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) {
        return {
            start: pos - size / 2,
            end: pos + size / 2
        };
    } else if (angle < min || angle > max) {
        return {
            start: pos - size,
            end: pos
        };
    }
    return {
        start: pos,
        end: pos + size
    };
}
 function fitWithPointLabels(scale) {
    const orig = {
        l: scale.left + scale._padding.left,
        r: scale.right - scale._padding.right,
        t: scale.top + scale._padding.top,
        b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for(let i = 0; i < valueCount; i++){
        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
        padding[i] = opts.padding;
        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
        const plFont = toFont(opts.font);
        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
        labelSizes[i] = textSize;
        const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
        const angle = Math.round(toDegrees(angleRadians));
        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
        updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x = 0;
    let y = 0;
    if (hLimits.start < orig.l) {
        x = (orig.l - hLimits.start) / sin;
        limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
        x = (hLimits.end - orig.r) / sin;
        limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
        y = (orig.t - vLimits.start) / cos;
        limits.t = Math.min(limits.t, orig.t - y);
    } else if (vLimits.end > orig.b) {
        y = (vLimits.end - orig.b) / cos;
        limits.b = Math.max(limits.b, orig.b + y);
    }
}
function createPointLabelItem(scale, index, itemOpts) {
    const outerDistance = scale.drawingArea;
    const { extra , additionalAngle , padding , size  } = itemOpts;
    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    return {
        visible: true,
        x: pointLabelPosition.x,
        y,
        textAlign,
        left,
        top: y,
        right: left + size.w,
        bottom: y + size.h
    };
}
function isNotOverlapped(item, area) {
    if (!area) {
        return true;
    }
    const { left , top , right , bottom  } = item;
    const apexesInArea = _isPointInArea({
        x: left,
        y: top
    }, area) || _isPointInArea({
        x: left,
        y: bottom
    }, area) || _isPointInArea({
        x: right,
        y: top
    }, area) || _isPointInArea({
        x: right,
        y: bottom
    }, area);
    return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const { centerPointLabels , display  } = opts.pointLabels;
    const itemOpts = {
        extra: getTickBackdropHeight(opts) / 2,
        additionalAngle: centerPointLabels ? PI / valueCount : 0
    };
    let area;
    for(let i = 0; i < valueCount; i++){
        itemOpts.padding = padding[i];
        itemOpts.size = labelSizes[i];
        const item = createPointLabelItem(scale, i, itemOpts);
        items.push(item);
        if (display === 'auto') {
            item.visible = isNotOverlapped(item, area);
            if (item.visible) {
                area = item;
            }
        }
    }
    return items;
}
function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
        return 'center';
    } else if (angle < 180) {
        return 'left';
    }
    return 'right';
}
function leftForTextAlign(x, w, align) {
    if (align === 'right') {
        x -= w;
    } else if (align === 'center') {
        x -= w / 2;
    }
    return x;
}
function yForAngle(y, h, angle) {
    if (angle === 90 || angle === 270) {
        y -= h / 2;
    } else if (angle > 270 || angle < 90) {
        y -= h;
    }
    return y;
}
function drawPointLabelBox(ctx, opts, item) {
    const { left , top , right , bottom  } = item;
    const { backdropColor  } = opts;
    if (!isNullOrUndef(backdropColor)) {
        const borderRadius = toTRBLCorners(opts.borderRadius);
        const padding = toPadding(opts.backdropPadding);
        ctx.fillStyle = backdropColor;
        const backdropLeft = left - padding.left;
        const backdropTop = top - padding.top;
        const backdropWidth = right - left + padding.width;
        const backdropHeight = bottom - top + padding.height;
        if (Object.values(borderRadius).some((v)=>v !== 0)) {
            ctx.beginPath();
            addRoundedRectPath(ctx, {
                x: backdropLeft,
                y: backdropTop,
                w: backdropWidth,
                h: backdropHeight,
                radius: borderRadius
            });
            ctx.fill();
        } else {
            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
        }
    }
}
function drawPointLabels(scale, labelCount) {
    const { ctx , options: { pointLabels  }  } = scale;
    for(let i = labelCount - 1; i >= 0; i--){
        const item = scale._pointLabelItems[i];
        if (!item.visible) {
            continue;
        }
        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
        drawPointLabelBox(ctx, optsAtIndex, item);
        const plFont = toFont(optsAtIndex.font);
        const { x , y , textAlign  } = item;
        renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
            color: optsAtIndex.color,
            textAlign: textAlign,
            textBaseline: 'middle'
        });
    }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx  } = scale;
    if (circular) {
        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
    } else {
        let pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);
        for(let i = 1; i < labelCount; i++){
            pointPosition = scale.getPointPosition(i, radius);
            ctx.lineTo(pointPosition.x, pointPosition.y);
        }
    }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color , lineWidth  } = gridLineOpts;
    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {
        return;
    }
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash || []);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
}
function createPointLabelContext(parent, index, label) {
    return createContext(parent, {
        label,
        index,
        type: 'pointLabel'
    });
}
class RadialLinearScale extends LinearScaleBase {
    static id = 'radialLinear';
 static defaults = {
        display: true,
        animate: true,
        position: 'chartArea',
        angleLines: {
            display: true,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0.0
        },
        grid: {
            circular: false
        },
        startAngle: 0,
        ticks: {
            showLabelBackdrop: true,
            callback: Ticks.formatters.numeric
        },
        pointLabels: {
            backdropColor: undefined,
            backdropPadding: 2,
            display: true,
            font: {
                size: 10
            },
            callback (label) {
                return label;
            },
            padding: 5,
            centerPointLabels: false
        }
    };
    static defaultRoutes = {
        'angleLines.color': 'borderColor',
        'pointLabels.color': 'color',
        'ticks.color': 'color'
    };
    static descriptors = {
        angleLines: {
            _fallback: 'grid'
        }
    };
    constructor(cfg){
        super(cfg);
         this.xCenter = undefined;
         this.yCenter = undefined;
         this.drawingArea = undefined;
         this._pointLabels = [];
        this._pointLabelItems = [];
    }
    setDimensions() {
        const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
        const w = this.width = this.maxWidth - padding.width;
        const h = this.height = this.maxHeight - padding.height;
        this.xCenter = Math.floor(this.left + w / 2 + padding.left);
        this.yCenter = Math.floor(this.top + h / 2 + padding.top);
        this.drawingArea = Math.floor(Math.min(w, h) / 2);
    }
    determineDataLimits() {
        const { min , max  } = this.getMinMax(false);
        this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
        this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
        this.handleTickRangeOptions();
    }
 computeTickLimit() {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
        this._pointLabels = this.getLabels().map((value, index)=>{
            const label = callback(this.options.pointLabels.callback, [
                value,
                index
            ], this);
            return label || label === 0 ? label : '';
        }).filter((v, i)=>this.chart.getDataVisibility(i));
    }
    fit() {
        const opts = this.options;
        if (opts.display && opts.pointLabels.display) {
            fitWithPointLabels(this);
        } else {
            this.setCenterPoint(0, 0, 0, 0);
        }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index) {
        const angleMultiplier = TAU / (this._pointLabels.length || 1);
        const startAngle = this.options.startAngle || 0;
        return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
        if (isNullOrUndef(value)) {
            return NaN;
        }
        const scalingFactor = this.drawingArea / (this.max - this.min);
        if (this.options.reverse) {
            return (this.max - value) * scalingFactor;
        }
        return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
        if (isNullOrUndef(distance)) {
            return NaN;
        }
        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index) {
        const pointLabels = this._pointLabels || [];
        if (index >= 0 && index < pointLabels.length) {
            const pointLabel = pointLabels[index];
            return createPointLabelContext(this.getContext(), index, pointLabel);
        }
    }
    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
        const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
        return {
            x: Math.cos(angle) * distanceFromCenter + this.xCenter,
            y: Math.sin(angle) * distanceFromCenter + this.yCenter,
            angle
        };
    }
    getPointPositionForValue(index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index) {
        return this.getPointPositionForValue(index || 0, this.getBaseValue());
    }
    getPointLabelPosition(index) {
        const { left , top , right , bottom  } = this._pointLabelItems[index];
        return {
            left,
            top,
            right,
            bottom
        };
    }
 drawBackground() {
        const { backgroundColor , grid: { circular  }  } = this.options;
        if (backgroundColor) {
            const ctx = this.ctx;
            ctx.save();
            ctx.beginPath();
            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
            ctx.closePath();
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
        }
    }
 drawGrid() {
        const ctx = this.ctx;
        const opts = this.options;
        const { angleLines , grid , border  } = opts;
        const labelCount = this._pointLabels.length;
        let i, offset, position;
        if (opts.pointLabels.display) {
            drawPointLabels(this, labelCount);
        }
        if (grid.display) {
            this.ticks.forEach((tick, index)=>{
                if (index !== 0 || index === 0 && this.min < 0) {
                    offset = this.getDistanceFromCenterForValue(tick.value);
                    const context = this.getContext(index);
                    const optsAtIndex = grid.setContext(context);
                    const optsAtIndexBorder = border.setContext(context);
                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
                }
            });
        }
        if (angleLines.display) {
            ctx.save();
            for(i = labelCount - 1; i >= 0; i--){
                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                const { color , lineWidth  } = optsAtIndex;
                if (!lineWidth || !color) {
                    continue;
                }
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color;
                ctx.setLineDash(optsAtIndex.borderDash);
                ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
                position = this.getPointPosition(i, offset);
                ctx.beginPath();
                ctx.moveTo(this.xCenter, this.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
            }
            ctx.restore();
        }
    }
 drawBorder() {}
 drawLabels() {
        const ctx = this.ctx;
        const opts = this.options;
        const tickOpts = opts.ticks;
        if (!tickOpts.display) {
            return;
        }
        const startAngle = this.getIndexAngle(0);
        let offset, width;
        ctx.save();
        ctx.translate(this.xCenter, this.yCenter);
        ctx.rotate(startAngle);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        this.ticks.forEach((tick, index)=>{
            if (index === 0 && this.min >= 0 && !opts.reverse) {
                return;
            }
            const optsAtIndex = tickOpts.setContext(this.getContext(index));
            const tickFont = toFont(optsAtIndex.font);
            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
            if (optsAtIndex.showLabelBackdrop) {
                ctx.font = tickFont.string;
                width = ctx.measureText(tick.label).width;
                ctx.fillStyle = optsAtIndex.backdropColor;
                const padding = toPadding(optsAtIndex.backdropPadding);
                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
            }
            renderText(ctx, tick.label, 0, -offset, tickFont, {
                color: optsAtIndex.color,
                strokeColor: optsAtIndex.textStrokeColor,
                strokeWidth: optsAtIndex.textStrokeWidth
            });
        });
        ctx.restore();
    }
 drawTitle() {}
}

const INTERVALS = {
    millisecond: {
        common: true,
        size: 1,
        steps: 1000
    },
    second: {
        common: true,
        size: 1000,
        steps: 60
    },
    minute: {
        common: true,
        size: 60000,
        steps: 60
    },
    hour: {
        common: true,
        size: 3600000,
        steps: 24
    },
    day: {
        common: true,
        size: 86400000,
        steps: 30
    },
    week: {
        common: false,
        size: 604800000,
        steps: 4
    },
    month: {
        common: true,
        size: 2.628e9,
        steps: 12
    },
    quarter: {
        common: false,
        size: 7.884e9,
        steps: 4
    },
    year: {
        common: true,
        size: 3.154e10
    }
};
 const UNITS =  /* #__PURE__ */ Object.keys(INTERVALS);
 function sorter(a, b) {
    return a - b;
}
 function parse(scale, input) {
    if (isNullOrUndef(input)) {
        return null;
    }
    const adapter = scale._adapter;
    const { parser , round , isoWeekday  } = scale._parseOpts;
    let value = input;
    if (typeof parser === 'function') {
        value = parser(value);
    }
    if (!isNumberFinite(value)) {
        value = typeof parser === 'string' ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
        return null;
    }
    if (round) {
        value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);
    }
    return +value;
}
 function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    const ilen = UNITS.length;
    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){
        const interval = INTERVALS[UNITS[i]];
        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
            return UNITS[i];
        }
    }
    return UNITS[ilen - 1];
}
 function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){
        const unit = UNITS[i];
        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
            return unit;
        }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
 function determineMajorUnit(unit) {
    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){
        if (INTERVALS[UNITS[i]].common) {
            return UNITS[i];
        }
    }
}
 function addTick(ticks, time, timestamps) {
    if (!timestamps) {
        ticks[time] = true;
    } else if (timestamps.length) {
        const { lo , hi  } = _lookup(timestamps, time);
        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
        ticks[timestamp] = true;
    }
}
 function setMajorTicks(scale, ticks, map, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index;
    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){
        index = map[major];
        if (index >= 0) {
            ticks[index].major = true;
        }
    }
    return ticks;
}
 function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
     const map = {};
    const ilen = values.length;
    let i, value;
    for(i = 0; i < ilen; ++i){
        value = values[i];
        map[value] = i;
        ticks.push({
            value,
            major: false
        });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
}
class TimeScale extends Scale {
    static id = 'time';
 static defaults = {
 bounds: 'data',
        adapters: {},
        time: {
            parser: false,
            unit: false,
            round: false,
            isoWeekday: false,
            minUnit: 'millisecond',
            displayFormats: {}
        },
        ticks: {
 source: 'auto',
            callback: false,
            major: {
                enabled: false
            }
        }
    };
 constructor(props){
        super(props);
         this._cache = {
            data: [],
            labels: [],
            all: []
        };
         this._unit = 'day';
         this._majorUnit = undefined;
        this._offsets = {};
        this._normalized = false;
        this._parseOpts = undefined;
    }
    init(scaleOpts, opts = {}) {
        const time = scaleOpts.time || (scaleOpts.time = {});
         const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
        adapter.init(opts);
        mergeIf(time.displayFormats, adapter.formats());
        this._parseOpts = {
            parser: time.parser,
            round: time.round,
            isoWeekday: time.isoWeekday
        };
        super.init(scaleOpts);
        this._normalized = opts.normalized;
    }
 parse(raw, index) {
        if (raw === undefined) {
            return null;
        }
        return parse(this, raw);
    }
    beforeLayout() {
        super.beforeLayout();
        this._cache = {
            data: [],
            labels: [],
            all: []
        };
    }
    determineDataLimits() {
        const options = this.options;
        const adapter = this._adapter;
        const unit = options.time.unit || 'day';
        let { min , max , minDefined , maxDefined  } = this.getUserBounds();
 function _applyBounds(bounds) {
            if (!minDefined && !isNaN(bounds.min)) {
                min = Math.min(min, bounds.min);
            }
            if (!maxDefined && !isNaN(bounds.max)) {
                max = Math.max(max, bounds.max);
            }
        }
        if (!minDefined || !maxDefined) {
            _applyBounds(this._getLabelBounds());
            if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
                _applyBounds(this.getMinMax(false));
            }
        }
        min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
        max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
        this.min = Math.min(min, max - 1);
        this.max = Math.max(min + 1, max);
    }
 _getLabelBounds() {
        const arr = this.getLabelTimestamps();
        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;
        if (arr.length) {
            min = arr[0];
            max = arr[arr.length - 1];
        }
        return {
            min,
            max
        };
    }
 buildTicks() {
        const options = this.options;
        const timeOpts = options.time;
        const tickOpts = options.ticks;
        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
        if (options.bounds === 'ticks' && timestamps.length) {
            this.min = this._userMin || timestamps[0];
            this.max = this._userMax || timestamps[timestamps.length - 1];
        }
        const min = this.min;
        const max = this.max;
        const ticks = _filterBetween(timestamps, min, max);
        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);
        this.initOffsets(timestamps);
        if (options.reverse) {
            ticks.reverse();
        }
        return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
        if (this.options.offsetAfterAutoskip) {
            this.initOffsets(this.ticks.map((tick)=>+tick.value));
        }
    }
 initOffsets(timestamps = []) {
        let start = 0;
        let end = 0;
        let first, last;
        if (this.options.offset && timestamps.length) {
            first = this.getDecimalForValue(timestamps[0]);
            if (timestamps.length === 1) {
                start = 1 - first;
            } else {
                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
            }
            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
            if (timestamps.length === 1) {
                end = last;
            } else {
                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
            }
        }
        const limit = timestamps.length < 3 ? 0.5 : 0.25;
        start = _limitValue(start, 0, limit);
        end = _limitValue(end, 0, limit);
        this._offsets = {
            start,
            end,
            factor: 1 / (start + 1 + end)
        };
    }
 _generate() {
        const adapter = this._adapter;
        const min = this.min;
        const max = this.max;
        const options = this.options;
        const timeOpts = options.time;
        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
        const stepSize = valueOrDefault(options.ticks.stepSize, 1);
        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
        const hasWeekday = isNumber(weekday) || weekday === true;
        const ticks = {};
        let first = min;
        let time, count;
        if (hasWeekday) {
            first = +adapter.startOf(first, 'isoWeek', weekday);
        }
        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
        if (adapter.diff(max, min, minor) > 100000 * stepSize) {
            throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
        }
        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){
            addTick(ticks, time, timestamps);
        }
        if (time === max || options.bounds === 'ticks' || count === 1) {
            addTick(ticks, time, timestamps);
        }
        return Object.keys(ticks).sort(sorter).map((x)=>+x);
    }
 getLabelForValue(value) {
        const adapter = this._adapter;
        const timeOpts = this.options.time;
        if (timeOpts.tooltipFormat) {
            return adapter.format(value, timeOpts.tooltipFormat);
        }
        return adapter.format(value, timeOpts.displayFormats.datetime);
    }
 format(value, format) {
        const options = this.options;
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const fmt = format || formats[unit];
        return this._adapter.format(value, fmt);
    }
 _tickFormatFunction(time, index, ticks, format) {
        const options = this.options;
        const formatter = options.ticks.callback;
        if (formatter) {
            return callback(formatter, [
                time,
                index,
                ticks
            ], this);
        }
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const majorUnit = this._majorUnit;
        const minorFormat = unit && formats[unit];
        const majorFormat = majorUnit && formats[majorUnit];
        const tick = ticks[index];
        const major = majorUnit && majorFormat && tick && tick.major;
        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    }
 generateTickLabels(ticks) {
        let i, ilen, tick;
        for(i = 0, ilen = ticks.length; i < ilen; ++i){
            tick = ticks[i];
            tick.label = this._tickFormatFunction(tick.value, i, ticks);
        }
    }
 getDecimalForValue(value) {
        return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
 getPixelForValue(value) {
        const offsets = this._offsets;
        const pos = this.getDecimalForValue(value);
        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
 getValueForPixel(pixel) {
        const offsets = this._offsets;
        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return this.min + pos * (this.max - this.min);
    }
 _getLabelSize(label) {
        const ticksOpts = this.options.ticks;
        const tickLabelWidth = this.ctx.measureText(label).width;
        const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
        const cosRotation = Math.cos(angle);
        const sinRotation = Math.sin(angle);
        const tickFontSize = this._resolveTickFontOptions(0).size;
        return {
            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
        };
    }
 _getLabelCapacity(exampleTime) {
        const timeOpts = this.options.time;
        const displayFormats = timeOpts.displayFormats;
        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
            exampleTime
        ], this._majorUnit), format);
        const size = this._getLabelSize(exampleLabel);
        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
        return capacity > 0 ? capacity : 1;
    }
 getDataTimestamps() {
        let timestamps = this._cache.data || [];
        let i, ilen;
        if (timestamps.length) {
            return timestamps;
        }
        const metas = this.getMatchingVisibleMetas();
        if (this._normalized && metas.length) {
            return this._cache.data = metas[0].controller.getAllParsedValues(this);
        }
        for(i = 0, ilen = metas.length; i < ilen; ++i){
            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
        }
        return this._cache.data = this.normalize(timestamps);
    }
 getLabelTimestamps() {
        const timestamps = this._cache.labels || [];
        let i, ilen;
        if (timestamps.length) {
            return timestamps;
        }
        const labels = this.getLabels();
        for(i = 0, ilen = labels.length; i < ilen; ++i){
            timestamps.push(parse(this, labels[i]));
        }
        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
 normalize(values) {
        return _arrayUnique(values.sort(sorter));
    }
}

function interpolate(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
        if (val >= table[lo].pos && val <= table[hi].pos) {
            ({ lo , hi  } = _lookupByKey(table, 'pos', val));
        }
        ({ pos: prevSource , time: prevTarget  } = table[lo]);
        ({ pos: nextSource , time: nextTarget  } = table[hi]);
    } else {
        if (val >= table[lo].time && val <= table[hi].time) {
            ({ lo , hi  } = _lookupByKey(table, 'time', val));
        }
        ({ time: prevSource , pos: prevTarget  } = table[lo]);
        ({ time: nextSource , pos: nextTarget  } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
    static id = 'timeseries';
 static defaults = TimeScale.defaults;
 constructor(props){
        super(props);
         this._table = [];
         this._minPos = undefined;
         this._tableRange = undefined;
    }
 initOffsets() {
        const timestamps = this._getTimestampsForTable();
        const table = this._table = this.buildLookupTable(timestamps);
        this._minPos = interpolate(table, this.min);
        this._tableRange = interpolate(table, this.max) - this._minPos;
        super.initOffsets(timestamps);
    }
 buildLookupTable(timestamps) {
        const { min , max  } = this;
        const items = [];
        const table = [];
        let i, ilen, prev, curr, next;
        for(i = 0, ilen = timestamps.length; i < ilen; ++i){
            curr = timestamps[i];
            if (curr >= min && curr <= max) {
                items.push(curr);
            }
        }
        if (items.length < 2) {
            return [
                {
                    time: min,
                    pos: 0
                },
                {
                    time: max,
                    pos: 1
                }
            ];
        }
        for(i = 0, ilen = items.length; i < ilen; ++i){
            next = items[i + 1];
            prev = items[i - 1];
            curr = items[i];
            if (Math.round((next + prev) / 2) !== curr) {
                table.push({
                    time: curr,
                    pos: i / (ilen - 1)
                });
            }
        }
        return table;
    }
 _generate() {
        const min = this.min;
        const max = this.max;
        let timestamps = super.getDataTimestamps();
        if (!timestamps.includes(min) || !timestamps.length) {
            timestamps.splice(0, 0, min);
        }
        if (!timestamps.includes(max) || timestamps.length === 1) {
            timestamps.push(max);
        }
        return timestamps.sort((a, b)=>a - b);
    }
 _getTimestampsForTable() {
        let timestamps = this._cache.all || [];
        if (timestamps.length) {
            return timestamps;
        }
        const data = this.getDataTimestamps();
        const label = this.getLabelTimestamps();
        if (data.length && label.length) {
            timestamps = this.normalize(data.concat(label));
        } else {
            timestamps = data.length ? data : label;
        }
        timestamps = this._cache.all = timestamps;
        return timestamps;
    }
 getDecimalForValue(value) {
        return (interpolate(this._table, value) - this._minPos) / this._tableRange;
    }
 getValueForPixel(pixel) {
        const offsets = this._offsets;
        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
    }
}

var scales = /*#__PURE__*/Object.freeze({
__proto__: null,
CategoryScale: CategoryScale,
LinearScale: LinearScale,
LogarithmicScale: LogarithmicScale,
RadialLinearScale: RadialLinearScale,
TimeScale: TimeScale,
TimeSeriesScale: TimeSeriesScale
});

const registerables = [
    controllers,
    elements,
    plugins,
    scales
];

Chart.register(...registerables);

const _style_0$4 = ".modal-btn[data-v-bd52da02]{width:100px;height:41px;background-color:#f7a650;border-radius:131px;position:relative;left:35%}.btn[data-v-bd52da02]{color:#fcefcb;text-align:center;line-height:40px}.modal-title[data-v-bd52da02]{position:relative;margin-bottom:15px;padding-bottom:10px}.modal-title[data-v-bd52da02]:after{content:\"\";position:absolute;bottom:0;left:0;width:100%;height:1px;background-color:#e0e0e0}.modal-item-one[data-v-bd52da02]{position:relative;margin-bottom:15px;padding-bottom:10px}.modal-item-one[data-v-bd52da02]:after{content:\"\";position:absolute;bottom:0;left:0;width:100%;height:1px;background-color:#e0e0e0}.modal-item-two[data-v-bd52da02]{position:relative;margin-bottom:15px;padding-bottom:10px}.modal-item-two[data-v-bd52da02]:after{content:\"\";position:absolute;bottom:0;left:0;width:100%;height:1px;background-color:#e0e0e0}.modal-item-three[data-v-bd52da02]{position:relative;margin-bottom:15px;padding-bottom:10px}.modal-item-three[data-v-bd52da02]:after{content:\"\";position:absolute;bottom:0;left:0;width:100%;height:1px;background-color:#e0e0e0}.modal-title-text[data-v-bd52da02]{color:#f07d1b}.modal-title-num[data-v-bd52da02]{color:#000;font-weight:700;margin-top:10px}.modal-text[data-v-bd52da02]{color:#1f1f1f}.modal-num[data-v-bd52da02]{color:#b4b4b4;margin-top:10px}.modal-reduce[data-v-bd52da02]{color:#1f1f1f}.modal-carbon[data-v-bd52da02]{color:#b4b4b4;margin-top:10px}.modal-save[data-v-bd52da02]{color:#1f1f1f}.modal-coal[data-v-bd52da02]{color:#b4b4b4;margin-top:10px}.modal-overlay[data-v-bd52da02]{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:1000}.modal-content[data-v-bd52da02]{background-color:#fff;border-radius:8px;box-shadow:0 10px 25px #0000001a;padding:20px;max-width:500px;width:90%;position:relative;margin-left:20px;margin-right:20px}.close-btn[data-v-bd52da02]{position:absolute;top:10px;right:10px;background:none;border:none;font-size:20px;cursor:pointer}.energy-charts[data-v-bd52da02]{background-color:#fff;border-radius:8px;box-shadow:0 2px 4px #0000001a;padding:20px}.chart-tabs[data-v-bd52da02]{display:flex;margin-bottom:20px}.chart-tabs button[data-v-bd52da02]{background-color:#f1f5f9;border:none;padding:15px;cursor:pointer;transition:background-color .3s ease;margin-right:5px;border-radius:4px 4px 0 0}.chart-tabs button.active-tab[data-v-bd52da02]{background-color:#3b82f6;color:#fff}.chart-tabs button[data-v-bd52da02]:hover:not(.active-tab){background-color:#e2e8f0}.chart-container[data-v-bd52da02]{width:100%;height:350px}.environmental-title[data-v-bd52da02]{display:flex;align-items:center;justify-content:space-between}.environmental-title-text[data-v-bd52da02]{font-size:16px;font-weight:bolder;margin:20px 0}.environmental-content-box[data-v-bd52da02]{display:flex;align-items:center;justify-content:space-between}.environmental-content[data-v-bd52da02]{width:105px;height:105px;background-color:#ecfcf2;border-radius:8px}.environmental-item[data-v-bd52da02]{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;margin-top:15px;gap:5px}img[data-v-bd52da02]{width:25px;height:25px}.environmental-content-cloud[data-v-bd52da02]{width:105px;height:105px;background-color:#fdf2e9;border-radius:8px}.environmental-item-cloud[data-v-bd52da02]{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;margin-top:15px;gap:5px}.environmental-content-coal[data-v-bd52da02]{width:105px;height:105px;background-color:#e2eefd;border-radius:8px}.environmental-item-coal[data-v-bd52da02]{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;margin-top:15px;gap:5px}";

const _hoisted_1$4 = { class: "energy-charts" };
const _hoisted_2$3 = { class: "chart-tabs" };
const _hoisted_3$2 = ["onClick"];
const _hoisted_4$2 = { class: "chart-container" };
const _hoisted_5$1 = { class: "environment-box" };
const _hoisted_6$1 = { class: "environmental-content-box" };
const _hoisted_7$1 = { class: "environmental-content" };
const _hoisted_8$1 = { class: "environmental-item" };
const _hoisted_9$1 = { class: "environmental-num" };
const _hoisted_10$1 = { class: "environmental-content-cloud" };
const _hoisted_11$1 = { class: "environmental-item-cloud" };
const _hoisted_12$1 = { class: "environmental-content-coal" };
const _hoisted_13$1 = { class: "environmental-item-coal" };
const _hoisted_14$1 = {
  key: 0,
  class: "modal-overlay"
};

// 定义 props 接收父组件传递的数据

const _sfc_main$5 = {
  __name: 'EnergyCharts',
  props: {
  hassStates: {
    type: Object,
    required: true,
  },
  // 接收 hass 对象
  hass: {
    type: Object,
    required: true,
  }
},
  setup(__props) {

const props = __props;

const energyChartRef = ref(null);
let energyChart = null;
const showModal = ref(false);
const chartTabs = ref(["Day", "Month", "Year", "total"]);
const activeTab = ref(0);
const co2 = ref("");
const coal = ref("");
const deforestation = ref("");

// 日统计数据
const dailyData = {
  labels: [],
  datasets: [
    {
      label: "Battery",
      data: [],
      borderColor: "rgba(75, 192, 192, 1)",
      backgroundColor: "rgba(75, 192, 192, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    },
    {
      label: "powerGrid",
      data: [],
      borderColor: "rgba(255, 99, 132, 1)",
      backgroundColor: "rgba(255, 99, 132, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    },
    {
      label: "Load",
      data: [],
      borderColor: "rgba(54, 162, 235, 1)",
      backgroundColor: "rgba(54, 162, 235, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    },
    {
      label: "Photovoltaic",
      data: [],
      borderColor: "rgba(255, 206, 86, 1)",
      backgroundColor: "rgba(255, 206, 86, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    }
  ],
};

// 月统计数据
const monthlyData = {
  labels: [],
  datasets: [
    {
      label: "Battery",
      data: [],
      borderColor: "rgba(75, 192, 192, 1)",
      backgroundColor: "rgba(75, 192, 192, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    },
    {
      label: "powerGrid",
      data: [],
      borderColor: "rgba(255, 99, 132, 1)",
      backgroundColor: "rgba(255, 99, 132, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    },
    {
      label: "Load",
      data: [],
      borderColor: "rgba(54, 162, 235, 1)",
      backgroundColor: "rgba(54, 162, 235, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    },
    {
      label: "Photovoltaic",
      data: [],
      borderColor: "rgba(255, 206, 86, 1)",
      backgroundColor: "rgba(255, 206, 86, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    }
  ],
};

// 年统计数据
const yearlyData = {
  labels: [],
  datasets: [
    {
      label: "Battery",
      data: [],
      borderColor: "rgba(75, 192, 192, 1)",
      backgroundColor: "rgba(75, 192, 192, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    },
    {
      label: "powerGrid",
      data: [],
      borderColor: "rgba(255, 99, 132, 1)",
      backgroundColor: "rgba(255, 99, 132, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    },
    {
      label: "Load",
      data: [],
      borderColor: "rgba(54, 162, 235, 1)",
      backgroundColor: "rgba(54, 162, 235, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    },
    {
      label: "Photovoltaic",
      data: [],
      borderColor: "rgba(255, 206, 86, 1)",
      backgroundColor: "rgba(255, 206, 86, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    }
  ],
};
// 总统计数据
const totalData = {
  labels: [],
  datasets: [
    {
      label: "Battery",
      data: [],
      borderColor: "rgba(75, 192, 192, 1)",
      backgroundColor: "rgba(75, 192, 192, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    },
    {
      label: "powerGrid",
      data: [],
      borderColor: "rgba(255, 99, 132, 1)",
      backgroundColor: "rgba(255, 99, 132, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    },
    {
      label: "Load",
      data: [],
      borderColor: "rgba(54, 162, 235, 1)",
      backgroundColor: "rgba(54, 162, 235, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    },
    {
      label: "Photovoltaic",
      data: [],
      borderColor: "rgba(255, 206, 86, 1)",
      backgroundColor: "rgba(255, 206, 86, 0.2)",
      borderWidth: 2,
      tension: 0.4,
      fill: true,
    }
  ],
};

// 处理标签点击事件
const handleTabClick = (tab, index) => {
  activeTab.value = index;
  if (tab === "Day") {
    handleDayClick();
  } else if (tab === "Month") {
    handleMonthClick();
  } else if (tab === "Year") {
    handleYearClick();
  } else if (tab === "total") {
    handleTotalClick();
  }
  createChart();
};

// 点击 Day 标签调用的方法 service_get_energy_data_day    
const handleDayClick = () => {
  console.log("点击了 Day 标签");
  if (props.hass && typeof props.hass.callService === 'function') {
    console.log('callService 方法存在，开始调用服务');
    props.hass.callService('ha_ems', 'service_get_energy_data_day')
      .then((response) => {
        if (props.hassStates && props.hassStates["sensor.plant_name"]) {
          const plantNameSensor = props.hassStates["sensor.plant_name"];
          if (plantNameSensor.attributes && plantNameSensor.attributes.energy_data_day) {
            const energyDataDay = plantNameSensor.attributes.energy_data_day;
            co2.value = energyDataDay.co2 || '';
            coal.value = energyDataDay.coal || '';
            deforestation.value = energyDataDay.deforestation || '';
            // console.log("当日能源数据:", energyDataDay);
            // 更新 dailyData 的 labels
            if (energyDataDay.batMap) {
              dailyData.labels = Object.keys(energyDataDay.batMap);
            }

            // 数据映射对象，用于更新数据集索引
            const dataMap = {
              batMap: 0,
              gridMap: 1,
              loadMap: 2,
              revenueMap: 3
            };

            // 遍历映射对象更新 dailyData 的 datasets 的 data
            for (const [key, index] of Object.entries(dataMap)) {
              if (energyDataDay[key]) {
                const values = Object.values(energyDataDay[key]);
                dailyData.datasets[index].data = values;
              }
            }
          } else {
            console.warn("未找到service_get_energy_data_day 属性");
            co2.value = '00';
            coal.value = '00';
            deforestation.value = '00';
          }
        } else {
          console.warn("未找到 service_get_energy_data_day 数据");
          co2.value = '00';
          coal.value = '00';
          deforestation.value = '00';
        }
        // 重新创建图表以显示更新后的数据
        createChart();
      })
      .catch((error) => {
        console.error('调用 energy_data_day 服务失败:', error);
        co2.value = '00';
        coal.value = '00';
        deforestation.value = '00';
      });
  } else {
    console.error('hass 对象或 callService 方法不存在');
    co2.value = '00';
    coal.value = '00';
    deforestation.value = '00';
  }
};

// 点击 Month 标签调用的方法 service_get_energy_data_month  
const handleMonthClick = () => {
  // console.log("点击了 Month 标签");
  // console.log('当前 Month 对象:', props.hass);
  if (props.hass && typeof props.hass.callService === 'function') {
    console.log('callService 方法存在，开始调用服务');
    props.hass.callService('ha_ems', 'service_get_energy_data_month')
      .then((response) => {
        if (props.hassStates && props.hassStates["sensor.plant_name"]) {
          const plantNameSensor = props.hassStates["sensor.plant_name"];
          if (plantNameSensor.attributes && plantNameSensor.attributes.energy_data_month) {
            const energyDataDay = plantNameSensor.attributes.energy_data_month;
            co2.value = energyDataDay.co2 || '';
            coal.value = energyDataDay.coal || '';
            deforestation.value = energyDataDay.deforestation || '';
            console.log("当月能源数据:", energyDataDay);
            // 更新 monthlyData 的 labels
            if (energyDataDay.batMap) {
              monthlyData.labels = Object.keys(energyDataDay.batMap);
            }

            // 数据映射对象，用于更新数据集索引
            const dataMap = {
              batMap: 0,
              gridMap: 1,
              loadMap: 2,
              revenueMap: 3
            };

            // 遍历映射对象更新 monthlyData 的 datasets 的 data
            for (const [key, index] of Object.entries(dataMap)) {
              if (energyDataDay[key]) {
                const values = Object.values(energyDataDay[key]);
                monthlyData.datasets[index].data = values;
              }
            }
          } else {
            console.warn("未找到energy_data_mont 属性");
            co2.value = '00';
            coal.value = '00';
            deforestation.value = '00';
          }
        } else {
          console.warn("未找到 energy_data_mont 数据");
          co2.value = '00';
          coal.value = '00';
          deforestation.value = '00';
        }
        // 重新创建图表以显示更新后的数据
        createChart();
      })
      .catch((error) => {
        console.error('调用 energy_data_mont 服务失败:', error);
        co2.value = '00';
        coal.value = '00';
        deforestation.value = '00';
      });
  } else {
    console.error('hass 对象或 callService 方法不存在');
    co2.value = '00';
    coal.value = '00';
    deforestation.value = '00';
  }
};

// 点击 Year 标签调用的方法 service_get_energy_data_year
const handleYearClick = () => {
  console.log("点击了 Year 标签");
  if (props.hass && typeof props.hass.callService === 'function') {
    console.log('callService 方法存在，开始调用服务');
    props.hass.callService('ha_ems', 'service_get_energy_data_year')
      .then((response) => {
        if (props.hassStates && props.hassStates["sensor.plant_name"]) {
          const plantNameSensor = props.hassStates["sensor.plant_name"];
          if (plantNameSensor.attributes && plantNameSensor.attributes.energy_data_year) {
            const energyDataDay = plantNameSensor.attributes.energy_data_year;
            co2.value = energyDataDay.co2 || '';
            coal.value = energyDataDay.coal || '';
            deforestation.value = energyDataDay.deforestation || '';
            console.log("年能源数据:", energyDataDay);
            // 更新 yearlyData 的 labels
            if (energyDataDay.batMap) {
              yearlyData.labels = Object.keys(energyDataDay.batMap);
            }

            // 数据映射对象，用于更新数据集索引
            const dataMap = {
              batMap: 0,
              gridMap: 1,
              loadMap: 2,
              revenueMap: 3
            };

            // 遍历映射对象更新 yearlyData 的 datasets 的 data
            for (const [key, index] of Object.entries(dataMap)) {
              if (energyDataDay[key]) {
                const values = Object.values(energyDataDay[key]);
                yearlyData.datasets[index].data = values;
              }
            }
          } else {
            console.warn("未找到energy_data_mont 属性");
            co2.value = '00';
            coal.value = '00';
            deforestation.value = '00';
          }
        } else {
          console.warn("未找到 energy_data_mont 数据");
          co2.value = '00';
          coal.value = '00';
          deforestation.value = '00';
        }
        // 重新创建图表以显示更新后的数据
        createChart();
      })
      .catch((error) => {
        console.error('调用 energy_data_mont 服务失败:', error);
        co2.value = '00';
        coal.value = '00';
        deforestation.value = '00';
      });
  } else {
    console.error('hass 对象或 callService 方法不存在');
    co2.value = '00';
    coal.value = '00';
    deforestation.value = '00';
  }
};

// 点击 total 标签调用的方法 service_get_energy_data_total
const handleTotalClick = () => {
  console.log("点击了 total 标签");
  if (props.hass && typeof props.hass.callService === 'function') {
    console.log('callService 方法存在，开始调用服务');
    props.hass.callService('ha_ems', 'service_get_energy_data_total')
      .then((response) => {
        if (props.hassStates && props.hassStates["sensor.plant_name"]) {
          const plantNameSensor = props.hassStates["sensor.plant_name"];
          if (plantNameSensor.attributes && plantNameSensor.attributes.energy_data_total) {
            const energyDataDay = plantNameSensor.attributes.energy_data_total;
            co2.value = energyDataDay.co2 || '';
            coal.value = energyDataDay.coal || '';
            deforestation.value = energyDataDay.deforestation || '';
            console.log("总数能源数据:", energyDataDay);
            // 更新 totalData 的 labels
            if (energyDataDay.batMap) {
              totalData.labels = Object.keys(energyDataDay.batMap);
            }

            // 数据映射对象，用于更新数据集索引
            const dataMap = {
              batMap: 0,
              gridMap: 1,
              loadMap: 2,
              revenueMap: 3
            };

            // 遍历映射对象更新 totalData 的 datasets 的 data
            for (const [key, index] of Object.entries(dataMap)) {
              if (energyDataDay[key]) {
                const values = Object.values(energyDataDay[key]);
                totalData.datasets[index].data = values;
              }
            }
          } else {
            console.warn("未找到energy_data_mont 属性");
            co2.value = '00';
            coal.value = '00';
            deforestation.value = '00';
          }
        } else {
          console.warn("未找到 energy_data_mont 数据");
          co2.value = '00';
          coal.value = '00';
          deforestation.value = '00';
        }
        // 重新创建图表以显示更新后的数据
        createChart();
      })
      .catch((error) => {
        console.error('调用 energy_data_mont 服务失败:', error);
        co2.value = '00';
        coal.value = '00';
        deforestation.value = '00';
      });
  } else {
    console.error('hass 对象或 callService 方法不存在');
    co2.value = '00';
    coal.value = '00';
    deforestation.value = '00';
  }
};

// 打开模态框
const openModal = () => {
  showModal.value = true;
  document.body.style.overflow = "hidden";
};

// 关闭模态框
const closeModal = () => {
  showModal.value = false;
  document.body.style.overflow = "auto";
};

const getChartData = () => {
  if (activeTab.value === 0) return dailyData;
  if (activeTab.value === 1) return monthlyData;
  if (activeTab.value === 2) return yearlyData;
  return totalData;
};

const createChart = () => {
  if (energyChart) {
    energyChart.destroy();
  }

  const ctx = energyChartRef.value.getContext("2d");
  const chartData = getChartData();

  // 图表配置
  const config = {
    type: "line",
    data: chartData,
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: "top",
          boxWidth: 3,
          usePointStyle: true,
          labels: {
            font: {
              size: 10
            },
            padding: 10, // 调整文本与图例的间距
            pointStyle: 'circle', // 明确使用圆形
            // 控制圆点大小
            usePointStyle: true,
            pointStyleRadius: 4 // 调整圆点半径
          }
        },
        tooltip: {
          mode: "index",
          intersect: false,
        },
      },
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            // text: activeTab.value === 2 ? "Power(MWh)" : "Power(kWh)",
          },
        },
      },
    },
  };

  // 创建图表
  energyChart = new Chart(ctx, config);
};

onMounted(() => {
  createChart();
  handleDayClick();
  console.log("EnergyCharts 组件接收到的 hass.states:", props.hassStates);
});

onUnmounted(() => {
  if (energyChart) {
    energyChart.destroy();
  }
});

// const setActiveTab = (index) => {
//   activeTab.value = index;
// };

watch(activeTab, () => {
  createChart();
});

return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", _hoisted_1$4, [
    _cache[11] || (_cache[11] = createBaseVNode("h3", { class: "section-title" }, "Power consumption statistics", -1)),
    createBaseVNode("div", _hoisted_2$3, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(chartTabs.value, (tab, index) => {
        return (openBlock(), createElementBlock("button", {
          key: index,
          class: normalizeClass({ 'active-tab': activeTab.value === index }),
          onClick: $event => (handleTabClick(tab, index))
        }, toDisplayString(tab), 11, _hoisted_3$2))
      }), 128))
    ]),
    createBaseVNode("div", _hoisted_4$2, [
      createBaseVNode("canvas", {
        ref_key: "energyChartRef",
        ref: energyChartRef,
        width: "650",
        height: "200",
        style: {"margin-left":"-30px"}
      }, null, 512)
    ]),
    createBaseVNode("div", _hoisted_5$1, [
      createBaseVNode("div", { class: "environmental-title" }, [
        _cache[2] || (_cache[2] = createBaseVNode("div", { class: "environmental-title-text" }, "Environmental benefits", -1)),
        createBaseVNode("img", {
          src: _imports_0$2,
          alt: "",
          onClick: openModal
        })
      ]),
      createBaseVNode("div", _hoisted_6$1, [
        createBaseVNode("div", _hoisted_7$1, [
          createBaseVNode("div", _hoisted_8$1, [
            _cache[3] || (_cache[3] = createBaseVNode("img", {
              src: _imports_1$1,
              alt: ""
            }, null, -1)),
            createBaseVNode("div", _hoisted_9$1, toDisplayString(co2.value) + " t", 1),
            _cache[4] || (_cache[4] = createBaseVNode("div", { class: "environmental-text" }, "Protect forests", -1))
          ])
        ]),
        createBaseVNode("div", _hoisted_10$1, [
          createBaseVNode("div", _hoisted_11$1, [
            _cache[5] || (_cache[5] = createBaseVNode("img", {
              src: _imports_2$1,
              alt: ""
            }, null, -1)),
            createBaseVNode("div", null, toDisplayString(coal.value) + " kg", 1),
            _cache[6] || (_cache[6] = createBaseVNode("div", null, "Carbon dioxide", -1))
          ])
        ]),
        createBaseVNode("div", _hoisted_12$1, [
          createBaseVNode("div", _hoisted_13$1, [
            _cache[7] || (_cache[7] = createBaseVNode("img", {
              src: _imports_3$1,
              alt: ""
            }, null, -1)),
            createBaseVNode("div", null, toDisplayString(deforestation.value) + " kg", 1),
            _cache[8] || (_cache[8] = createBaseVNode("div", null, "coal", -1))
          ])
        ])
      ])
    ]),
    (showModal.value)
      ? (openBlock(), createElementBlock("div", _hoisted_14$1, [
          createBaseVNode("div", {
            class: "modal-content",
            onClick: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"]))
          }, [
            _cache[10] || (_cache[10] = createStaticVNode("<div class=\"modal-title\" data-v-bd52da02><div class=\"modal-title-text\" data-v-bd52da02> Standards for calculating social contributions </div><div class=\"modal-title-num\" data-v-bd52da02>1kwh is equal to:</div></div><div class=\"modal-item-one\" data-v-bd52da02><div class=\"modal-text\" data-v-bd52da02>Protect trees:</div><div class=\"modal-num\" data-v-bd52da02>0.055 tree</div></div><div class=\"modal-item-two\" data-v-bd52da02><div class=\"modal-reduce\" data-v-bd52da02>Reduce carbon dioxide emissions:</div><div class=\"modal-carbon\" data-v-bd52da02>0.997 kg</div></div><div class=\"modal-item-three\" data-v-bd52da02><div class=\"modal-save\" data-v-bd52da02>Save standard coal</div><div class=\"modal-coal\" data-v-bd52da02>0.4 kg</div></div>", 4)),
            createBaseVNode("div", {
              class: "modal-btn",
              onClick: _cache[0] || (_cache[0] = $event => (closeModal()))
            }, _cache[9] || (_cache[9] = [
              createBaseVNode("div", { class: "btn" }, "Close", -1)
            ]))
          ])
        ]))
      : createCommentVNode("", true)
  ]))
}
}

};
const EnergyCharts = /*#__PURE__*/_export_sfc(_sfc_main$5, [['styles',[_style_0$4]],['__scopeId',"data-v-bd52da02"]]);

const _imports_0$1 = "data:image/png;base64,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";

const _imports_1 = "data:image/png;base64,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";

const _imports_2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAACGCAYAAAAcjCKsAAAAAXNSR0IArs4c6QAAIABJREFUeF7tfQl4G9XV9jl3JDlOTAhkgbKFLU1sSXYS2xJQ+FjbQClLy/rBz9JCy1oohbIvYWuAQtl3CDuFuElpy1qW0EJDJNuJI2nkpAkkQAiQkIXYibXNPZ/OaORoGdmSLFkO/e/z5MmTaObOuXfO3HvuOe95D8J3vREp9T7fMM1iqaqR0gpSWtFms0RjMQWltBAiWhExAgBCSilsNtJiMc1qsWgUicRAiGi3EFElFgv76utDgKh9l6cMv2uDs6vq9jVC7CFjsfEgxC5ItBMC7ABE4whgO0QcBQDbAEA1EQ0HAAsismIQAkSISCJADwFsBoCNQNSFQqwjKb8BxC+JaBUSfaZZLJ8pXV2fet3utd+lOdz6FWLWLKVx0qQ6ixCHItGhBLA3v3ACGAGI/MKtCFCScRIAAUAUATZB4k8XES0hgPc1gLkLOjtVOPHErXoFKclEDeYXsvvy5cNGr127nbDZvo9CHA1ExyDinlCilz6AsRAhrkCAv2lSvkLh8JK1o0evX7HHHqEB9Dnot241CtHs9e4qhg//AQAcQAD8dy0C2PKaMSKNhFgHUq5DxG8BkbeCKPDWQBRDISIgJZAQAomqeFUBgBrjz0hCHANE2yOAyOd5BBBBgMVENA+E+CBks/3LN2HCynzurfQ1Q10h0K2qtSTluYA4DQB25O2gvy2AiNYAYjshLkSAABEt1Yi6LVZrKBwKRQgxOsxm0yKhkFZVUyO7IhHJL0JTFKyxWkUoFFLYAA3ZbJaqUMgmhBgWE2IbwdsRUQMQTUaAyYA4rq8XyFsMIvK28hUivikBHmutqwsCIm89Q7INSYWoU9WaEQB7C4BLQcrjALHadPYQNZKyGxG7gWgpAbwupXyjbcmSzrLv5YbtogD8kIQ4DAEcgDgSpawBRCXH2w4R0WyKxe7cuGnTx0v2379rqGnFkFKIiYsXbzNK06aBlMcD4pHGkm02Z+sIoBWIeBWYLxEXtbe0rITp0/UvfdAbEbp9vp01xEaB2IwALkBsBIDtc8jSRYhvIEDLBkV5a8mkSUNGMYaGQsyapTTV1h6iIF4FAJMJYFTmtqAvvwDLQMqZgPh6JBr9cuGUKWsBsTJKkEvriMSUZctG20Kh7yHiERLgFwAwIcd4NhCRDxBneIPBd8q+quXxpVRUIQ6aO9fSNW7cTgrA9UB0WqaRSAASELuQaBkQ3RsLh2e3NzWxf2CraXwqGtfVdRQgXgJC1AER20BpxikboYD4nAZwE/T0fNne1MQGb0VaxRTC7ffvQIhnIMB5ALB75ugJ4CskeiMGMHttTc27W9vxLXM8u8+dO2yHHXY4BKQ8lgAOR4BdTcb8GRI9AgAzPU7n15XQiIooRHMw+D9CyjuAqD7LYCTqAcTnieixkJSdvoYGdgB9Z9q+n39eHd24cZIA+CUQ8QfBzrMtLTF+v0Z0bZvT+fZgD3xQFYKNxpFS/kJIebPhPtbHa3gAe4CoDRAv8jociwZ7IirxPFcg0IAA9xARG6HVqXYGEW0mxBnRaPSBjilTNgyWfIOjEETYrKpNCsBvCPFnQDQs9ZsAgHkS8YkvenpmrdrKbISBvqhd5s2r3mnkyBORVwyA/VI9rpRwk/+dpLzTO2eOZzBOUeVXCCLFpaonxiduOgJMSBsw4rdEdCcQPdPqcKwcyg6bgb74Pu/nDyYQ2EVBPEMSXWoE4HpvIaKPieiW1rVrn4eDD46VU5ayKsTeS5dWbR+J/BKJbofUvZJDyETLCeBCr93+j/9aRTB5s80+34FCiEcAcQIQ9Tq4CCAcd7Nfu6am5oFyGthlU4hGVd1NSHmFADgnw3O3nhBfhljsDm9Dw/JyavvW2nez378rAlyFiLyyjk4ZhySip+KYjlvLNXdlUYjGYPB7FikfIYAjMBEoShqPjB24UguFXtza/AmDrVyNbW3DlWHDToifQu4AgNSYSZQA3tUQz2m32z8rtVwlV4j6RYvGVVssbwDR1BRFYG/iSol4Qpvd7i31IL7L/U1dvLjeEov9hX01qQ4tSeTvDoendTY1fVnK8ZdOIYiw0eeboijKQwjg7lUGoigivgFCXOapq1taSuH/W/pq9vn2FELcbTi0ekP+BNAmES9oq6trLZUdVjKFaGxr20upqnoOhXBlGEPPKFbrNR9NnPjFf8sLLMc49+3o2Fkqys2A+POMlbddatppbQ0NS0rx3JIoRGNb2xilqmouIjpSzkoxQHzM43BcUApBi+5j+nSxt8tlHTtqlIBds7zFeXf7ZSxGK1asiJX72NefQK5A4H4kYnyIJWUVXhKNRg9YOHXqmv7u7+/3ASuEsZw9DgCHpChDDwA82CXEjUG7vbs/Icry+9y5FteYMZOB6FB91QL4HgH0TmIhz0R2phJtBACViN5ft3nze8v22Yf/PeiNsSI1iWDgBWlub6J/g6L8fKDb8oAUYvLChaNsVuuDCHCCATszjhN012aiW/319esHfcb4gQlHDzt4zkWi3fsArBQknhGC30AA/4oKcfHCurpPC+qgRBfzvFdZLNfGI8GXpq7IhPiXTRs3nqvut9+6Yh9VvEJMny5cJ5xwExJd0/twRjABPOG1288tVqAB30ckXKo6AwEuH3BffXRAiGoU8chKKQWL5lLVh3WXd7oD6wGv3X5xsTiRohSisa3Nahk27FcAcA/nNRjzxufjlh4pL6zkyuDy+xlt9Vim+7fkykHE3taZPUSXVCoi2/jxx9sqPT33AtEpnG+kL46MIQG4rBvxwaDdzvlHBbWiFKI5EDgKiR5HxB16DRuAVpLy5Nb6+k8KkqCEFzt9vu2GC/E0ARzVHxC3RI9dJwEOb3U4WkvUX8HdNLa17aZUVz+LRAem3Lw6Duw91+t0vpLQkfxbwQoxZcGCnaxW6+w4ingfQyP5gWtR06Z4GhoqCjV3B4MTQNM8gLhd5hQYIXaG4RUGuSNCQhQ5FYzoTo/T+bv8p7z0V+rOQEVZSADfS8pJAB1EdHSr0/l5IU8sSCHqVNVWI+V9iMjbRfLeLzSin1cCzJE50Ga//2cCcXbWBLBtQxRAgL8CUUGGoASoQYCDEOBwM/Q3g3y9dvu+hUx6Oa7loBgK8VwGEuvpr0eMOK+QYFhBCtHs958X35vvScE+cqLLLd1C3FnMflXqiWn2+y8TiH8w6fdTLRY7se2VV9qKwRTo+aJS3pnqFErZKr/yOhzfK/VYCu2P7Tpl2LALAeBm5DTGxF4RJcSrW+32O/PtL2+FaFbVyULKVwFxZ6NzIqIPQlL+uFJGVeYg3X7/c4D4/0y2iz96HY4tR7R8ZyflOveiRbuQonxmtnWEYrFdFk2eXHFPrL6CE/0tDjj6UcrW8aVEPDbfGFJeCtG4atVwy7p19wDiL5JHHAL4GIU4YqCOkCLejfkt06cL9/HHf2wK2EU81Wu3vzjQZ7kCgVUIkLUaEMAZXofj2YH2X4r7pyxYMN5qs71tgJH0UwcSvbjBaj0/n/yPvBSiORg8TEg5CwB0Y404TV6IM7x1dWzFDonGHlMUYqlJ/iWFo9E9O6ZMWTFQQd2BwJ8B4DiTFehZr8NxxkD7L9X9+6jq0ZKI7YmRRp+cGHSW125v6e8Z/SsEO6COOy6AiLXJrQIRZ0Z7ei4aSpiGpkDgdAXgGRODcrnHbufs8AE3dyDAcZkHTDrqjIVCTUNlPhjZTRs23E+8om8x/ld2Ie7Vn63Xt0IQieZg8FpBdGPKJHyqIZ6Y75404LeQZwfuQOAxSABV05okeqrV6eSJGXBz+f1NgPghAnCGeGr7IqZpR7c3NCwY8ENK1AHLikK0ALvuk18ywO3eNWuu7StA16dC6IYkkQ7O6O2U6FpvZ+dtQyHtLCkTYzdHh0LzALEXlJP8TQM4o61E+7sObUN8BwG+n/HeeEk+txR2Son0geM5whUIXBn3YN6a8u5WSiGO6+tjzq0QHC0cO/aWOFPK75L7MgH8Z3wwWNcyxFhSGn2+SYoQbyHAbmkTStQTBWhc4HR2lmKi2RNaLcQzCHBUan/s9IpHUm9ptdtvKBVQpRTynjBrlvJZXV0AACZxf4TIdEl3e3p6roIc6YI5FWLywoUTbDbbq3ELVf8aCGCTRDylzW7nY82Qai6//yeIyPZDWrY1J9KGNe3HpToSHkRk6QkEbiPE32YdPxFbwGY72zNhQkXC4rleiMvvPxIQX+71TRAtjwEcmesjyakQLlW9AYiuT1kdXu2R8vSKBa76UEF3IPAbArjdJFm4ZV1399mlxC40BwKcVnAvZnBWsCc0bLMdvmiIIcMyVzVjNbuj1eG40mxKcytEIPANboGAx0jKa7319ZxfMaSanvsRCt0NjH1I4ZkysAu3euz260u5jBt5E3wET2OP4QxuKURjW2KJHlKtWVVPFUQPp6RPhtaHQrv+p6npm0xB+1ohFiPRROOGHkK8xGu3PzqkRsqYgM7O0RiLvRS3/g/LkI1ZZc73OJ3PlVLmZlXdURB9AAm2u3STJWFYDsk5Ak17EwGaegVGnOGpq7sm82PJqRBNPt8xihC3EaetE70S1rQrSrUXl/IFTe7s3L1KyveBaHyGoVeQyzZvmdgvc/zxzP7yoyyFAGjxOhycXDPkGm91AoCP5npjOsWookzLBPjkPmUQ4e7vv181ehvm2oJoJUks+prd5kCAKXzmm5Bw/CcSjbrLkTnd7PNdJ4S4yUSutR6HY8yQ0wYWKHFq/CQZDeVDAgBc4HU40px5/Xsqh+TotgjlCgQuibto/2iyfP/Fa7f/rBziN6rq/pbEtpHVYprWOJQcVKkCNqvqpUj0h15bi+j5HinPTQ1OfhcU4hUEOCbzzUjEi1vt9vvKohCJNLsvU2IFvY/RNO3ytoYGsxB8OUQpqM+mxYsnimj0HUTcRd82AD4LWSwH+SZN6s2x/S4oxFo0YXuLEjUscDp9Bc1YARe7VfVtIMo0ZLmHtzwOx+EFdDVol+oQfikfQcRTDYUgJDrd43Q+nxSiIIWY6vfXW5n0A2AqInKo+QHPmjUfVCp5pbmjwy4slqxjHiGu8ba07FgMGCbft+Py+6+Jk6azJzezLdtEtH+gQhxR/cnfHAicLwDuAgCdtEUSvd3qdPYayHkrhOEefj7OaML8i4mGuEJq2hmt9fX/6k+Qcvzu8vvPjQN9+Xyd2eZ4HI6sMHUpZdB5sjTtPZOcj9VSyhNb6+v/Wcrnlaqvpo6OKYrF8ncASAKdQrFQaGJ7U5OeSZ6fQrS1WZurqm4UnOuQwtKqQ76JbvY6nRwNLQjdW8gAm1R1CjKhqRC91AKG8Iyubs7sixDfJaLyvhCi0Yh4dtIlnJRBpxgkeo1plVPlEgDBLzZufH3lfvtxVlvl2qxZSnNd3T9Fgi9cb0ZgTvef5KUQjT6f0yIExzDS6AMNHsnbvKp6fTminwwJGyHlRYjIdEQ6TnCrbQmg76ubic6p9HbiCgSuQIDbeucS8TVPXd3RnNyTj0KgKxDgreIUk5fBeQlntjocvASVvOkoKEWZi0TpUcySP2nQOoxJootanU6zbW7QhODThhKLBbmIkL5CEH0Sr/lxEEP2+1UITsoRRHNSs41TlsdXu4PB44InnlhwhlA+o+d9GqV8f5CSbvIRacDXSKKXWp3O/x1wRwPpgLm5VZUVIhEWB/hGCnFKW10dYzFzN4ffv8PwBEn3FJOr1keJflAqrIGZFG5VrSOij8zO+wOZj0rd24ubcDiur5QMyee6VPUhJGIWYVaIMBD9zut03t+X61pxq+qvgej3WQkqiJrUtGtb6+u37ENlGOHEDz/cZtSoUZxTwCQZaQZlGR5X1i6N6Ks/SnRyOT+ifAfRpKrHK0Q66NbIanuwG/HSnArR0NGx8zBFeYMQHSZLticUix03GMGuxra2bZWqqtMR8UjaQm1oi5cWsGeWT9A1HYCXwkHjpDDkyCqDQAmK4jb9BSWMtY6Ypj3S7nQuKWU4Pl8FyLyO3QgWIZjviwvSsVLoeJecCuEOBDh4c11mR3q1OqJL49lKj1ZqYAZJCccSdkqVjwk+o9Ho/yycOnVVsRNV6H1uv58zurKTgBBDXatXjw0efPCgKWchshuJRxwS5w+LldYfsliYNTC7GRHEf8R5mLmkYVojgA+iVVXHLZwwYcD0NYUMIPVal6oeggD/SOVFMAb1jqelZVo5PZSZMhvwPdNTFpOEeR2Ot4odZznv0zPlEZ8HxB8bK8SGiBCuLIXYd968ajly5KtpFEFbJGNKuQMX2O2mkb5yDiC1b7fPdz0IkZoakPz5eo/DwcTqg9Z4S7MMG8bIo2y6oiGQGZ5rIvRyDWPGcDbeOYZCECAemK4QTMUTDJ6CREwtmMz60fvUU8IAnvA4HHoHlWzuQIC/uiyAipTywEq40V2BgDeHx3S+d/XqAyoV6+nzHSUI6dnhd13SRkTEn6cpxJQFC8ZabbaXAODgrJJAiEs0TTu2vb5+cSWVQcdQhsNfmWxnXbFQaMdKZE+5VPUOJDLjiPhUIB72kd2+rJJzluvZLp/vQhDizpTEo1vSFKIpEPiVkkhVSzviEVFUKMpN82trZ1S69nWTqroUovmZbncCeM/rcBxaiYl3B4M/BilfM3n2OlKUM7y1tbwFD7nW7PefhEy/ZOwGBPBsr0Lo/NSa1mFWi5IAVLBYjvKmACkqNTq3338ZmHBASIDrWwfZfkjOwdT29r0tVVXsQEuDz+n1LhCv9hTAzzCY89rk8x0hEiQjOsE6AfBBAmDv11+v2n78ePZcZeVAcrYPadpZrfX1Tw+msDmXOVV9BYnSEVJEmgZwWJvT+X4lZNQ9ugBzEJELoKQ1IpqpjBp14Ue77lrZKKfJxDR2dOyvWCx/RgCdK4wAuPAtgCsQmAacPo44Nus+otdj4fCxQwFkq/MzWq0fJX3wSVkJYCUlDMqKEJ4xc72lquqBHAwz8zYT/azSEU6zD0Uv8UT0WpIEhog+R714ajT6OCRqM6TZFOz545h/TIiia2BRLBarEuLrj+x2JjEdEGaC/SMC8RUgSndIIb6rWSwnt0+cmJV4MlgrhhFSZgRV2vGTANZKTftBqbioSzmezJxYItrAjK9HCXZQEKUdM0v4YK5aO9cAnw6IoNvl852CXG3GcLcaMhIhPrLOZrtk2YQJ7LquSHP5/T8FxJkmpx+SRMe3Op1zKiJYHw+dqqp7W4neAYBkTksIXX7/W4iYdaYvpfDswyCillan8+Si++WQbTB4XZzY6obUHAxGKCHAFR6Hg0lUK9YY34kWC0eGzRjWH/Q4HEwINqQaVz1SGF6AuIdhQxCDX5ajSSHVUkvOZQe9TmfRqKf6RYtGVAnxiMggFdOXZMTT2uz2N0otcyH96RwV4bAHABpM7uv0OBwcMxjQllmIPPlca64Qqsop/1x4vayNU8e8TqcOyCimGTmVzGnVW5zF6GeFlPLQShmUqWNxBQKPI8DZWeMj0iTAHoWSiBYzT4Xcs6+q7i0zt4xGv/9HCiInu1QX0lkh1+rGKdEvB5J4a+x3/AVmhpq9njVrfjAU3MMuVWW3/wtmczOUmOqS8pkalXsvXTpydDj8KAFwMdG0IuXGjWt5WS5EAVKvJaI1HBvRIpGWgRxdXcHgkcg8mRmNAAbMQVns2DLvY8ohIcTyrChsYq94xutwnFmqZ5WiH9NjJ3fs9vt/SIgvZnra9IcSvd4lxE/7Yy8rVkA9DGuxTNQ0LbXab1Z3AuA0TLCqpTVCvFVKyZZyxRuhnqPQksKrkSrTUi56ogFEzQRFRZHxkpZfemprPy62tEGhE5DpmALEBbrfgeHu20j5sE5Mmt1iBrP6k4U+sL/rdVY3gLsQYC9KyfcwvY9oJCKmF05PXLhOz4UYIs1QBjO4H1fkZVlzka8nq/Y8qIXDjwxkNc13KnK6rrmD+mXLxg0LhVTTVQJgmSQ6pJRGkVEV5ilAPDbfAfyXXMdKc4jX4SjaGZjvPPUZ3OJOXD7fOSDEvZk8jLpRKOXvY5HIjFJpbi4YXL6D+S5fJ4kua3U6Of+yrC0zzzPuZU0Pf+t1F4R4wYSeh42iTzSiH7U7nZzkO+BmUBEzCWjFmeQHPJhSdkAU09iv4nAwLqWcjZ2SN4AQ1yGRfpjIAsjwfzb7fKcKIVIJqnqFIqJHvLNnX1AKzKLOjob4JCAek+N0U87JGHJ9c6icC9EA0aOrurpuL3cOKEPoxo0Zcw+mQOg0xP/JwlS6ly4dCZHIi2DirNIr1CMe2Wq3v1uKGTXAvFwsbQrmKKFIAAy55yhsetCIaLNeyQex10gjxOFIlB2xTRGWs5QwQaeTVyMArqbDfeY8BRkvk1FcuiwEUMNVfZJfXuqD9GM4IsuuNwLoRoBlhOgFKf/hdTgWDMYpQ68BQsS8EEcYcpiDbPnHxs5Op0XTGLOfNQkE8BEoylHe2tqifROpE7Svqm4fjcXGSiHMfCBgkdIFivLHTFIQLvgmY7EZUlFCyf4QcUdLojBcfa63TURtMhb7jbRY8iplaGXsJuLvYUtOiFnXtwDin6JS6q5pC+Lh8VWP0xhqTC6+LUrUW0oBASIRonV+p3PDYKY1ZMHwifwhTTOH4fMgXKp6CxBdZULmtZnY6HE4HhmMAcRjLVx2gGuDbomDcEU8gOs8TueMzAlv9vv3EwlW2yzawMQnSRpHJcPR6OV9EpIRKe5A4FACeCWTpLT34yZiZbw5Uw6deBzxr5l5I8aXOCSY6rISdYhe7SHKnaijBz6I/ooAk0203NOjacf7yl10bdYsxVVbexMgXpkR4dwQB3OclSuk7A4G9yGuDZbgZTTLPeGSks9sJrrWDLjC5YqEzXaiEIIt/d7Kg2nzgMgUxjO+GDny3pUZaCgDyPNvdvFkzR3R155weNdcXNN57WMluKjZ7z9RIL5sKCmvbH2n8sGsWYq7rs48txOAnVXTvU5nL9N6CWTM6sI9f/5Iqql5wqgc3Ps7Ea2UUh7R1tCQkzXW4LRg45hhbdlKkVgpXgvFYudnpiQy7gIMZTDNPE+cBH4T0bSnc5WXcgcCzHbLFY8zG8U0ranSTHWFJ/uyLcFF3qur30Yis1UitNlms/u///2ywdamLF68kzUWey1rlUL0f716tWvFwQf32g9mCqlnjwO8DER2sxers8MTzenRtAt8DQ2rmcuxedy4kwQXYkmplpvsW0/YJdoERBd56uuf6usjcPt8F4AQZsVWGBzyu1anM+/CaCX/2EiHPXQios5UrNMBEJ3ClRX75YdoUtVjBNGsTGJxQ8jZXYhnlqvgu/FC5yHRthnL9UyP3X5WPhO1j99fS4gPEgBnJWUZroYreY4mJZORcorgrWYpjMmJi6chXNcNMLO/2E6zqtoFkd9sdSKi170Ox08GwwYzm6PGJUsmWaJRtSjCEP5SXIHATEQ83WQ/XK8JcWa5SibwPoeIL2UlDRVY9KzR79/LIsR9RMTWv5lScIFXrqnB9gKH180+lE2apv1yw/Dhc/KC6vG8qSozspgVbVuKRAd4KsRU5/b7rzJOTolXSvSax+HIm1II3AsXTgCrlSHuaeBWna+KaMb82bOvK4WzKlPhXIEAE1ikQc/0tAApdy80rmJUw2E+BE5o7XdlzNgm1sc9tad7nU6zZJycC5VLVV9Gomzua6LVkqgyTHUJ25AJ2YonHTPyNq5jlpG0rYMNMyFu8rS03FImhejADEgal4f0OhzmR8p+9pD6RYt2qVaUB4Hox2YUSaa3E30Rh/9d7l27dlahIBwufCsQHzJZWXtIiIpUF2hctGiqRVGYQK6XllASfT/5geX9pfCyqyDyMTTBJ5AwRr4EKY/z1tdzrkRJG5c9AE3jOpm21I4J8Umv3Z4NU8vz6QYRCht0J5hwTKb1wsYWIZ4me3reLSao1xgMTlWknGcSLOQt6t5YKHR5Mf3mOVTTy4zKgjx+3enI2Vpeh2Na8uK8FYJvMIqEPomITVxDWyO6uFzZUlwaKP6cNISUztGEeFqr3W4KU8t3ovSC9lVV76XUA8n+iAEiMU07ZkFDw5v59pt5nb5NAbydtObTFBvgTQXx1I/s9rw8psXKkHqfTm1M9GiSUdA4NRVPbWwYIFgXDI4I1tVtLqfP3eX334GImRnV3RJxn1a7nS3koprO51BVxcw455sVd8/otF0gnv+R3c5u/IKb4aBir+nRJjd/Go5GDypFgdl8BTO8k28DwFZGfk4k3KrKdMm9ho+xvHVELZYjF06aVBRlkI4MI7qfAE7NlwiVa2kJi+XX82trC88b5RoV48b9HoguMzFkY1LKwwaTAtnl9/8u/hFwbTJ9ZyDE50Kx2Hn5lUeoYAEVI/DyTwRIq8hLRLO+tVrPzqeGdeZXw3kd1RbLk0B0Ur5fVMp1yzRN+2lfntFcfboCAbZ3GHSUBf8b1Iz1gRZQ0UssIXJJwkEvseRatOgQEOKl1ORjg8GGi6pNL3SrmrJ06VhrOMwRSw7epBmpKS9yJSQ4tcwilMz2+jFJeU5rff3cQp7vUtUDMEH/lxUTIcR/eu32g4pQ0IJvcanqOUjEaZDGzl9giSWXqlasCBtD+RCRK+2l5op0SaLzW1NqO+QzKzqtYXX140B0tEmJ5sTkACwkogsFIhdovRhy5Kgwaow9lVpPT94pBUwVMALxQ9OibQCbv7VYdixmxctn7Mlr9EJ1msY0TKmVDAorwubKLNMIcI3X4bijEEGKunbuXIt7zJjbMqn++IgrY7Fj2yZPztvAc3k8o2HECIbFH2wmi2FlL5Q9Pce2ulyfG17Zu1GI881iGYbycNLR+Z7Zs5/O1/fi9vvfNoMlcn8S8YhWu73ok0w+c9zk95+mCMH+lyQn5eYNodD4gso0ulX1+rTEWqLXNhOdVu5CrrplbrM9DZmkIACdm9ev/4H/gAOYVqDfZngmGeL/U1OGuEQP/45p2kVpkcdE+YDrBcCv43v/djkUKRo/AN/YQ/RQPvOushWQAAAOIElEQVTh8vuvTq3BndonIf7Ba7czaqwsjaGKI4R4lgB+Yig0H91vb7XbrzJ7YE4/BKfOWYg40pgo9Uy0WY+I1dcz8KNsjQ1KUBRe3jKxBLM9Dsfx+TzYiJI+ZawM5pTIRO+Qpl3gnTz5P5l9MjWjNnLkRQhwbU6bgglcAR791mK5ob8l3wDtMD4iq8XjK/OHOxwHvI/IeRslb0z3gAB/6i31DPBJjOgnBZd65lCwe+zYm4F9AVtCwUt3CwZry1kMnqOESMQZRJkeyou8dvv9/c0Yu6eHKcrfchC267zOCDA3EomcvHDq1D7JVzkIRIgMTTeF9xmyPK1HXlOwnVkyJuIHDKgxSzQqG1MdF4P/tK4u2PtRc7hfyrs94XDhxeB5UHruHwBnXPcWTiGia72dnbeVo2AKP7NZVX8uiGZmTCrFFKWhvbaWw8k5m151Lha7N74V/DDHS2RyzjdJiN94a2uzVgazjptV9SIhJVfATSvtnHYtF1uPRK6cP2XKilzCuQKBt8yKv+rZXERneJ3O0jLVEYlmVb1aAPQSuRLA5zIWO74vO6xv1zWRcAUC13FFm+RAiegzKcQJbUV67/r7wt1+/8xMriYC+Gq43b5rX8sqF4izIPKxym0a4k58HS0SgMEpn/cnR/J3DuyN3m23M4xi81lUz8Z1DMl7ixKnINO+3ap6lV5ZIFPTGX5PdE2cO6OkpR11+iUAPu72VjyWALe1rllzXV9Buv5jGYnljslKkxFGzkF8KhYO/7ocJKHuQGCpyRGtT/thn2BwqpSSKQ3M2FuS28ScWCh0VntT07f5KkPqdUaqP8PWc84ZIarQ3X2g1+3OQqS7fL59UQi2I7LvR5wZ6+kp2XzqJGjV1ffH401cViL5vJVdiHv1B+zpXyF46wgGjwQpucxS8gthn8CZpeZN0iORFgtXh0vbszUpf91WX28KR2MnFirK3QDgzDHZGkk5W7HZfvvRxIlfFKMMyXtcgcD/ItEdhLhzLkwF+zQ0xPPaW1paU4+lXKPcpmnsfc0qF0UAJWWqc6sq0zY+m8Ib1sWJ3B67/c/9jT8vhWC37zCLhd2vZ6YYmJ+QohyR717cnyD8e1MgcLIC8KeMazlv4QcLnc5E7YktDd2BwElE9PskR5LJM9hyfywSiUzvz4DMRz4djV1V9TOByHaKKRrbgOT5JcAFbQ5H78lCdw7FYi/l8EesCwuxT0ddHa+OA2o6OgyR/Rr6iq57eIle2PDttxcs2X9/JoDrs+WlENxDs6pOFkzYgZgEVhABfMjJHbmQx/09PPN3dyDwoB6FTG+hmJRTMji2sdnv5wDVA3GPZjreMnkvV/0hejKsab8tlXzJrhsDgYMVAK41YeoGN04ymyTRtHiR1Hl8X1+RT72iDdFxXqfzL4XOWer1enre2LGvIsAhydWSHXrxVeuYVoejNZ++81YIXSn8/vMQ8Z6UiQgR0S3dQvyhv70pH2FcgQCDSfbNvDZeSecOLRS6sb2xsadh0aKdqhTlKETk8gimlr/BF/GsgnhFufAGbr+fM7oYvLtXTkge0deEeDkRzSWASQoA0x8kP6i0YbLR6nU4rsxnnsyu4dXLUl19EUl5Uy+PBlEsPhdXF2KwFqQQHD6ukfJeI0E0cS/iKglweinyPV2BwL8Q4AAThdgUV5S3gOhbEmIvJHL1kWsZIsS70Ga7wzNhAp/9y9OIlOZg8IciETDqteQzHsYJMOxZTQJ4c0L/mAnHa7ezI6yo5g4EDgZOETQKvXMnTGaubNx47kcFFI8tSCH4IUySrkg5O/klGwW81mwePrw+sOeeXxc1GuMml99/HyKyyzirGc9J6GAOS1/nrES86+vhw29asccefeZsDETO1Hv37ex0Sk1j0Kqpmzvv5yCekI/RZ9Yf0zgMs1gWAdEOvVgHgA4iOrqQI7Yxt3mL3Hshw9viSx9T8KVCzP8tpTx9IPSABufRO7mikn1JyrXAkOjhHilvKLXN0N8M6SUbpHyCEDkhqC+vpmlXBPBZyGI5yFdEtQGDeIWTh7eAiYhWE9E53kSYoSBuzIJXCH2VSFjbZwvE+1ICR8xvMLt748YL1P32Kw4nmMjlfBETvNuFtI1sy6z+5pv7+8vmKqTTvK+dPl00HnvsforF8kgqCDmv+xPI9Qerhw+/4v0CV7XJy5ePsnV3s2HN86XHbPhUIQEu3Yz4UDF2XVEKoQ90+nTRfPzxNwiA3qKkxpFrptfh+GVek2FykdPn23O4EJz/kC/JaQ9HZb3h8D2VTqBlELKtqup9IEqrkd7nXBAtiwEcXgwzT7PP95hQlF+khuoR4O75djvXFMlFbtanOMUrRPIoZbPdB0TMYd0bVWTuyB4pb8knNJxtLOh1v6ahlIyJqO8rqYaI2Ot4hxYO/2Gw4ey5ZlUnA02QoLv6gvkbJyEfSnmup76+vZAPSGffYSoggEt67+MTBeJfNm3ceG7RK3Rfbth8Bdyns3N3qWkPI8DhKcL1EOLD327YMD0fZ4jZszg2oQhxsiDi/Ik9Ur8C/ZyP+BlJebPX4Xi60mWf0uTn4mYdHQ3CZrs1R+qgBESVpHwJpPyTt6Fheb5zzdfp1Y632+4GkDINNU6IHyDiWZ4BOrcGtEIkB8JCbrvttu/p+RrJRsRewic9Tue5hQw4Y3KVumCwWtG0ccOFGI8Wi4740SKRzbHq6kULX3hhbb6opaJlKPJGdhJtP27cLhaivYTFUgWaxnxD3ZFI5BNF01a3f/JJuJiIscvv54/v7LTMM8TOSDh8YCm8sSVRCJ6zKcHgeJumvQBC7JP2NXOlHimv9pSbXKTIF7e13GYg0RmbwYw6etNtNqJ2KeVppSrQUjKF4O2nqaNjslCUhxBxnxSh+fTxJgpx6UCXs63l5ZVaTh29BvBHSGSvb7HViNoI8fxWu72tVNQCpVQIfR649qfNZuPaFb0IX0OTV5IQx7Ta7R2lnrDvcn9NHR1ThNU6B4h2y6BV8nVv3jwt6HJ9Vcrxl1whWDiubRGv9PYwSMn5mamYxtVSyitlJPJyObAUpZyYSvfVuGrVcMv69SfpwJx0qkVecd/ZRHROoACgT77jKYtC6Erh9+8KQlyKUl6AiFs4JomYa+FlTYgZ7XY7Yx/+f8uYAcMeY1IP5qhKrQ/CpaqeAilvLfR0ku8kl00hWAAdfjZ+/ClAxPgB/YSgN0QNOBMK8Tyv3T63UPdqvoPbCq9D9+LFB0EsxpSPe6XlhhDxUf6a1SNGPFzOOE1ZFUJ/IQzBs9t/Gh8cgz2Z5Kr3mexYEoh3RhGfbW9pWTlUj5BlVywibAwGd7UAnElS/tYE48HVCG5s/eablwolLSlU9vIrBEuUqETfhETsUj02A1gS9zzTfAR44vNw+KVVTU29tL+FDmZrvH6ntrbhO9tsJ6EQZxsR5C0fTKLi4N9Jyru8Tuf8Up0k+pqnwVEIQwLm0aZw+Lw4mywjuXuZaY3Qdg/wMUqIi/9bTiKMQkMp74WEQ6861U1PzMdNNEMLhx8oFhhczAcyqAqRFLDZ5ztQCHE7ATgz0+SJiGtkP6NJ+XgUYMlgh7KLmcRC7mFENAwfPsmiab/ibPQs0hIeP6JPCnFta13doJeOqohC8AQatTlOZ8MykwciscsQp+f/AxRlzurq6nfLaUgV8kKLvXb35cuHjevuPgyEOBaIpsW3SJ3FJa0hruASFEj0dKUoCyumEPpEzJ1radhppx2GRaM3cBnDrPQ9ds0idiHAYinl3Zaurr8VAgcr9uWV8j7OE42OHHmsSNAM1AJiTWbZBD3yificBnDTNnV1q8qV55nPuCqrEEkJOePabj9IEF3Nzk4CGGVCVso5mcskwHNSiNcE0arWuro1QyrSmVjaRL3PN6ZKyp3Aav2JAOCsrywgroHM3gAAHUB0m6ez891igl35vORCrhkaCmFIzCxp2xBNI4DjMJG+vsV3kT4qBs8uiBdzaQVNm0eI7a0Ox8rBsMJNJ9c4NipSNhJAsxCimaTkEgm5Uv84ceZ1APhzF8Cb5aKGLkQRktcOKYVICmXQ5+0FCQDICWb8TPrHmNxSpOyKF6INMueiZrW+vWDiRLXsK0cCde0kKX8oAA5DRCZa51KSI3KRjUDCudRC0ejdm2y2ZUNJEYa0QqRoNk71+xmB9CtE5FJAO3J6Wn/UxMQZ1YjtCNAhpfSDEEsUgG5ptYZET09kkxDRqnBYi9hsmi0Skd01NTrcbNSGDRiuqhLVNpuQUlrjLmKrRLQJRRlGQmwrY7G9FYAGIpoCQnBm/Oi+vkJjW+iKA145WeZNIcRjHrudIfkFAV+L+dKLvWdIrhBmg2lYsmRnm6btD1IeECcDZYRxbb7obAPruR4ThVR53+5GxFA865qztrkIbJS3G5RSAURrPD3Qhog1eu0sgG25likl/s4LUW302YkA/+bstnAs9q/MmhzFvrBy37fVKERyIhiJNHbcODY6J6CUnNR6jO73L4DQvEyTyl/9Ui7JBJr2qhaNLls7evT6re24vNUpRNbLZGKMRYtqQVEOE0Jw9hJTILExOoISdbqs/W0x+SqI4VGNINFm9iQiYhchMlUCp+q911pX11ks2jlfGcp93davEBkzxIhkG9EeitW6G2jaroi4E2c0cR4oIXJ2FVv+27ChGscasLtYEKINOHWZKIwciQUI87YCiJzv0QVE6xGR6Ye+IsQvpKZ9DoryWbimZoV//Pi8SNDK/SJL1f93TiGyJmbWLKVxzz2rIjZbFb/4EVJawzabRYnFFMViUWQkgskSkWxJCiLSFEWTihKTkUhMU5QYEkVsY8aE2z/8sChgbKle1mD083/oz6ONtNTL4AAAAABJRU5ErkJggg==";

const _imports_3 = "data:image/png;base64,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";

const _imports_4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAACGCAYAAAAcjCKsAAAAAXNSR0IArs4c6QAAIABJREFUeF7tXXl8lcXVfs7MzQKCCyBVBHITFutSV9R+LnVp3bAUkmBcUFDUuqC0bq1rxaXWuvG5S90XqgaSgAtuVbT1s63ihjsJuTeAFBVBtqzvnPNl3rvkJrlJ7r25G5b39+MPcuedOXPmeWfOzJzzHMIP/Jm1CDnbDUeepxl5TRuRp3Pg0R54yIGHFZQiEBtsZdWgNDaxQBSDxQPHOHBMC5y8fmhyctG0dhmazh6Dlh+yyuiH1DkRUGUddqAWeMWD4URqGARDQBgMocECGQRBfyL0F1A/EuSB4GmnA4EjhCaCbBTBBhA2EGg1SL6B4BsQVorwcnKwTHLgLynAKiLID0WPmz0gFgo8a/wYI6J+roh+BkghgH4Q+9VTXxA0gGT1UyAwgNSDsAnARoB8LPJ3In5tgBeLDic4mzM4kqWotOnguZXo27wJA8iD3QVqAoHGARiSNgG6b2ilQJ4j8Dxx8EnuVlgzbgjqs0S2mMTYbABRVY0R4tE/E8ghBBwooJEE9+vv8RFBM5GsBrAaoHX2yxbCRgKaYf/Z794+5M4kue4/QT93poFsA2CQCA0icn/r8RHAEKRGgLcJ9A9yzN+LR2Fpjy9mQYGsBsQMgdpzGfZmo86FwqEQ7Eh2Geh+CWBAlhHJ+8z0oQZ/2ExYDkGDBhrRiOYmjRaPBy3oD9PHATeYACD6aFCDBwoboB0HOXkGOchHrgHyQeiTKxhmoPYiJXtDaG+AhltbtJtxFAksL/8B402l+b6PhuODGQTOgrGPKkI2AoIWVKN/gwe7EvTvRPBLIuRElV7gkJINIlgnIosAebnFYOEJI1GbakPPGrDP1KAoV+MIAR1FRGOIsI0w9e9kqAaFF0ELEZ4XmJv7OPhs7ChsALLLIM0qQMyuw3Z9HIyF0scDcqRrFEZ7RL4moneY5B0SXgSD90tG4ptMfnWVNRgMjX1E1H4E2h+Q/UD0o+gyST1Ar4LNnAYPFkwqwNpMyh7ZdlYAYuFCeNYMwzhofQmJ7A6i/h2XBQEYIp8I8ABrfh0Kq44firWpngniHSg7c8xZge3A2CHHqCOYcBZAu1PnpUUgskGIPgGZWwf48Nzhh2d+h5JRQCwS5CyvwXB49I0ClKKDkSgQJmAdRN4Hya3ffofXNreDIXswNnAQjlRMFxHRPgxsQ6COdochoALaXDFsGJaNocwdfmUMEBXVGAqPOoPsFyS0U4cvUQCpFcGLUFy5ejXe2tyA0HFmmSXIGVCLn2lSxSAcA1BRJ+OY5CsRPACHHyodhRXxzk7JKJ92QNgptcqPXxHUNQLsAlB+u46IbIDC/VD8+IomVE8fhaZkdDRb6lhQjbyNCqOVVpOJcQ4R2e1txCONBHwu4GuLvXg23UtiWgFRvhwDPC3qYihcCKE+kVpwt2eQN42R35SNRE22DGAq5SivwUit6Q6ADu20nSZpAGOmk8O3lQ3DmlTKkXajsrwcWo/BQXYbCYWjIW33B9ZYJOANAf7SxzHzxv7AZoSeBtLOGJs8ulgBvwZwaDvj0x6DM16221SzCP9XVmaPzVP7pHyGsEbV4EF6sohcBZC3w/T4LRNuylH89Pjh+E+27clTq/p2tdP8ZdjRsDoRjMtBNKiDnvxEdMM3q83jqbalUgqI8uXok2PUxSJ0dfBIONBPF/nyOYHPLC7CO2lUfNY3NdeHAxTUAwLatcPRvD1+v75Fu0tIQ6o6kjJAzF+OkcboayCY1N6aFnuANNsB31xWiFWp6tjmXG+5DztoqN8TcDJAgyNtLRBma22uHT8sNXZWSgBRsQRFlKv/ApZDQRT2NyDISgZdtB5m/umFaNycBy3Vsj/iQ/420BMAuR2gHcPtiTgg+rsoc1ZpAWqTLUfSAVG+FMM9pF4F0eiwsCT2+mgJe3j8xGGoTnYnfsj1VS7FaCg1v3VmGAWhtttdkSWO8JFlI7Asmf1PGiBmzIDa6zT81LC6j4j2CAkpIs2tt4PzHSOXJFv4ZCoim+uyH5kmuo1AvwJR+ApeRBZrxed++Cj+NWNGcm5QkwaI8qX4iUepx1u92PZov3WSexzhG7bYC72DnGtXiLqaiM4Lf2zull0WO8yTy0bg4961ELL3k1DLU19gSG6efosA675mH3v0bF3Jbisp5MuT0MSWKoIaqPSpmwBcBLi2mftBi8DX3GwOPunHWNlbRfV6hiivxq4eDz0CqP3bkCubQLh90zr+8+Q9Xd/DLU+SNPD4R9hqq23UZRBcSCDXWzzw8DuOI6eXjcJnvWmqV4B47ksMasnVD4FkLKRtNyEi1zcYvvWUUVjfG+G2vBtdA09WY+s+OepSEroqXILEgdCCnGZzxridratgYk/CgHDd2+rUXSJtaxogBoSZJV6+NDFxUvdW+dvoo4ZgLImeCsHeRGh/qdahaRE0gvCBkHmYV2JB2YGpOwxKtNdVtepWIfwWaNt9COS+Ei+fTwm66SUECHv+Xu9RFyrQjW2HTmKdVR+rN3xJts0MFT78FKKvI4XDI+9RYhoIgiOMhSDzh9JC/Cumd9JUyM4UfXPUbcKYQkQhN0Nrv12R7/DMRO6F4gaEe33t0xOh5F5I5Jk7v95k5LSTRmJ5mvQRUzMV1diHPOopgEb1Ij7DKrlaHD6pdBTej6nhNBVyz300PQJRR0QsH6uZaVppoZkT7/V53IB4diWGtzSpBQTaLSiAVday1liEvYoL8X2a9BBTM+Wfop/uoxe2OraOiemFHgq1OvwuMg3m8LLdbIBO9jxVPmwLqI8ENCwMepJPhfm40iLUxSNpXICYtQh9Bw9SD4jQyeFGRPxQfHKJF/+Mp+F0lJ2zVJdoJQ8BtG1y2pPvhWhqqddUJae+5NUypwYHaq1mR94oE6R8w3qeGs9OL3ZACGhunbpCgWaE12GSjcS4fNtCvj/bQtis0fuTOjUDQldGcXBNaCRcR1+SP35cwDOyLbbCuhkMGqDOIYUbIQEvLBsw1HpIMaO0kP+IGONPYwZERQ0OIq3mArRDaKkQwYLVa0xxqu/oExm9wOWQ+l8EHE+S9lhHnvXg32bj5ZwLikF6HgmOjTD2V4nhiaUj8X+xKCEmQCyoxtaNHjULoLK2SCX5XHL4qNKhmXEG7alzVjnbD8I4sNq3p7Jx/a74vW9X47ls/AhsP+bVYBhr9TJAuwT7ZSPZyvMdPntsDOdCMQFinh8nM9Ss0FQEyFqATy4pxEtxKXNL4bRoYO5SjFXKtScCthPJRgU+e4IXf+1JgB4B4Xo9OdonQCgKSYRw/3oxF2XjtNlTh/8bfrfL5das/5eUu1y6Y0zA1y0eU9iTt1W3gAhMu+omCF0UViTJUkd4YlkhPsykci1QVQtGkcZoJWoPgEaKYFtBBwKQFAtJgENkt9tSw8SLxWAJ56C6J8WnWCzMrcbe5FFzKRD/EXhIbt+ugH/f3QagW0AEtzJzAArzLwjJJSUFfHu8Bx7JVIA9eSQoi/7/CQa8xBSmn0wZuqir2QYYAfingP+SyZNN65+y+2R1sSK6uU1WWQniid0dEXQJiPJPkevpq2xl0wEKlpOPir1s7wEyQqFjZcrpp2aIwaUBZpiQXGkY6riasCwAMEK4xdTzjLLdXB6KtD8uxZJffUgIOSyJHbc7nXr+XVcydQmIyhrsDq2eB6gg0BPZQMITi4vwStp7BsD1GlLqTwQ6HuiCHiATgnXfZotA5hjmyzPlLTZvGY42jprbFiEmdTD8y5KR+CSa6F0CosqvbhOhC4NGiYXWPMPm9LIRsAwsaX0qP8dA6qMfF8ZRXXAv2OPzr0VoOZF7rJyuGYxE0I9IhgFu6H9nfbocFnhFGszkkl3wXVoVF/iQttFKP0rA+NBYEsnMYi9fHDMg/lqLH+WR8lMo7lJkvWE6+/iR5ul0d8glFaujp0lUSfTLKX5Dablp/Vq81dCC5tH7pg0MriqWvAcaMgQ5pgmHMOgyQB0WRUcixJUDCuTETJzozqnRJ2ols0C0tTvXQxqbhL0nF+HrjrJ2QrRdd+bVqVtEqA1BgncatDkm3cQW9vh5D78+lSB3CgKdCS5fhog+EGP+VFKEqliPZVMO5gAtYjFYXQHCXpF+CgRZL6Dpi73miXQfe7tELKztmVHYq41IbptQwJd2tAc7AcKNqfCol0DudbH7MHDaxELzWMoV2qGB8mps7/HoZwDYry5CVn7TYbng+CJ8kikDtytduIQhtdjdo+guQB0aUc4uY284jjmhbBS+TbcuK2r0aaTxSNs35V7nH1M6un1sRydAVPoxFaLuCtH5CFBr3jWj0xFo2lFJVbU4SpRa0C4egbCikc2YaNNdupXcXXt22c1XehEEQ8PlbHyK4xp0aT/hdQOu99NLCAieS1gyNL6gxIuHI/vRDhCu/0BfPSsQQhaaHOTCkkK+MxPKrqjVTxPhhIilYj3AJ2wuR+aVPksMop5Bu+UO5SWFJqJP6dNslU/9pnXpvT10H0XAX1u2MmeXDW7z72gHiKerMSJXqzdAFES11OV4+MhxGYi2WrAAeY27qJUADWib5jB/HZnTTs8yR5yuhvSRD7Dt1tvqRwiYEAHqNfkOD0nEva230LFRYELqVSKXTtGeXK6gFj4skkOzHSAqfXoK4K4zob8/vnG9OS8eB4veCh16PxD4oz+KkKUZLJeVjOCZyWojHfVU+JR1gv0zBQhR7SMOmz2TFVgTTx+sC3+/rfW9ACaHZAFwekmEfRgJCKr0679BEPTNkwYBLiwt5FnxNJqssvNqMY5JPxvxZX2nNE+aMBwvJ6uNUD3WEAzeACX9/CK4bDwJ0MBwe9qMLx2OiL4lu0dd11fpU+cAsAHEAQYfwuslXvOL0NlNGBAVtSgg0l8CyAtNJ8x83MQiLE6fuG0tVdZiMkhH7GxkpRCPK/Umz8nVHoXrPjiGoI4iBRbhBclmuqvwYx8S9VzkfRDETCkpwuOZ0Ovc5dhDGfUCJGQWoKkJ5scnFcIfwEfwqaxV01qZS+6OEPLNxV5zRLr3zKH2K/w4g0Q/GJZHZIUjPDaZU+3cpeocpXFLgDnfPd5cT0zTSkaY2ckaLHfpI7WgzS4DhMyZpV48lKw24qkneLbzuqUvCr9Hcn6Jl+8JAyKwJaHnCeqYUCFS8tviAr4jnsaSWbbKjzMkRYCwjPpNjWqqVjRTIviugvI3gXHuOmWeSoa/RzRAEJkzizMECNvHylp1CYhuaRsvfsl5V35pjxbcGcIuFyC1kEChYF3jITPqV174kjnI8dSVKkC4vpakzoPgDwBZpvtOj0DWgHG1aeQHe3tTmY2AmLsUo0jpL0LOxwLxQfhw67LvAmKuD0cT1GwKGT4in5QUseV4SLqRFSsoUgWIqlr1ayjcLtItq769LNsApvN6u3xkIyAgoAq/+jgUWyOQ7wQ8aWIhXnYBUelT0wHcDJBrUBLJXcVetn/L2JNsQNiYkkHbqdOUpjuiLBNd9dOSpp69DuaZRJePrASEnQRq1d2KaFqg42L7+Tt7AEl3ViNvqFa3IUBE4QJEyJSUepHRYJRkAsLGojZ41LmtfZtBXSwTXSNf7JX1VU49P5zI8pGtgJjjR4kWXRHstyViv3eF4Yvp+Tps12z0EyAc54IBWGfEHFBWBLsFzdiTTEDMrdVnKSW3Q1w+hWg3vDaRmp0dt4tmUojIegidVzrC9Oi13PH9bAVEeS121qT/TUDAjhK8kKvNqVS+HDt5HPUiQD8JTh+LnWYeW7YzvsoYGgAkAxDWEVc7arIiuruLZcLGLHwpxKfAQR/S6rGopOQBRTSJ4Kw+xpTHc+ycrYB4bjl2chz1Yqs5ERh3kU/qDR9LQZazd8IWt+D5Bm0mp9v3oSP4egsIu0w0etTZrTPCtV3GdoosAfO5i0fgjV3ngHL2x1Ei6t7OjLsh6eS71vxdV5gGfjTW5SNbAWF9JPKNfoKCKwPcWZD3o3nLcAgb/WZE6Nf9+Q7/Np6vIBUzSW8BUeHXZxDLTATY5jsvE8AqEXN0aSE+DvlUuCQoKzAGjn5Julg+APkeoPNKCmPzHstWQAQ+GG1DHe1RtjtHKG0OtVwPp0ngQiswcUCuKy3kazO55bSCJAoI14DU+lSlcF/UZcIyq4gsIcWnFBfgvWhgrlyKg2GXD3HPZaL5nTYJY+rqtWZOTyF92QoIu/Ws9KsZgEs7HerjVPvHG2yEdBAPjYpw8QQv2xuxjD6JAmJenR7HLI9EXia174gsIebzPirCwq6O5e3Jbe7+ONqIupfCXucd1SH/IcWnFhfgte4UlbWACJxY2m2n3WEG7q9EbrQHFI+T0KlBQKwnRWcVF5jyjKIhwRnCjdvoq/4soN90tUwomGM/egyLeyL6tMvHPl9hf+PoBSJRdh8kDMZNziL+Q3feZNkMiKo6XSYsD4QdeESepAqffoWAIy0AbLJTI+qUiYVO0q+Y4wVYIjNEW3AR2UO1tqneLhMsNSw8aeIILIpHlso6HAxWTwTjUyKXD7tDudnx8lVl1HUei2wGRGWN5xhoDl/NC/AqVfnU+wKblNSdM+LiEohHsfGWTQQQto3KpSiBUh1YY6QawtMWF+K1eG9v7fLhOQDHgtXdbUFL7vS6GsSn9uTOl82AqKjDQWRURSidJEE+sDbE8vDdOMkK1nzcxGGZ8YGIBE2igLAnr8Ny9fHCuBGEHSF4y2Ez/bMifBovGELyWFCofbG30vpOiHVllzoR+v3qNWb+ZmtUujYE9oRSz4fGnyDLqbJWf9/KLRm89ZM6MB9VMgJL4v2ik10+UUCE5LBeUO8BnmSnPLTLUtmuaIk1FiSbZ4j5X2Fnp1m9QoGU1fb5nip92uatCFiZEH+zw784MQsSl/cWEMkGaKL1ZTMgAkng1N9COykBGi0gbGLywKUWxGeYD8tUYGoyloxEBs5mFv72MEh3xmEi9dp3shkQzy7F8Bal3ojwg5H/akDMX4YhLUZdTcAUBbAQZjUy35zMIKBsBkTFZyhAn3aOUWK3nQ2EAO+ziNQpD/+8eDiWJvpFJOu9VC8ZgZBFfScUjoUglHrZiKAKxlyYrMy62QwINy+ao/4WsXtqsIBYS7BMqC4glhnwUZm++raypBIQLhhy9KMADu54gBXMI/qaOGZqMkCRzYCY68OPNdTL0mZUrqUKn6oLW5k/gG1nTzOUzTlOOfo+iOv/EZUfwyUoFVQaMhf0NhNQNgOi47bTTggWEO8RaJ+gUbmKiEuygaY4FTNE+Rco9OS5N3y/bOPb7BJCNnFchZNjLioblrhvSDYDwnKIKa0qKEhGK5D3qaJWv0SEo121kKwm5kmZog1K5S6j3I9Cj2h7q/uzWFnx7UyhgFfZMWcmunxkMyCsc7Um9aQEsxqI4GWq9KlHAbIxndaKsKQWvy4tNJaTIaNPMmcIu5twHH0/kTszdMu817HTQZtibqOY6YnsPrIZEC6zjBbLUBwkY5HH7G3ndRRIxex634rg0tIiviujaEiiUfnU5/Dm5+uZAvwqhmWiq24bYczx5JiLxw+PL9FZNgOiolZdQIRbQt72QnK9PbqeDEIohlKI5IYJBXxNpplZkjFDBG0GGzLXgYEmfrgHZ4qXczzmrHFx2BTZCgiXstCnriNyfWECs6ZgClX68T8QbZnSA6eVgr+sJ/ObROMQ4ld19Dd6C4gKP3Yk0fcDGBd1mbAJ6TuH8QWEsdfZYnkw2z9Bm2KOGDO9ZCRsDvMen2wFhEt/DH0HtWULEDHmELJhXUqpfwMUckF/0fGYU8qGYU2PvU1hgd4AIhCaqGcGqfhCh06R0jaC5AkInRW1CyRPCtMJRFH5MI0AzzQ3mUtjyZOZrYAoX44B2tGzCZblxp0K1jLzAVT+JXby5KoXANoz+MOnLhnVqMymPUgUEBUrMJRatOVNspwH0QxISyb6sKnnKzx9dVTeSCffDPY0qlsFNIkQfaZw4xjyzdRxQ7pPiZitgLB6Uo56WYR2DawMsti08Fiy+ZoELg+DNbrssyEHZv9xhfgihRNAj1UnCohKv7pEmG7s6usGML/eMafbzIGVPh01drWk0Nh4lQEeR88W4KhoGXks1yMYF5eO6N7/NFsBUenHLsL6HSIEsu8InlNkJpO931d91S0KdEHbrac5sbQQGd16JgII1zlGq9slIj92GHmCJpDMdpgvCrHxdgcI+17lCgxEi5ubdGJUgJHc6hTwZZujC12lDycC+qmgfoQhd3E9XxqI/q5V01qRcmuYuRYyq6SQQ/76PX7NqSiQCCAsA/xPptjbS3cbHWkUtkDkUTTx5ZH0wj0BwgXFKgymRnUrC50cuXwI0CIiV04s4lu7C1nI1hmiyqdm2TOnoJlgk9ZeYklDXEBU1eHnwm5uy+2DBb4s9vIumdx6JgIIK/uzddjNiCoXoZ0D5w7SLKAX+zhmSscUQ7EAwgXF5xiIfP1XETnMTZgqYgB8KppLSgvaE392/DiyERDBLecSIhoZHO9vSfFJNqTABUQwvvNNgEYEO8TcbHabuHPm7IhEAeHOePYWj9TJzBgohE/q+/Djk3fonJQ+VkC4OlqKbTxKTRGBBdoqaJ7dExiC73WiFMo4g4yb6UBb7rCg0S1Lczx8qD1fcf8Q4B2iKkCFDEs7C15WUsh/TsVyEEudvQFEqH6XXa6b3B7xACLWOjeHGaKyVl0JohvaZOVnF3ul2DohR7LQnUEUQfIF/Gs7vznk8MPhxDKAyS6TDED0JFMigOipzmwHhHUXXOvV/wDw0zaQmzNLiwIkaGFAuBdARtcQEOAvhKxk5vHxBrbEq7Cuym8BRLI02b6euUsxRik1P0STKECDaTajQvQP7Q5uKnz6BQLGBgGR0YuuLYBIDSA6XWgBC0oLjUsW026GsP+Zt0yfwAZ2bxr0wsYzniZz1vgfY0NqxOu61i2ASL7G53+B/k6efoAQJpQXpXHShOFt7g7tZogqH7yAel3C9ISy0lF8ZFkBPku+eN3XuAUQydf4vDrsatiNw9gxuAr4CXx4cZDFttMMYQk9m5vUPRRwmLFgsfR8V5QU8k3JF28LINKt0wqfupxAfwyNrUAey83jaeOGoD7qkmH/WFWHU8So+4LMKxYRq8y7pqCsLL2pBrfMEMmFS3k5cvV+2hKT7hDYM8hG0nxucQGejGyp021glGTi1tcyzIWcXDG32BDp0ufcWnW+Ipv2KWg8knzGHj66dGj7W+1o18NUuVTNgKI/hF4WGyZu+JhYnUKS0cktM0QytBioo7IGg0mrl9poH2wiNbmuZARf07GVqA6nry7FNhuV+krg8jq62eXFoQtKRxob3JKWJ02ACMe1RnRKSgpNNKeahPqdDXcZbgI2j9wFcQnYbOD6pn7MOx0ZJQdrlx7IFbXqOlJ0ZUSYW1o9qdIBiAq/qqUAsVj4seGMpUXsTWj0o7yUaUCE/DoQ9oyCkMgNxUUcXgG6tSFCP1qmUw+5iT+C6Rql3hJ8povyOB2AmFuL8xXp29CW/qiZxVw8sQiReUN6hY1MA6LCj2ISZWmD+gY6ItWO8LiuwjW7nCFmLIRnD6+6QYBLCeROoQL4BvjN6HTcb1T4cAJBR2QSlv8ocPGEQvy7VyMU8XKAkwpTAXVF4M98o1OPhDitu5Jpng8HMFQVwnt/q8f0OCDNWoScQQP1lwS4s6BA7OXVLYv9fNWMLu6oug1aqarDvsKqIpJbiVmu4/f4ulTn8az04wiIbqP8E1lPoLOKizLPkBcPIOfW6jIFeSCUZtkdGDZHlo7A3+KpJ96yLjfWfsrmBIlYGqSOFJd2xc8ZsC+6edxMO2PUNUShQB53/7pciMtKC/GveIWMp3zA+Vcvj5DRMOSWgV6+OhP5s+ORPVTW5i3/zq+uV6BLIzy4xGk2w1LNJV5ejf/xeNycocNC8ojI9WYRX9vdx9xjWJtdOn7idTPChowvEcETmzakPn1jpU8tabNh3G/r/aYmHheL+3siA5jsd9zYEKjnILRvxKDUlBZxOI12stu09b28ClvVN2rL5BvkHw0s9x/7zeiuloqQHD0Cwhac48N4DZcp3iUnE8FGpcxpxV6E8i2kol+oqFXXE9FVYWW6YfpydUkh/ymT7n2xdDbopnY5iK5v57UtcmNJEQeZg2OpKf4ylbU4Hko/DAl4VAOyzoCnHF+I+T3VFhMgLOI2Nag7QTQlFNFk+aiI+ZhUMtZZ/gKBeoWIBrd1RNaBeVrJCCQtc15PSkrk98qlmASl7onM6yUi3yjio4sL8WEidcbyzvxa7GxIvRRm9Hej0OSxrfrw9KOjuBF2rDMmQNiXqnzYi6GeJ9BOwUpsTMM/vv3OHHv2mLbLkViEjrWMTYu0/UBtj1tPb2/vyPcEPq/Yi6djpQeMtc1elxNQlR8nCtw0Cy4zT0hfwnh09Vpzfqr0FczcuwDAIRH+kl8x8biJXnwQS99iBoStbK5fna+ErNu5S2MokAZSuNbZyDNjzR8Ri1CRZeb5cSCLmt0ph4XIOhDuZ+Jn+udjSSzoj7fteMrbWXRDI0YrUSdAcA6oY8Y/8SviSRO8eDueemMtG6R1vqg1/vQPFMraCzQRySXFXo75XCUuQLiN9lN3gMkmJgl57K40wqcfX4RXYhU+nnIBamE9CQwbuBt072v76gCpFaEPoeRDYlomBJtQLG0PCfJEyXAw7UUke3WRkaeBgXP5XfNkqrbrc6txtM5RD4vQkPCMBPmLqefp8XyscQHCNmR9L43RNkHb/m1Lh3yb7/C+Y1MVD2rTCtbpqSSwaRtCSdUjB93m+RBySc7ThoVAQzbyQ6AokD48mj6bhXBeaYF5OFXL24JqDG3U6gOQm188FNr/rtNiiuPd3sYNCKuDiqU4DqQeJKLA3bq7fvA/xZFTSkd3H7iS6HAFp8SpAH7fdQqkRGtP1Xti82n/OdGMfrFIFWTUswZ2hBe1rILwmaUj8EIsdUSWSQgQ7pHoduosUnRn24GLtFisOPU8rWy31FAJWBdB5+f5AAAHTklEQVTyNUU4gIw6V4gmtB7DBm5js+xpPe7fRCLzRPN9A2rx71Qd9T/2OQb2z7cs/SgFKMdVA8GIkemr1/IDPRGzR1NbQoCwFdk4yj2mqD8CdFl4krBn5YK/lhRx+EAkFWMVACT2UkpdLESlXRJ/pKLx7uq0JCQslQS+7Zs1+CCRAYlH5Eq/ekIEJ4fumoJT9U2LH+Mre0oQ01U7CQPCVuhSCYi+GyRlYYS67hNyb0sOX50O0hEbYqc92A+iRpNNnMboG+aljUe7iZS19opCvQBrQbzEOHg3FFmeSHWxvhO40nY/xoiAbGlpTd08p36DOX/SHlgba10dy/UKELayZ/0odEAPQNTP2yqXBiI8mNefrxo7EOsTFW7Le501MP9b9Dcb3VvoX7dF67s23GseJWf9ygtfb/TWa0CEZwpSCyG0V1gYEocETxZ7eWqqrOvedHyzfDeQSe8h2DsKIk+Erj8kcd3pv+9tv5ICCCtERR2KSPTjEPkpQGFuBoI8w8K/Ly1CXW+F/W9+3/JmKXITzJ0QMRMbEP1LyEyOJRI9Fv0lDRA2D2SVH3sytCWdODBC6BYBvZ4L89tM0xTFopBsLGPpf0gs16YcEWmrtdIdva1gphV78VGyZuHkASKoyQANj7bn6aGDK/uLvaVcKcIlpSPwbjYqPVtlmleDA41W5cFoq0jn33eQY8aWDEVU4rRE+5N0QFhBXvBhhybS90DklwBFnCzKd1B0ubPRPFW2GzYmKvR/w3sPfYH+2+WpSa0nszdGUEZatrgWKHoBMOeVevGfZOsiJYCwQtrs8y2O+h1ANntsBN+TzZ2NKm34xvEjUZPsDv0Q6rPcoaRcP89iCvqgBPtlhORe7fAtE0bCepMl/UkZIKyklhVuqFKnk6ZbRdpOFV2aYBIfG55eWoQXs93ZJela76JC16mmFmNJqztFyBvpWEOETWLkknzmR8aOSt0FXkoBYftdLtDaj4mtJzgzCC4RWFubhI0ico8hnvVZAeoSzauZrgFLVTuW0mnXOhR4SJ0NoWltnk5ui/bi7stWM2yG8WJuKhLFRfYr5YAINkblNdjH49EXQuy5eyDHV+hpTVuwiEUeNPU8+7/NtrCcDS156hQlOAPU5nsZ1I2lC6xwHDOzbCTe747+MFlgTRcgXHkDhBXqjNap8DqA+kd0wtIONAL0scPm4rIReCtZHczmesqX4mCt9UwS2Q0g+5FEjIdsaN2bXaNb+MF0ErakFRChwbGpfbTWNwlkHwrFj4Z+FLEOLnOY+O51TfjsjAyw16QSRIEZAbsqUZY5eCKIgkl0A60KZBOB3jfGXHb8yNR4V3XXv4wAwgpkyUAlX50KwXlEoXDBSFHlayG8AuZnN23Ai5P37MwzmcqBS3bd1sVuYz2OJajxIBwJ0I86tiEi1SDcS438RCTjbrJlyUpAWKHcmI8fYXvqqy4VoXPaGPDapgsAGyGoJUV3bWoxcyxpeToV1Nu2FlRj64YcXQYWm73Gxrb0Q8C7KvxYJjgiuV/q+ZaPv8a3PcVO9FamrAVExLBT1TIcBNZXgmQMJMIVrJ3eZIUAT4K5ChorPvZlVnnRFOuCvBDbw2AolCom4BSAhkZxrxOQfCdM7zHMHycW4q1s2H5nbMmIpszyt9HHsxN+DlYTA+kawkld2hcn2QimDwB5F8Tvag8WfTAUtZnattpt494rUGQcjIGo/QDaD0r2DvExdO6rWH+FZ6F4rvMVXis7EA2p/OrjqTurABES3MYXbNMfQx1SvyHQKQAidySR/WNANtllpbVcDYu8ocGvNjfg3/F4GsejsFDZckGu9lk/RvULRXSYQCyRuF0OrFtfV4QjG1rLPekRvmPdBqzIRrsoKwEROUDWiVTlqtNFUAxgp2BKwW4ZXuypHgs+IcgHzFgsHl6So/CN04xGIjR7PGhpakIL8mFyHHCLzeMLIEeBWjxQaITOy0OO4yBHBLkg9Gn1+B4sUKOUwh6WmkcRdo88fe0CVBaw1ub5ighV3MyPpMoJORFQR3sn6wERnjVqMLifRx8MyEEkdBADe3Q2QrtUiwhQT5DVgDVKyRqqG4XQSECLm3TNPgKbYieHBPlwM82IjY3cWkCDCLCEGzHpyxqJClgskLdB9NZGx7w1Ocakbcka2ETriamDiVaeivdcd/w8bEsKXiJ1HNuZg9y8UZ2y6KWi/S7rDMRQfqaAKhF+QRh+pwnfp3rpSnYfNztAdFSAeyFUjULK0YcKyeFg7EmEbUDYCu6FWscTwF6pMHCiStgEwSYRrIPCRyS0UFrMmyWj4MuGnUJverjZA6Jj58u/QT80YLiHMVxEDYdgCCnsICSDIGqAIvQXka1B6CtCfYM3iiGfjebgTWw9BPVEtJ4FG0C8hoRWC2MVCCuJeJmjsAx9sKxs8A/Lr+MHB4hoM8ijfuRtxcgDI1fnwGP/NW+ABx7XeIRpDuwKdC64yR6cOzC5/eGYlsA/KDRvUmg6zWuDZwMG6A/1+X91Fiu7mKULwwAAAABJRU5ErkJggg==";

const _imports_5 = "data:image/png;base64,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";

const _imports_6 = "data:image/png;base64,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";

const _style_0$3 = ".ai-control[data-v-ce0c153d]{background-color:#fff;border-radius:8px;box-shadow:0 2px 4px #0000001a;padding:20px;margin-bottom:20px}.optimization-suggestions[data-v-ce0c153d]{margin-top:20px;text-align:center}.suggestions-list[data-v-ce0c153d]{list-style:none;padding:0;margin:0;display:flex;flex-wrap:wrap;justify-content:center;gap:20px}.suggestion-item[data-v-ce0c153d]{display:inline-flex;align-items:center;padding:15px 20px;border:1px solid #e2e8f0;border-radius:6px;transition:background-color .3s ease;flex-basis:auto;box-sizing:border-box}.suggestion-item[data-v-ce0c153d]:hover{background-color:#f8fafc}.suggestion-content[data-v-ce0c153d]{display:flex;align-items:center;text-align:left}.suggestion-icon[data-v-ce0c153d]{font-size:20px;color:#f59e0b;margin-right:10px}.data-content[data-v-ce0c153d]{text-align:left;margin-left:10px}@media (max-width: 768px){.suggestions-list[data-v-ce0c153d]{gap:15px;padding:0}.suggestion-item[data-v-ce0c153d]{flex:1 1 calc(50% - 15px);max-width:calc(50% - 15px);padding:12px;margin:0}}@media (max-width: 480px){.suggestion-item[data-v-ce0c153d]{flex-basis:100%;max-width:47%}}";

const _hoisted_1$3 = { class: "ai-control" };
const _hoisted_2$2 = { class: "optimization-suggestions" };
const _hoisted_3$1 = { class: "suggestions-list" };
const _hoisted_4$1 = { class: "suggestion-content" };
const _hoisted_5 = {
  key: 0,
  src: _imports_0$1,
  style: {"width":"30px","height":"30px"}
};
const _hoisted_6 = {
  key: 1,
  src: _imports_1,
  style: {"width":"30px","height":"30px"}
};
const _hoisted_7 = {
  key: 2,
  src: _imports_2,
  style: {"width":"30px","height":"30px"}
};
const _hoisted_8 = {
  key: 3,
  src: _imports_3,
  style: {"width":"30px","height":"30px"}
};
const _hoisted_9 = {
  key: 4,
  src: _imports_4,
  style: {"width":"30px","height":"30px"}
};
const _hoisted_10 = {
  key: 5,
  src: _imports_5,
  style: {"width":"30px","height":"30px"}
};
const _hoisted_11 = {
  key: 6,
  src: _imports_6,
  style: {"width":"30px","height":"30px"}
};
const _hoisted_12 = { class: "data-content" };
const _hoisted_13 = { class: "data-title" };
const _hoisted_14 = { class: "data-metrics" };
const _hoisted_15 = { class: "metric-value" };
const _hoisted_16 = { class: "metric-unit" };


const _sfc_main$4 = {
  __name: 'EnergyStatistics',
  props: {
  energyData: {
    type: Array,
    default: () => []
  }
},
  setup(__props) {

const props = __props;

return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", _hoisted_1$3, [
    createBaseVNode("div", _hoisted_2$2, [
      _cache[0] || (_cache[0] = createBaseVNode("h4", null, "Data statistics of the day", -1)),
      createBaseVNode("ul", _hoisted_3$1, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(props.energyData, (item, index) => {
          return (openBlock(), createElementBlock("li", {
            key: index,
            class: "suggestion-item"
          }, [
            createBaseVNode("div", _hoisted_4$1, [
              (item.icon==1)
                ? (openBlock(), createElementBlock("img", _hoisted_5))
                : createCommentVNode("", true),
              (item.icon==2)
                ? (openBlock(), createElementBlock("img", _hoisted_6))
                : createCommentVNode("", true),
              (item.icon==3)
                ? (openBlock(), createElementBlock("img", _hoisted_7))
                : createCommentVNode("", true),
              (item.icon==4)
                ? (openBlock(), createElementBlock("img", _hoisted_8))
                : createCommentVNode("", true),
              (item.icon==5)
                ? (openBlock(), createElementBlock("img", _hoisted_9))
                : createCommentVNode("", true),
              (item.icon==6)
                ? (openBlock(), createElementBlock("img", _hoisted_10))
                : createCommentVNode("", true),
              (item.icon==7)
                ? (openBlock(), createElementBlock("img", _hoisted_11))
                : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_12, [
                createBaseVNode("div", _hoisted_13, toDisplayString(item.title), 1),
                createBaseVNode("div", _hoisted_14, [
                  createBaseVNode("span", _hoisted_15, toDisplayString(item.value), 1),
                  createBaseVNode("span", _hoisted_16, toDisplayString(item.unit), 1)
                ])
              ])
            ])
          ]))
        }), 128))
      ])
    ])
  ]))
}
}

};
const EnergyStatistics = /*#__PURE__*/_export_sfc(_sfc_main$4, [['styles',[_style_0$3]],['__scopeId',"data-v-ce0c153d"]]);

const _imports_0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD4AAAA+CAYAAABzwahEAAAAAXNSR0IArs4c6QAACGdJREFUaEPlm3tspFUVwM/5pnZb7CwskUAI6nYCrlQLne/eoZR1sckaIo8IihV87K4RiPiK4hsSEdzoGkkW/oDgC1ZAN+KCLBpZExUboZR27pnpllARWnysG3WVhKaw7bbTe5zTzDSz0/tN5/HN0NGbzF9zv3PO75773cc550P4P21Yb+6+vr6TM5mMb609m5k7EXEDAHQw80miGxFfBoCXEfGwtfYFRByPRqN/HBwczNTTtnqAe1rrC621VyLiVgB4q/BVCDEDAE8AwK9bWloeGRkZ+XuFz6/avVKDAgXG4/E3e573cQD4MAC8aVXN5XdgRHwcAL7b0dGxP6yZUDN4IpGIWWu/DgAfAoCW8nmq6jmFiLs6Ojruq3UAqgbv6+trn5+fvxEAvgwA66rCqP6hCQC4koieq1ZEVeC+729BxPsAoLNaxTU+tzcWi23ft2/fYrVyKgX3lFLi4Z0VTusXAcBkX4fnmXnK87xXcqs5MPOJ1trTEHETAPQAwLkAsL4EUM3QS7tJuSPW39/fNjMzsxcA3lvGMwwATwLAXmvtgXQ6/dcynlnqMjAwEJmcnDwPEa9AxA8CwBsLng0Fumzwnp6ekzzP24+I71wF4Bgi/tBae0cqlZosFzaonwzC1NTU5Yj4FQCYrHV6F+pZ1eNKqRMAQLaT3lIgzPxTMZCI/lYrcMDzHgDYsGSXBO/q6mptb29/BAAuKaHwn4h4jTHmsbCMaoSckuBKqe8DwHVBhiDiHyKRyAdGRkb+1Qhjw9QRCK613p49W8uWFdQemp6e/sjk5OSxMA1qlCwneE9Pz8ZIJDIOANEAQ34Si8V21LKPNgowcLa6/vB9/1FEfI/rP2b+xdzc3MDExMT8a218OfrFiWNjY38p7rvC477vX4aIvwwQ+qe2trbE0NCQ3J7WfNNaf4eZxYHdRLRQajuTk5lM8bc5qOY8z+tLJpNja54YAHLQXxJbEfEzxpg7A8F9338fIj4cMMVvSaVStzYDtFLqNgD4YoGth2ZnZ88sfD2Pm+q+748iYsIBNxmNRrsHBwfn1jq4A3rJZETcbox5IG//Mrjv++cg4kEXGCLuMMbcv9ahxT6l1HA2cnN+sa3M/FQqldq8AjxopADgxWg0uqnWi3+jBq3U67q4uPiWsbGxF5ZmQN4gpZScsQtvQvm/biKiXY0yPAQ9skALXMwh60Yi+vYyuNZ6EzO7ohnW87yNyWTyUAgGNUyEUkoc9dVihXLENsYs3TCXPK6Uuh4A7nZY9jQR9TXM4pAUJRKJhLV21CHuWGtr64bh4eHZPPiPc9HR4r67iOimkOxppBhUSv0j68xTi5Vaay9Ip9PDeXA5tHQ7psYlxpgDjbQ4LF1KqZ+7okWIeL0x5nt58FcA4PWO0dlYSdgoLKPDkKOU+gYAfM0hazcRfQF7e3vXZzKZaUeHOSKSwQgt6hEGULkylFI7AOBHjln8oDHmankXJOvhCgYeIqIwMyLl2hxKP6315cy83wH+O2PMuzAej3d5nvesQ9sEEbkuK6EYVm8hWut+Zv69Q8+TRLRFPC6Lmixuxe0ZIjqn3gbWS34ikbjAWjvkkD9CROej7/tnI6KkZIrbs0T09noZVm+58Xh8q+d5vw30eDweP93zvMOODkeIaMU+WG+Dw5If9I4DwGNEdCn29/e3zMzMyHUzUqSUo9HoCc1wFXUNltb6Bmbe7Vjc9hhjPpbfx50XFGttTzqddl5Vw/JMveQopeQILkfx4nYzEe1cAtdaH2DmdztG51pjzD31Mq6ecoOCKog4YIx5KO9x520me7W7n4jkINBUTXJ9kUjkP47XVzjOJKKpvMcvZmZXCuhILBY7vdni5yWCEcuHsiXwzZs3R+fm5mSEWh3T/SJjzG+ayeVKKcn3XeGweXkGF0ZgfhWQHPwZEV3VLOBKqTdk832yPa9wYjbYcnUqlXpQWAqDjR9FxD0OwMzi4uJZrmzEWhwMrfU3mdkVQ3h1YWHh1PHx8VePA8/lwWWklgrvChsift4Yc/taBC20qbu7e0Nra6uUnaxgYOZ7U6nUNfn+xXH13Yh4QxFgaOUX9R44pdRdAPBJhx4pTTmXiJ5xgueOr1MA0Jbr0DTQuTibxNSLT6CC8igRHbfYrUgaaq1vZ+bPSeFOmDUn9fR2LphCske7vG2tPS+dTkvV1XJbAS7vybp163Z2dnZ+tkn2b7lay0o9EDC49xDRtSvWrXp6ohGytdZ3MvOnAnS9FIlENo2Ojr70vwQunv6WK3GwvIDlzuWuQVm13KsRXqtUh1LqdbkEyPL25NiC7zLGfDpIdtOB9/b2npHJZKTCcksgFOLw0aNH+0uVqzQTuHwAcB0zy/Q+ucQskb16CxG5QubBq3ql066wv9Z628LCwuMHDx50hbKqFq21vthae2tA0UKh3OdbWlq2lvNFQ2geL6g5kbo3Ke/8gTHmKQCQU1PFraurq6Otre39iCjvqVpNADMns79L0+n0v1frK/+HAl5YaFOkVBIVByQ9i4gjyWRSyq6cmRml1IlSus3MUjMr37JcBADt5UBky733z87ObpuYmJBUWFmtZvAS0C4DZDYcka+Ocj+5OkqR8CnZb05OK8vi4zstSOGwMeaOSmdWTeBKqZuzs+a1qoR62vO8T1RbflYruFz6BVwKfWVvbUSThfOWbF7v3loSmjWB5ylzta/yycY2+ZiuTvRyz75tenp6TxiFw6GA50FlgZLPsJj5KkR8R8AVsZJxkdLRh5n5gVQqNViLh4uVhgpeKDwej5/ieZ5kLC9ERPnIRpKTMjBBTT6p/DMiPsfMcoV8YnZ2dqhexcJ1A3fRyb15fn7+DERsR8T1iMjW2hlrrdyiDhcX2lYyNSrt+1+F/xxsI6bRyAAAAABJRU5ErkJggg==";

const _style_0$2 = ".select-wrapper[data-v-e28c4872]{margin:10px 0;position:relative}.refresh-wrapper[data-v-e28c4872]{position:absolute;top:-40%;right:85px}.refresh-icon[data-v-e28c4872]{position:absolute;top:87%;width:23px;height:23px}.refresh-text[data-v-e28c4872]{width:40px;position:absolute;top:22px;left:26px;font-size:16px;color:#333}.custom-select[data-v-e28c4872]{border:1px solid #e5e7eb;border-radius:4px;background-color:#fff;font-size:14px;appearance:none;cursor:pointer;transition:border-color .3s ease;width:76%;padding:8px 12px;box-sizing:border-box}.custom-select[data-v-e28c4872]:focus{outline:none;border-color:#4f46e5;box-shadow:0 0 0 2px #4f46e533}.custom-select option[data-v-e28c4872]{padding:8px;font-size:14px}.select-icon[data-v-e28c4872]{position:absolute;right:12px;font-size:12px;color:#6b7280;pointer-events:none}.select-container:hover .select-icon[data-v-e28c4872],.select-container:focus-within .select-icon[data-v-e28c4872]{color:#4f46e5}@media (max-width: 768px){.select-wrapper[data-v-e28c4872]{width:100%}}";

const _hoisted_1$2 = { class: "select-wrapper" };
const _hoisted_2$1 = ["value"];

const _sfc_main$3 = {
  __name: 'SelectDropdown',
  props: {
  options: {
    type: Array,
    required: true,
    default: () => []
  },
  selectOptionsName: {
    type: Object,
    default: () => ({})
  },
  hass: {
    type: Object,
    required: true,
    default: () => ({})
  }
},
  emits: ['change', 'refresh'],
  setup(__props, { emit: __emit }) {

const props = __props;
const emits = __emit;

// 使用计算属性获取第一个选项的id作为初始值
const selectedId = computed({
  get() {
    console.log('111111111111', props.selectOptionsName.number.value);
    const value = props.selectOptionsName.number.value;
    console.log('当前值:', value);
    return props.options.length > 0 ? props.options[0].id : '';
  },
  set(value) {
    console.log('选择', value);
    emits('change', value);
  }
});

const handleChange = (e) => {
  emits('change', e.target.value);
};
// 触发刷新事件
const emitRefresh = () => {
  emits('refresh');
};


onMounted(() => {
  console.log('下拉框初始化，当前选中:', selectedId.value,
  );
});



return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", _hoisted_1$2, [
    withDirectives(createBaseVNode("select", {
      "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((selectedId).value = $event)),
      onChange: handleChange,
      class: "custom-select"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, (option) => {
        return (openBlock(), createElementBlock("option", {
          style: {"padding":"8px 12px"},
          value: option.id,
          key: option.id
        }, toDisplayString(option.plantName), 9, _hoisted_2$1))
      }), 128))
    ], 544), [
      [vModelSelect, selectedId.value]
    ]),
    createBaseVNode("div", {
      class: "refresh-wrapper",
      onClick: emitRefresh
    }, _cache[1] || (_cache[1] = [
      createBaseVNode("div", { class: "refresh-icon" }, [
        createBaseVNode("img", {
          src: _imports_0,
          alt: "",
          class: "refresh-icon"
        })
      ], -1),
      createBaseVNode("div", { class: "refresh-text" }, [
        createBaseVNode("div", null, "refresh")
      ], -1)
    ]))
  ]))
}
}

};
const SelectDropdown = /*#__PURE__*/_export_sfc(_sfc_main$3, [['styles',[_style_0$2]],['__scopeId',"data-v-e28c4872"]]);

const _style_0$1 = "body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#f8fafc}.app{display:flex;flex-direction:column;min-height:100vh}.main-content{flex:1;padding:20px 0}.container{max-width:1400px;margin:0 auto;padding:0 20px}.grid-layout{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px;margin-top:20px}@media (max-width: 768px){.grid-layout{grid-template-columns:1fr;margin-top:20px}}.unconfigured-message{display:flex;justify-content:center;align-items:center;min-height:60vh;padding:20px}.message-card{background-color:#fff;border-radius:16px;box-shadow:0 10px 25px -5px #0000000d,0 8px 10px -6px #00000005;padding:40px;text-align:center;max-width:400px;width:100%;animation:fadeIn .5s ease-in-out}@keyframes fadeIn{0%{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}.icon-container{margin-bottom:20px;color:#4f46e5}.message-card h2{color:#1e293b;font-size:1.5rem;margin-bottom:10px}.message-card p{color:#64748b;margin-bottom:25px}.btn-configure{background-color:#4f46e5;color:#fff;border:none;border-radius:8px;padding:12px 24px;font-size:1rem;cursor:pointer;transition:all .3s ease;box-shadow:0 4px 6px -1px #4f46e533}.btn-configure:hover{background-color:#4338ca;transform:translateY(-2px);box-shadow:0 6px 12px -2px #4f46e54d}.btn-configure:active{transform:translateY(0);box-shadow:0 2px 4px -1px #4f46e533}.mr-2{margin-right:8px}";

const _hoisted_1$1 = { class: "app" };
const _hoisted_2 = { class: "main-content" };
const _hoisted_3 = { class: "container" };
const _hoisted_4 = { class: "grid-layout" };

// 定义 props

const _sfc_main$2 = {
  __name: 'App',
  props: {
  hass: {
    type: Object,
    required: true,
    default: () => ({})
  },
  config: {
    type: Object,
    default: () => ({})
  },
  locale: String
},
  setup(__props) {

const props = __props;
const headerRef = ref(null);
const selectDropdownRef = ref(null);
const curDeviceSn = ref('');
const zeroFeed = ref("");

/**
 * ha绑定当前电站
 */
const selectOptionsName = ref({
  number: { value: '0w' },
});
/**
 * 电站列表
 */
const selectOptions = ref([

]);
/**
 * 切换电站
 */
const handleSelectChange = (value) => {
  console.log('父级处理');
  const plantValue = Number(value);
  props.hass.callService('ha_ems', 'service_switch_plant', {
    plant_id: plantValue,
    device_sn: curDeviceSn.value
  });
};

const modeData = ref({
  mode: { value: 'close' }
});

/**
 * 流动图数据处理
 */
const powerData = ref({
  solar: { label: '光伏功率', value: '0w', unit: '' },
  smartDevice: { label: '智能设备功率', value: '0W', unit: '' },
  grid: { label: '电网功率', value: '0W', unit: '' },
  battery: { label: '电池功率', value: '0W', unit: '' },
  batterySoc: { label: '电池SOC', value: '0%', unit: '' },
  totalLoad: { label: '总负载功率', value: '0W', unit: '' },
  solarWorkMode: { value: 0 },
  loadWorkMode: { value: 0 },
  gridWorkMode: { value: 0 },
  batWorkMode: { value: 0 },
  homeWorkMode: { value: 0 },
});

/**
 * 设备列表
 */
const smartDeviceDataList = ref({
  smartDevice: [],
});
/**
 * 设备详情列表
 */
const smartDeviceDetails = ref({
  smartDeviceDetailsList: [],
});


/**
 *  定义能源数据（可根据需求扩展）
 */

const energyData = ref([
  {

    title: 'Solar',
    icon: '1', // 太阳图标
    value: '',
    unit: 'kWh',
    desc: '将太阳能转化电能，用于电池充电或负载供电的能源'
  },
  {
    title: 'Load',
    icon: '2', // 工业图标
    value: '',
    unit: 'kWh',
    desc: '负载所消化的能源'
  },
  {
    title: 'Gird',
    icon: '3', // 电源图标
    value: '',
    unit: 'kWh',
    desc: '累计从电网买到的能源'
  },
  {
    title: 'Grid',
    icon: '4', // 电源图标
    value: '',
    unit: 'kWh',
    desc: '累计给电网出售的能源'
  },
  {
    title: 'Bat',
    icon: '5', // 电池充电图标
    value: '',
    unit: 'kWh',
    desc: '累计给电池充电的电能能源'
  },
  {
    title: 'Bat',
    icon: '6', // 电池充电图标
    value: '',
    unit: 'kWh',
    desc: '累计电池放电的电能能源'
  },
  {
    title: 'Income',
    icon: '7', // 货币图标
    value: '',
    unit: '',
    desc: '今日收益'
  }
]);

/**
 * 检测更新数据
 */
function updatePowerData() {
  try {
    console.error('[ha-vue-card] 数据2', props.hass.states);
    const states = props.hass.states;
    // 定义辅助函数处理值转换 
    function getValue(stateValue) {
      return stateValue === 'unknown' ? 0 : stateValue || 0;
    }

    function mergeTableData(tableData1, tableData2, tableData3) {
      return [...tableData1, ...tableData2, ...tableData3];
    }

    powerData.value.solar.value = getValue(states["sensor.plant_name"].attributes.data.solarPower);
    powerData.value.smartDevice.value = getValue(states["sensor.plant_name"].attributes.data.loadPower);
    powerData.value.grid.value = getValue(states["sensor.plant_name"].attributes.data.gridPower);
    powerData.value.battery.value = getValue(states["sensor.plant_name"].attributes.data.batPower);
    powerData.value.batterySoc.value = getValue(states["sensor.plant_name"].attributes.data.batSoc);
    powerData.value.totalLoad.value = getValue(states["sensor.plant_name"].attributes.data.homeAllPower);
    powerData.value.solarWorkMode.value = getValue(states["sensor.plant_name"].attributes.data.solarWorkMode);
    powerData.value.loadWorkMode.value = getValue(states["sensor.plant_name"].attributes.data.loadWorkMode);
    powerData.value.gridWorkMode.value = getValue(states["sensor.plant_name"].attributes.data.gridWorkMode);
    powerData.value.batWorkMode.value = getValue(states["sensor.plant_name"].attributes.data.batWorkMode);
    powerData.value.homeWorkMode.value = getValue(states["sensor.plant_name"].attributes.data.homeAllPower.match(/(\d+\.?\d*)/))[0] > 0 ? 1 : 0;


    // 获取设备列表
    const chargerList = states["sensor.plant_name"].attributes.data.chargerList;
    const loadList = states["sensor.plant_name"].attributes.data.loadList;
    const heatPumpList = states["sensor.plant_name"].attributes.data.heatPumpList;

    const deviceList = states["sensor.plant_name"].attributes.data.deviceSn
      ? [{ deviceSn: states["sensor.plant_name"].attributes.data.deviceSn, iconType: 1 }]
      : []; // deviceSn 为空时返回空数组

    const emList = states["sensor.plant_name"].attributes.data.emSn
      ? [{ deviceSn: states["sensor.plant_name"].attributes.data.emSn, iconType: 7 }]
      : [];

    // 将 deviceSn 赋值给 curDeviceSn
    curDeviceSn.value = states["sensor.plant_name"].attributes.data.deviceSn || '';



    console.log('[ha-vue-card] 充电桩列表:', chargerList);
    console.log('[ha-vue-card] 插座列表:', loadList);
    console.log('[ha-vue-card] 热泵列表:', heatPumpList);
    console.log('[ha-vue-card] 设备列表:', states["sensor.plant_name"].attributes.data.deviceSn);
    console.log('[ha-vue-card] 电表列表:', states["sensor.plant_name"].attributes.data.emSn);

    // zeroFeed.value = states["sensor.aisystemstatus"].state
    // console.log('当前模式123', zeroFeed.value);


    // 合并所有非空列表
    const smartDeviceList = [
      ...deviceList, // 直接展开数组，空数组会被自动忽略
      ...emList,
      ...chargerList,
      ...heatPumpList,
      ...loadList,
    ].filter(item => item !== null && Object.keys(item).length > 0); // 过滤无效项
    smartDeviceDataList.value.smartDevice = smartDeviceList;
    console.log('smartDeviceDataList', smartDeviceDataList.value.smartDevice);

    const smartDetails = states["sensor.plant_name"].attributes.devices;
    smartDeviceDetails.value.smartDeviceDetailsList = smartDetails;
    console.log('[ha-vue-card] 智能设备详情总:', smartDeviceDetails.value);    // 合并设备列表并添加设备类型标识

    console.log('[ha-vue-card] 当天电价以及单位:', states["sensor.plant_name"].attributes.data.dayRevenue, states["sensor.plant_name"].attributes.data.dayRevenueUnit);
    console.log('[ha-vue-card] 光伏当天统计:', states["sensor.plant_name"].attributes.data.solarDayElec);
    console.log('[ha-vue-card] 负载当天统计:', states["sensor.plant_name"].attributes.data.loadDayElec);
    console.log('[ha-vue-card] 电网买电当天统计:', states["sensor.plant_name"].attributes.data.gridDayBuyElec);
    console.log('[ha-vue-card] 电网卖电当天统计:', states["sensor.plant_name"].attributes.data.gridDayElec);
    console.log('[ha-vue-card] 电池充电当天统计:', states["sensor.plant_name"].attributes.data.batteryDayElec);
    console.log('[ha-vue-card] 电池放电当天统计:', states["sensor.plant_name"].attributes.data.batteryDayDischargerElec);

    energyData.value[0].value = states["sensor.plant_name"].attributes.data.solarDayElec;
    energyData.value[1].value = states["sensor.plant_name"].attributes.data.loadDayElec;
    energyData.value[2].value = states["sensor.plant_name"].attributes.data.gridDayBuyElec;
    energyData.value[3].value = states["sensor.plant_name"].attributes.data.gridDayElec;
    energyData.value[4].value = states["sensor.plant_name"].attributes.data.batteryDayElec;
    energyData.value[5].value = states["sensor.plant_name"].attributes.data.batteryDayDischargerElec;
    energyData.value[6].value = states["sensor.plant_name"].attributes.data.dayRevenue;
    energyData.value[6].unit = states["sensor.plant_name"].attributes.data.dayRevenueUnit;

    selectOptions.value = states["sensor.plant_name"].attributes.plants;
    selectOptionsName.value.number.value = states["sensor.plant_name"].state;
    zeroFeed.value = states["sensor.aisystemstatus"].state;
    // modeData.value.mode.value = states["sensor.ailu_dian"].state  // 之前的写法
    modeData.value.mode.value = zeroFeed.value;

    console.log('电站列表', selectOptions.value);
    console.log('电站当前Id', selectOptionsName);
    console.log('当前模式', states["sensor.aisystemstatus"].state);


  } catch (error) {
    // console.error('[ha-vue-card] 更新数据时出错:', error);
  }
}

ref(null);

/**
 * 开关
 */
const handleIncrement = (deviceId, deviceSwitch) => {
  console.log('打印打印', deviceId, deviceSwitch);
  props.hass.callService('switch', deviceSwitch, {
    entity_id: deviceId
  })
    .then(() => {
      console.log('设备状态切换成功，开始刷新页面');
      getRefresh();
      console.log("刷新结束了");

    })
    .catch((error) => {
      console.error('设备状态切换失败:', error);
      ElMessage.error(`设备状态切换失败: ${error.message}`);
    });
};

// 刷新方法
const getRefresh = () => {
  console.log('props.hass 对象:', props.hass);
  if (props.hass && typeof props.hass.callService === 'function') {
    props.hass.callService('ha_ems', 'service_refresh_data')
      .then(() => {
        console.log('刷新接口调取成功');
      })
      .catch((error) => {
        console.log('刷新接口调取失败:', error);
      });
  } else {
    console.error('hass 对象或 callService 方法不存在');
  }
};
/**
 * 监听处理
 */
watch(() => props.hass.states, () => {
  updatePowerData();
}, { deep: true });
onMounted(() => {
  // console.error('[ha-vue-card] 数据1', props.hass);
  console.error('[ha-vue-card] 数据2', props.hass.states);
  console.error('[ha-vue-card] 数据3', props.hass.states["sensor.plant_name"]);
  updatePowerData();
  // handleSelectChange(props.hass.states["sensor.plant_name"].attributes.plants[0].id)
  handleSelectChange(props.hass.states["sensor.plant_name"].attributes.cur_plant);

});

return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", _hoisted_1$1, [
    createVNode(Header, {
      ref_key: "headerRef",
      ref: headerRef
    }, null, 512),
    createBaseVNode("main", _hoisted_2, [
      createBaseVNode("div", _hoisted_3, [
        createVNode(SelectDropdown, {
          ref_key: "selectDropdownRef",
          ref: selectDropdownRef,
          options: selectOptions.value,
          selectOptionsName: selectOptionsName.value,
          onChange: handleSelectChange,
          onRefresh: getRefresh
        }, null, 8, ["options", "selectOptionsName"]),
        createVNode(FlowDiagram, { powerData: powerData.value }, null, 8, ["powerData"]),
        createBaseVNode("div", _hoisted_4, [
          createVNode(AIControl, { modeData: modeData.value }, null, 8, ["modeData"]),
          createVNode(DeviceControl, {
            onIncrement: handleIncrement,
            smartDeviceDataList: smartDeviceDataList.value.smartDevice,
            smartDeviceDetails: smartDeviceDetails.value.smartDeviceDetailsList
          }, null, 8, ["smartDeviceDataList", "smartDeviceDetails"])
        ]),
        createVNode(EnergyStatistics, { energyData: energyData.value }, null, 8, ["energyData"]),
        createVNode(EnergyCharts, {
          hassStates: props.hass.states,
          hass: __props.hass
        }, null, 8, ["hassStates", "hass"])
      ])
    ])
  ]))
}
}

};
const App = /*#__PURE__*/_export_sfc(_sfc_main$2, [['styles',[_style_0$1]]]);

const _sfc_main$1 = {  };

function _sfc_render(_ctx, _cache) {
  return renderSlot(_ctx.$slots, "default")
}
const I18nHost = /*#__PURE__*/_export_sfc(_sfc_main$1, [['render',_sfc_render]]);

const _style_0 = ".child-container[data-v-2e61f8a9]{margin-top:16px;padding:16px;border:1px solid #ccc;border-radius:4px}";

const _hoisted_1 = { class: "child-container" };


const _sfc_main = {
  __name: 'ha-vue-card',
  emits: ['increment', 'reset'],
  setup(__props, { emit: __emit }) {

const emit = __emit;

const incrementParent = () => {
  emit('increment',1,2);
};

const resetParent = () => {
  emit('reset');
};

return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", _hoisted_1, [
    _cache[0] || (_cache[0] = createBaseVNode("h4", null, "子组件", -1)),
    createBaseVNode("button", { onClick: incrementParent }, "增加父组件计数"),
    createBaseVNode("button", { onClick: resetParent }, "重置父组件计数")
  ]))
}
}

};
const HaVueCard = /*#__PURE__*/_export_sfc(_sfc_main, [['styles',[_style_0]],['__scopeId',"data-v-2e61f8a9"]]);

HaVueCard.observedAttributes = ['hass', 'config'];

console.log('[hapack] 开始初始化面板组件');
// 创建i18n实例
// https://vue-i18n.intlify.dev/guide/advanced/wc.html#web-components
const I18nHostElement = defineCustomElement(I18nHost);
customElements.define('i18n-host', I18nHostElement);
const HaVueCardElement = defineCustomElement(HaVueCard);
customElements.define('ha-vue-card', HaVueCardElement);
// 定义需要观察的属性


// 将Vue组件转换为Web Component
const AeccHaPanel = defineCustomElement(App);
customElements.define('ha-ems-panel', AeccHaPanel);
// 注册面板组件
console.log('[hapack] 注册面板组件 ha_ems-panel');
console.log('[hapack] 面板组件注册完成');
